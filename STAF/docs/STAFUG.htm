<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>STAF V3 User&#39;s Guide</TITLE>
<!-- Begin Header Records  ========================================== -->
<!-- /opt/dev/autobuild/build/obj/linux/staf/retail/docs/staf/usergui -->
<!-- de/STAFUG.script converted by b2h R4.3 (362) (LINUX) on 31 Dec   -->
<!-- 2016 at 17:10:43                                                 -->
<META HTTP-EQUIV="updated" CONTENT="Sat, 31 Dec 2016 17:10:43">
<META HTTP-EQUIV="review" CONTENT="Sun, 31 Dec 2017 17:10:43">
<META HTTP-EQUIV="expires" CONTENT="Mon, 31 Dec 2018 17:10:43">
</HEAD><BODY BGCOLOR=WHITE>
<!-- End Header Records  ============================================ -->
<A NAME="Top_Of_Page"></A>
<H1>STAF V3 User&#39;s Guide</H1>
<P>
<B>Software Testing Automation Framework (STAF) User's Guide</B><BR>
<B>Version 3.4.26</B><BR>
<P>31 Dec 2016
<HR><H1><A NAME="ToC">Table of Contents</A></H1>
<P><B><A NAME="ToC_1" HREF="#HDROVERVIEW">1.0 Overview</A></B><BR>
<MENU>
<LI><A NAME="ToC_2" HREF="#HDRREQUIREMENTS">1.1 Requirements</A>
</MENU>
<P><B><A NAME="ToC_4" HREF="#HDRCONCEPTS">2.0 Concepts</A></B><BR>
<MENU>
<LI><A NAME="ToC_5" HREF="#HDRHNDLCON">2.1 Handles</A>
<LI><A NAME="ToC_6" HREF="#HDRSRVCON">2.2 Services</A>
<LI><A NAME="ToC_7" HREF="#HDRWKLDCON">2.3 Workloads</A>
<LI><A NAME="ToC_8" HREF="#HDRVARCON">2.4 Variables</A>
<LI><A NAME="ToC_10" HREF="#HDRTRSTCON">2.5 Security</A>
<LI><A NAME="ToC_11" HREF="#HDRQUEUECON">2.6 Queues</A>
<LI><A NAME="ToC_12" HREF="#HDRSTRINGCON">2.7 Strings and Codepages</A>
</MENU>
<P><B><A NAME="ToC_15" HREF="#HDRINSTALL">3.0 Installation</A></B><BR>
<P><B><A NAME="ToC_16" HREF="#HDRCONFIG">4.0 Configuration</A></B><BR>
<MENU>
<LI><A NAME="ToC_17" HREF="#HDRCOMMENTSCFG">4.1 Comments</A>
<LI><A NAME="ToC_20" HREF="#HDRMACHINECFG">4.2 Machine Nickname</A>
<LI><A NAME="ToC_24" HREF="#HDRNETWORKCFG">4.3 Network Interfaces</A>
<LI><A NAME="ToC_31" HREF="#HDRSERVICEREGCFG">4.4 Service Registration</A>
<LI><A NAME="ToC_41" HREF="#HDRSERVICELOADERCFCG">4.5 Service Loader Registration</A>
<LI><A NAME="ToC_53" HREF="#Header_53">4.6 Authenticator Registration</A>
<LI><A NAME="ToC_60" HREF="#HDROPPARMS">4.7 Operational parameters</A>
<LI><A NAME="ToC_64" HREF="#HDRVARCFG">4.8 Variables</A>
<LI><A NAME="ToC_68" HREF="#HDRTRUSTCFG">4.9 Trust</A>
<LI><A NAME="ToC_74" HREF="#HDRNOTIFYCFG">4.10 Start/Shutdown Notifications</A>
<LI><A NAME="ToC_78" HREF="#HDRTRACECFG">4.11 Tracing</A>
<LI><A NAME="ToC_82" HREF="#HDREXAMPLESCFG">4.12 Configuration File Examples</A>
<LI><A NAME="ToC_85" HREF="#HDRTUNECFG">4.13 Tuning</A>
<LI><A NAME="ToC_88" HREF="#HDRDATADIRCFG">4.14 Data Directory Structure</A>
</MENU>
<P><B><A NAME="ToC_90" HREF="#HDRCOMMANDS">5.0 Commands</A></B><BR>
<MENU>
<LI><A NAME="ToC_91" HREF="#HDRSTPROC">5.1 STAFProc</A>
<LI><A NAME="ToC_96" HREF="#HDRSTAFEXECMD">5.2 STAF</A>
</MENU>
<P><B><A NAME="ToC_102" HREF="#HDRAPIREF">6.0 API Reference</A></B><BR>
<MENU>
<LI><A NAME="ToC_103" HREF="#HDRMARSHALL">6.1 Marshalling Structured Data</A>
<LI><A NAME="ToC_104" HREF="#HDRCAPI">6.2 C</A>
<LI><A NAME="ToC_133" HREF="#HDRC++API">6.3 C++</A>
<LI><A NAME="ToC_144" HREF="#HDRREXXAPI">6.4 Rexx</A>
<LI><A NAME="ToC_173" HREF="#HDRJAVAAPI">6.5 Java</A>
<LI><A NAME="ToC_174" HREF="#HDRPERLAPI">6.6 Perl</A>
<LI><A NAME="ToC_175" HREF="#HDRPYTHONAPI">6.7 Python</A>
<LI><A NAME="ToC_176" HREF="#HDRTCLAPI">6.8 Tcl</A>
</MENU>
<P><B><A NAME="ToC_177" HREF="#HDRSERVICE">7.0 Services overview</A></B><BR>
<MENU>
<LI><A NAME="ToC_178" HREF="#HDRSYNTAXSRV">7.1 General Service Syntax</A>
<LI><A NAME="ToC_179" HREF="#HDROVFORM">7.2 Option Value Formats</A>
<LI><A NAME="ToC_180" HREF="#HDRPRIVATEDATA">7.3 Private Data</A>
<LI><A NAME="ToC_182" HREF="#HDRVARRES">7.4 Variable Resolution</A>
<LI><A NAME="ToC_183" HREF="#HDRSRESDEF">7.5 Service Result Definition</A>
<LI><A NAME="ToC_184" HREF="#HDRSERVICEHELP">7.6 Service Help</A>
<LI><A NAME="ToC_185" HREF="#HDRSERVICELIST">7.7 Service list</A>
</MENU>
<P><B><A NAME="ToC_186" HREF="#HDRSERVICEREF">8.0 Service reference</A></B><BR>
<MENU>
<LI><A NAME="ToC_187" HREF="#HDRCONFIGSRV">8.1 Config Service</A>
<LI><A NAME="ToC_195" HREF="#HDRDELAYSRV">8.2 Delay Service</A>
<LI><A NAME="ToC_202" HREF="#HDRDIAGSRV">8.3 Diagnostics (DIAG) Service</A>
<LI><A NAME="ToC_234" HREF="#HDRECHOSRV">8.4 Echo Service</A>
<LI><A NAME="ToC_242" HREF="#HDRFSSRV">8.5 File System (FS) Service</A>
<LI><A NAME="ToC_326" HREF="#HDRHDLSRV">8.6 Handle Service</A>
<LI><A NAME="ToC_364" HREF="#HDRHELPSRV">8.7 Help Service</A>
<LI><A NAME="ToC_391" HREF="#HDRLIFECYCLESRV">8.8 LifeCycle Service</A>
<LI><A NAME="ToC_443" HREF="#HDRLOGSRV">8.9 Log Service</A>
<LI><A NAME="ToC_489" HREF="#HDRMISCSRV">8.10 Misc Service</A>
<LI><A NAME="ToC_533" HREF="#HDRMONSRV">8.11 Monitor Service</A>
<LI><A NAME="ToC_570" HREF="#HDRPINGSRV">8.12 Ping Service</A>
<LI><A NAME="ToC_578" HREF="#HDRPROCSRV">8.13 Process Service</A>
<LI><A NAME="ToC_637" HREF="#HDRQUEUESRV">8.14 Queue Service</A>
<LI><A NAME="ToC_663" HREF="#HDRRESSRV">8.15 Resource Pool (ResPool) Service</A>
<LI><A NAME="ToC_725" HREF="#HDRSEMSRV">8.16 Semaphore (SEM) Service</A>
<LI><A NAME="ToC_789" HREF="#HDRSRVSERVICE">8.17 Service Service</A>
<LI><A NAME="ToC_821" HREF="#HDRSHUTDS">8.18 Shutdown Service</A>
<LI><A NAME="ToC_841" HREF="#HDRTRACESRV">8.19 Trace Service</A>
<LI><A NAME="ToC_876" HREF="#HDRTRUSTSRV">8.20 Trust Service</A>
<LI><A NAME="ToC_904" HREF="#HDRVARSERVICE">8.21 Variable (VAR) Service</A>
<LI><A NAME="ToC_936" HREF="#HDRZIPSRV">8.22 Zip Service</A>
</MENU>
<P><B><A NAME="ToC_965" HREF="#HDRUTILS">9.0 Log Utilities</A></B><BR>
<MENU>
<LI><A NAME="ToC_966" HREF="#HDRSTAFLOGVIEWER">9.1 STAF Log Viewer Class</A>
<LI><A NAME="ToC_968" HREF="#HDRSTAFJVMLOGVIEWER">9.2 JVM Log Viewer Class</A>
<LI><A NAME="ToC_970" HREF="#HDRSTAFLOGFORMATTER">9.3 STAF Log Formatter Class</A>
<LI><A NAME="ToC_972" HREF="#HDRFMTLOG">9.4 Format Log Utility</A>
</MENU>
<P><B><A NAME="ToC_979" HREF="#HDRRETCODE">Appendix A. API Return Codes</A></B><BR>
<P><B><A NAME="ToC_980" HREF="#HDRCMDREF">Appendix B. Service Command Reference</A></B><BR>
<P><B><A NAME="ToC_981" HREF="#HDRSAMPREF">Appendix C. Samples Descriptions</A></B><BR>
<P><B><A NAME="ToC_982" HREF="#HDRCODE">Appendix D. Code Samples and Snipets</A></B><BR>
<MENU>
<LI><A NAME="ToC_983" HREF="#HDRJAVASAMP">D.1 Java</A>
<LI><A NAME="ToC_985" HREF="#HDRREXXSAMP">D.2 Rexx</A>
<LI><A NAME="ToC_991" HREF="#HDRCSAMP">D.3 C</A>
<LI><A NAME="ToC_993" HREF="#HDRC++SAMP">D.4 C++</A>
</MENU>
<P><B><A NAME="ToC_995" HREF="#HDRINDEX_START">Index</A></B><BR>
<P><B><A NAME="ToC_996" HREF="#HDRSTAFUGEND">End Of Document</A></B><BR>
<P>
<P>
<A NAME="IDX1"></A>
<HR><H1><A NAME="HDROVERVIEW" HREF="#ToC_1">1.0 Overview</A></H1>
<P>As its name indicates, STAF is a framework.  It was designed to promote
reuse and extensibility.  It is intended to make software testing easier, and
specifically to make it easier to automate software testing.  This includes
creating automated testcases, managing and automating the test environment,
creating execution harnesses (i.e., applications which schedule and/or execute
work on test systems), etc.
<P>STAF externalizes its capabilities through services.  A service provides
a focused set of functionality, such as, Logging, Process Invocation, etc.
STAFProc is the process that runs on a machine, called a STAF Client, which
accepts requests and routes them to the appropriate service.  These requests
may come from the local machine or from another STAF Client.  Thus, STAF works
in a peer environment, where machines may make requests of services on other
machines.
<P>STAF was designed with the following points in mind.
<UL COMPACT>
<LI>Minimum machine requirements - This is both a hardware and a software
statement.
<LI>Easily useable
<LI>Easily extendable - This means that it should be easy to create other
services to plug into STAF.
</UL>
<A NAME="IDX2"></A>
<HR><H2><A NAME="HDRREQUIREMENTS" HREF="#ToC_2">1.1 Requirements</A></H2>
<P><H3><A NAME="Header_3">1.1.1 Operating System</A></H3>
<P>STAF is supported on the following operating systems
<UL COMPACT>
<LI>Windows 2000
<LI>Windows XP
<LI>Windows Server 2003 (i386, x86_64)
<LI>Windows Vista (i386, x86_64)
<LI>Windows Server 2008 (i386, x86_64)
<LI>Windows 7 (i386, x86_64)
<LI>Windows Server 2008 R2 (x86_64)
<LI>Windows 8 (i386, x86_64)
<LI>Windows Server 2012 (x86_64)
<LI>Windows 8.1 (i386, x86_64)
<LI>Windows Server 2012 R2 (x86_64)
<LI>Windows 10 (i386, x86_64)
<LI>Linux (i386, x86_64, PPC64, PPC64LE)
<LI>Linux on zSeries (31-bit, 64-bit)
<LI>AIX 6.1 and higher (32-bit, 64-bit)
<LI>IBM i 7.1 and higher (32-bit, 64-bit), previously known as i5/OS or OS/400
<LI>z/OS UNIX 1.4 and higher (32-bit, 64-bit)
<LI>Mac OS X 10.10 and higher (Universal binary with support for i386 and x86_64)
<LI>Solaris (Sparc 32-bit) 10 and higher
<LI>Solaris (Sparc 64-bit) 10 and higher
<LI>Solaris (AMD Opteron 64-bit) 10 and higher
<LI>Solaris (x86) 10 and higher
<LI>HP-UX 11.11 and higher (PA-RISC) 32-bit and 64-bit
<LI>HP-UX 11.31 and higher (IA64) 32-bit and 64-bit
<LI>FreeBSD 7.4 and higher (i386)
</UL>
<P>
<A NAME="IDX4"></A>
<HR><H1><A NAME="HDRCONCEPTS" HREF="#ToC_4">2.0 Concepts</A></H1>
<HR><H2><A NAME="HDRHNDLCON" HREF="#ToC_5">2.1 Handles</A></H2>
<P>A handle is a unique identifier, representing a given process.  This
handle is used when submitting requests to STAF.  This handle, combined with
the machine name, uniquely identifies a particular process in the STAF
Environment.  It is this combination of machine/handle that allows
services to track requests from multiple processes on different machines.
<P>In order to submit service requests to STAF, a process must have a handle.
Thus, the first thing a process should do is register with STAF to obtain a
handle.  Other data tied to this handle is the following:
<UL COMPACT>
<LI>Name - a descriptive name associated with the handle, which is specified
when a process registers with STAF.
<LI>Last used date/time - a timestamp of the last time the handle was used to
submit a request.
<LI>User authentication information - user authentication information
associated with the handle if the handle has been authenticated
<LI>Variable pool - a means by which to store and retrieve information that the
process may use, such as configuration data.
<LI>Queue - a priority queue used for interprocess communication between other
processes/machines using STAF.
</UL>
<P>Before a process exits it should unregister with STAF to free up any
resources used by that handle.
<P><B>Note: </B>Handle 1 is always allocated to the STAF Process itself.  The name
associated with this handle is STAF_Process.
<P>
If STAFProc is shutdown on a machine (or the machine is rebooted), STAF handles
for that machine are deleted.
<P>  
The SEM and RESPOOL services perform garbage collection for handles that have
been deleted by default, unless you specified no garbage collection when
requesting a mutex semaphore or resource pool entry.  Performing garbage
collection means that when a handle is deleted, any mutex semaphores or
resource pool entries owned by the handle will be released and any pending
requests submitted by the handle will be removed.
<A NAME="IDX7"></A>
<HR><H2><A NAME="HDRSRVCON" HREF="#ToC_6">2.2 Services</A></H2>
<P>Services are what provide all the capability in STAF.  Services may be
internal services, in which case, the executable code for the service resides
within STAFProc.  Services may also be external services, in which case, the
executable code for the service resides outside of STAFProc, for example, in
a Java routine.
<P>Services are known by their name, such as PROCESS or LOG.  Internal
services are always available and have a fixed name.  External services must
be registered, and the name by which they are known is specified when they are
registered.  If an external service is not registered with STAF, then the
service is not available on that STAF Client.
<P>Services may also be delegated to another STAF Client.  In this case, when
a request is made for the service on the local STAF Client, it is automatically
forwarded to the machine to which this service has been delegated.  For example,
a testcase may request the local machine to log some information via the LOG
service.  If the LOG service has been delegated to another machine, the
LOG request will actually be handled by the machine to which logging has
been delegated.  In this way, all logs could be conveniently stored on one
system, without the testcases needing to explicitly send their LOG requests
to the common system.  In a similar manner, if a service were only available
on a specific operating system, then all testcases could assume that the
service was available locally, when, in fact, the service was being delegated
to the machine running the required operating system.
<P><B>Note: </B>Internal services may not be delegated.
<P>External services and delegated services are both registered in the STAF
Configuration File.  External services also may be dynamically added (registered)
or removed (unregistered and terminated) 
via the SERVICE service (see <A HREF="#HDRSRVSERVICE">8.17, "Service Service"</A>).
<A NAME="IDX9"></A>
<A NAME="IDX10"></A>
<P>Service loaders are external services whose purpose is to load services on-demand.
They allow services to be loaded only when they have been requested,
so they don't take up memory until needed.
They also allow dynamic service registration when a request is made so that
you don't have to change the STAF configuration file to register a
service.
<P>When a request is encountered for a service that doesn't exist,
STAF will call each service loader, in the order they were
configured, until the service exists or we run out of service loaders.
If we run out of service loaders, then the standard
RC 2 (DoesNotExist) will be returned indicating that the service is not registered.
Otherwise, the request will be sent to the newly added service.
If a service is currently being attempted to be loaded by a service loader,
any requests submitted to the service while it's being loaded will wait
until the attempt to load the service has completed.  If the service was loaded,
the request will be sent to the newly added service.  If the service wasn't loaded,
RC 2 (DoesNotExist) will be returned indicating that the service is not registered.
<P>STAF ships two service loader services:
<OL TYPE=1>
<P><LI>A default service loader service called STAFDSLS which is written in C++ and
can dynamically load the Log, Zip, Monitor, and ResPool C++ services.  This service
loader is configured automatically in the default STAF.cfg file.
See section <A HREF="#HDRSTAFDSLS">4.5.2, "Default Service Loader Service (STAFDSLS)"</A> for more information about the default
service loader service.
<P><LI>A HTTP service loader service called STAFHTTPSLS which is written in Java and
can dynamically load any STAF services written in Java.  It can download the
jar file for a STAF Java service (or a zip file that contains the jar file)
from a web server or from a file on the local machine.  It uses a configuration
file to determine what services it can load.  This service loader service can
reduce the maintenance for managing STAF Java services.
See section <A HREF="#HDRSTAFHTTPSLS">4.5.3, "HTTP Service Loader Service (STAFHTTPSLS)"</A> for more information about the HTTP
service loader service.
</OL>
<P>
<A NAME="IDX12"></A>
<P>Authenticators are special external services whose purpose is to
authenticate users in order to provide user level trust, which can be used
in addition (or instead of) machine level trust.  An Authenticator is a
special service that accepts an authenticate request.  As a user, you
cannot directly submit a request to an authenticator service.
Authenticators are accessed indirectly via the Handle service.
<P>Authenticators can only be registered in the STAF configuration file --
they cannot be dynamically registered.  One or more Authenticators can be
registered.  The first Authenticator registered is the default, unless
overridden by using the DEFAULTAUTHENTICATOR operational parameter.
If you want to authenticate across systems, you must register the
Authenticator on each system using the same name (case-insensitive).
<A NAME="IDX14"></A>
<HR><H2><A NAME="HDRWKLDCON" HREF="#ToC_7">2.3 Workloads</A></H2>
<P>A workload is a set of processes running on a set of machines.  A workload
may be as simple as a single process running on a single machine, or it may be
as complex as multiple processes on multiple machines coordinating together to
perform a larger complex task.  STAF was designed to help the creation and
automation of workloads of all sizes.
<A NAME="IDX16"></A>
<HR><H2><A NAME="HDRVARCON" HREF="#ToC_8">2.4 Variables</A></H2>
<P>STAF provides a means to store and retrieve variables.  These variables
may be used for any purpose the tester desires, such as storing testcase
configuration parameters.  These variables provide two main capabilities
to testcase writers.  One, they provide a standard means by which to store
configuration data, i.e., each tester doesn't have to figure out how to store
and retrieve said configuration data.  Two, these variables may be changed
dynamically.  For example, if a testcase queries the WebServer variable
before sending a request off to the web server, and that web server goes down,
the WebServer variable can be dynamically changed by the tester to refer to a
different web server, and the testcase can continue execution.  Note how STAF
allows the variable's value to be changed outside of the scope of the running
testcase, thus allowing the testcase to continue execution without needing to
be stopped and restarted.
<P>STAF maintains a "system" variable pool that is common to all
the processes on a given STAF Client.
STAF also maintains a "shared" variable pool which is also system-wide,
but which will be sent across the network and used in variable resolution
on remote systems.
In addition, each process/handle has its own variable pool.
By default, the values of variables in a process' variable pool override the
values of variables in the system and shared variable pools.  However, the
process may override this behavior when asking for the value of a variable.
Basically, as part of every remote request, the originating handle and system 
shared variable pools are sent across the wire. These pools are stored only for 
the duration of the request for use in variable resolution.
<A NAME="IDX17"></A>
<P>The following system variables are predefined:
<UL COMPACT>
<LI>STAF/Config/BootDrive - Indicates the drive from which the machine was
booted
<LI>STAF/Config/CodePage - The codepage used by STAF
<LI>STAF/Config/ConfigFile - The configuration file used to start STAF
<LI>STAF/Config/DefaultAuthenticator - The default authenticator.  If no
authenticators are registered, it's value is "none".
<LI>STAF/Config/DefaultInterface - The default interface.  If no
network interfaces are registered, it's value is "local" to show that
the local interface is the only interface available.
<LI>STAF/Config/InstanceName - The name of this STAF instance.  The default
is STAF if the STAF_Instance_Name environment variable is not specified.
<LI>STAF/Config/Machine - The name of this machine
<LI>STAF/Config/MachineNickname - The nickname for this machine.  This defaults
to the same value as STAF/Config/Machine unless overridden using the MACHINENICKNAME
configuration setting.
<LI>STAF/Config/Mem/Physical/Bytes - The amount of physical memory in bytes. 
Note: The value is 0 on z/OS because STAF cannot determine
the physical memory on this operating system.
<LI>STAF/Config/Mem/Physical/KB - The amount of physical memory in kilobytes.
Note: The value is 0 on z/OS because STAF cannot determine
the physical memory on this operating system.
<LI>STAF/Config/Mem/Physical/MB - The amount of physical memory in megabytes.
Note: The value is 0 on z/OS because STAF cannot determine
the physical memory on this operating system.
<LI>STAF/Config/OS/Name - The name of the operating system, e.g.
WinXP, WinSrv2008, Linux, AIX, SunOS, HP-UX, Darwin
<LI>STAF/Config/OS/MajorVersion - This is operating system specific
<LI>STAF/Config/OS/MinorVersion - This is operating system specific
<LI>STAF/Config/OS/Revision - This is operating system specific
<LI>STAF/Config/Processor/NumAvail - The number of available processors.
Note: The value is 0 on z/OS because STAF cannot determine
the number of available processors on this operating system.
<LI>STAF/Config/Sep/Command - The character(s) used to separate multiple
commands concatenated together in a single line
<LI>STAF/Config/Sep/File - The character(s) used to separate files and
directories in a path
<LI>STAF/Config/Sep/Line - The character(s) used to separate lines in a text
file
<LI>STAF/Config/Sep/Path - The character(s) used to separate paths in a path
list
<LI>STAF/Config/STAFRoot - The directory in which STAF is installed
<LI>STAF/DataDir - The directory that STAF and its services use to write data
(based on the DATADIR operational parameter)
<LI>STAF/Env/* - All environment variables accessible via STAF
<LI>STAF/Version - The version of STAF installed
</UL>
<P>
<P><H3><A NAME="HDRVARCONBASICS">2.4.1 The Basics of Variable References</A></H3>
<P>
To substitute a variable's value, write the name of the variable in curly braces:
"{STAF/Config/OS/Name}" is a valid reference to the variable STAF/Config/OS/Name.
Assuming STAF/Config/OS/Name=Win2000, string "Operating system is {STAF/Config/OS/Name}"
resolves to "Operating system is Win2000".
<P>
Variable references can be used in many places when submitting a STAF request.
For example:
<UL COMPACT>
<LI>When submitting a request to any service, the machine
name and service name can contain STAF variables.
<LI>When using the Variable service, the string being resolved can contain STAF variables.
<LI>When starting a process via the Process service, the values of any of its request options
can contain STAF variables.
<LI>When logging a message via the Log service, the value of the message can contain
STAF variables.
</UL>
<P>
See section <A HREF="#HDRVARSERVICE">8.21, "Variable (VAR) Service"</A> for more information on setting and resolving
variables.
<A NAME="IDX18"></A>
<HR><H2><A NAME="HDRTRSTCON" HREF="#ToC_10">2.5 Security</A></H2>
<P>Security in STAF can be defined at the machine level and/or the user level.
In other words, you grant access to machines and/or to userids.
Access in STAF is granted by specifying a certain trust level for a machine or
user, where trust level 0 indicates no access and trust level 5 indicates all access.
Each service in STAF defines what trust level is required in order to use the various
functions the service provides.
<A NAME="IDX20"></A>
<P>A basic description of each level follows
<UL COMPACT>
<LI>Level 0 - No access
<LI>Level 1 - Restricted access.  Only PING and helps available.
<LI>Level 2 - Limited access.  Only query/view facilities available.
<LI>Level 3 - Standard access.  Non-destructive updates allowed, e.g., logging.
<LI>Level 4 - Advanced access.  Update abilities, e.g., copying files, deleting
log files.
<LI>Level 5 - All access, e.g., SHUTDOWN, Process invocation, Trust definition
manipulation
</UL>
<P>In order to use user trust security in STAF, you must have at least
one authenticator registered.
<P><B>Note: </B>The local machine can be granted a trust level by specifying
interface "local" and a system identifier of "local".
<P>User authentication overrides machine authentication.  For example,
if the machine trust level is 3 and the authenticated user has a trust
level of 4, then the handle will have a trust level of 4.
If the user has been authenticated, but there are no user authentication
trust matches, the machine trust level is used.  If there is no machine
trust level specified, then the default trust level is used.
<A NAME="IDX22"></A>
<HR><H2><A NAME="HDRQUEUECON" HREF="#ToC_11">2.6 Queues</A></H2>
<P>Each handle in STAF has a priority queue associated with it.  This queue
is used to accept/retrieve messages from other processes/machines.  Each
message in the queue has the following data associated with it.
<UL COMPACT>
<LI>Priority - An unsigned long value (0 - 4294967296) representing the
importance of the message, with 0 representing the most important message
<LI>Timestamp - The date/time the message was received
<LI>Machine - The machine which sent the message
<LI>Process name - The registered name of the process which sent the message
<LI>Handle - The handle of the process which sent the message
<LI>Message - The actual message itself
</UL>
<P>STAF allows you to register to receive notifications for certain events,
such as STAF starting and shutting down.  These events will appear in the
queue of the requesting process.  They will reveal the originating handle as
handle 1 of the originating machine, which is the reserved STAF Process handle.
<A NAME="IDX24"></A>
<A NAME="IDX26"></A>
<HR><H2><A NAME="HDRSTRINGCON" HREF="#ToC_12">2.7 Strings and Codepages</A></H2>
<P>The requests submitted to STAF and the results received from STAF are all
strings.  These strings may contain any arbitrary set of characters, including
the NULL (i.e., 0) character.  When working in an environment with a
heterogeneous set of codepages, STAF will translate the request and result
strings from and to the necessary codepages.  This ensures that the request and
result strings are not misinterpreted by the receiver.
<P>
In general, when using STAF services, there shouldn't be any round trip problems.
"Round trip" in this context means when all requests are originating from the 
same system, even if the requests are sent to, and the data is stored on, a system
with a different codepage.  However, if you send, for example, a request to log
data containing Japanese codepage specific characters to any system and then
query the log from a system using a US English codepage, you won't get the
"correct" data, as that is not a valid "round trip". 
<P><B>Note: </B>All STAF generated strings are composed of only ASCII-7 characters and
will safely survive the translation from/to different codepages.
<P>
<P><H3><A NAME="Header_13">2.7.1 Windows Codepage Translation Anomalies</A></H3>
<P>
If you need to specify non-ASCII characters in  a request, then you need to be
aware of some anomalies if your target system is a Windows system that isn't
using an English codepage and whose ANSI codepage (ACP) identifier is different
from the OEM codepage (OEMCP) identifier.  The system locale determines which
codepages are defaults for the Windows system.  However, some European locales
such as French and German set different values for the ACP and OEMCP.
By default, STAF uses the OEM codepage when doing codepage translation.
But, depending on where the data is input, it may be necessary to tell STAF
to use the ANSI codepage.  The ANSI codepage is used in the window manager
and graphics device interface and by many applications.  However, the Windows
command line and bat files use the OEM codepage as they are interpreted by
cmd.exe.  You can use CHCP to display or change the codepage used by the
command line.  Note that these anomalies occur only on Windows systems.
<P>
To avoid these Windows codepage anomalies, you may need to change the codepage
used by STAF using one of these methods:
<P>
<UL>
<P><LI>Change the OEMCP value to be set to the same data as the ACP value in the
Windows Registry.  You can use REGEDIT to start the Windows Registry Editor
and select Edit-&gt;Find and type in ACP to find its value data and then do the
same for OEMCP to find its value data.  Assuming they are different, you
could change the value data for OEMCP to be the same as the value data for
ACP by highlighting OEMCP and selecting Edit-&gt;Modify and enter the new value
data for OEMCP and then exit the REGEDIT program.  The system must be
rebooted for the registry change to take effect.  Also, if the system is
abnormally rebooted, it's possible that the Windows operating system may
reset the registry value.  This is the recommended method.
<P><B>Caution: </B>You should NOT change the ACP value to the OEMCP value.
<P>
<P><LI>Or, you can override the codepage used by STAF by setting the
STAFCODEPAGEOVERRIDE environment variable to the ANSI codepage and then
start STAFProc.
</UL>
<P><B>Note: </B>To see the codepage that STAF is using, check the value of
STAF variable STAF/Config/CodePage.  For example: 
<PRE>    STAF testmach1 VAR RESOLVE STRING {STAF/Config/CodePage}
</PRE>
<P>
<P>
<P><H3><A NAME="HDRFSGETFILECONVERTERERROR">2.7.2 Codepage Converter Error on a FS GET FILE Request</A></H3>
<P>
On a GET FILE request to the FS service (or on another service request that
submits a GET FILE request to the FS service like the STAX service does on
an EXECUTE FILE request), RC 39 (Converter Error) is returned if the file
contains data that is not valid in the codepage that STAF is using.
To see the codepage that STAF is using, check the value of STAF variable
STAF/Config/CodePage as discussed in the previous section.
<P>
To resolve an RC 39 (Converter Error) on a GET FILE request to the FS service,
either:
<UL>
<P><LI>Change the file contents to only use data that is valid in the codepage
used by STAF, or
<P><LI>Override the codepage used by STAF by setting the STAFCODEPAGEOVERRIDE
environment variable to a codepage that does support the data in the file
and then re-start STAFProc.
</UL>
<P>
<A NAME="IDX27"></A>
<A NAME="IDX29"></A>
<HR><H1><A NAME="HDRINSTALL" HREF="#ToC_15">3.0 Installation</A></H1>
<P>The STAF Installation Guide
(http://staf.sourceforge.net/current/STAFInstall.pdf)
has detailed information on how to install STAF.
<P>
<P>
<A NAME="IDX31"></A>
<HR><H1><A NAME="HDRCONFIG" HREF="#ToC_16">4.0 Configuration</A></H1>
<P>STAF is configured through a text file called the STAF Configuration File.
This file may have any name you desire, but the default is STAF.cfg.  The
STAF Configuration File is read and processed line by line.  Whitespace at
the front of the line is removed before processing.  Blank lines, or
lines containing only whitespace are ignored.  You may continue a configuration
statement onto the next line by placing a "\" as the last character of the
line.  The maximum length for a line in the STAF Configuration File is 2048
characters.  The various configuration statements are described in the following
sections.
<P>You may use variables for all the values of configuration statement options,
with the exception of the <TT>SET VAR</TT> configuration statement itself.
However, these variables must be either predefined STAF variables (see
<A HREF="#HDRVARCON">2.4, "Variables"</A>) or be previously defined in the STAF Configuration File
via the <TT>SET VAR</TT> configuration statement (see below).
<HR><H2><A NAME="HDRCOMMENTSCFG" HREF="#ToC_17">4.1 Comments</A></H2>
<P><H3><A NAME="Header_18">4.1.1 Description</A></H3>
<P>You specify a comment by placing a pound sign, #, as the first character
on the line.  Comment lines are ignored.
<P><H4><A NAME="Header_19">Examples</A></H4>
<PRE>
# This is a comment line
</PRE>
<A NAME="IDX32"></A>
<A NAME="IDX34"></A>
<HR><H2><A NAME="HDRMACHINECFG" HREF="#ToC_20">4.2 Machine Nickname</A></H2>
<P><H3><A NAME="Header_21">4.2.1 Description</A></H3>
<P>You may specify a nickname for your machine using the
MACHINENICKNAME configuration statement.
<P>This allows you to override the machine nickname which is set to the
value of the STAF/Config/Machine system variable by default.
This primarily affects the data stored by services such as the Log and
Monitor services, which store data based on the machine from which it came
by using the STAF/Config/MachineNickname system variable as part of the
directory path when creating logs and monitor data.
By allowing the STAF/Config/MachineNickname system variable to be overridden,
it allows you to better manage your data.
<P>
The machine nickname is not used to communicate with other systems and does
not have any effect on trust.
<P>This option is used in both connected and disconnected modes
(e.g. disconnected mode is when you are not using a network interface).
<P>
<P><H4><A NAME="Header_22">Syntax</A></H4>
<PRE>
MACHINENICKNAME &lt;Nickname&gt;
</PRE>
<P><TT>&lt;Nickname&gt;</TT> is the nickname you wish to use for your machine.  It is
case sensitive.
<P><H4><A NAME="Header_23">Examples</A></H4>
<PRE>
MACHINENICKNAME testmachine1
MACHINENICKNAME JohnDoe
</PRE>
<A NAME="IDX36"></A>
<A NAME="IDX37"></A>
<A NAME="IDX38"></A>
<A NAME="IDX39"></A>
<HR><H2><A NAME="HDRNETWORKCFG" HREF="#ToC_24">4.3 Network Interfaces</A></H2>
<P><H3><A NAME="Header_25">4.3.1 Description</A></H3>
<P>You indicate that you wish to send and accept requests on a network
interface using the INTERFACE configuration statement.
The INTERFACE configuration statement registers
connection providers (also called network interfaces, or interfaces
for short).
<P>
<P><H4><A NAME="Header_26">Notes:</A></H4>
<OL TYPE=1>
<P><LI>Currently, STAF provides two network interfaces, secure TCP/IP and
non-secure TCP/IP (except a secure TCP/IP interface is not yet provided
for z/OS).
The default STAF configuration file configures a secure ssl interface
as the default interface and also configures a non-secure tcp interface
(except on z/OS where only a non-secure tcp interface is configured).
STAF also allows you to plug in network interfaces
(aka connection providers) so that you can create your own
connection provider which can communicate via any mechanism you
choose (e.g. a Serial Line, NetBIOS, or SNA).
Connection provider interfaces are C/C++ based so they are platform
specific.  However, we haven't provided any documentation yet on how
to do this.
<P><LI>An interface named local is also provided with STAF.  Requests
coming from the local system will appear as though they came from an
interface named "local" and a system identifier of "local".
</OL>
<P><H4><A NAME="Header_27">Syntax</A></H4>
<PRE>
INTERFACE &lt;Name&gt; LIBRARY &lt;Implementation Library&gt; [OPTION &lt;Name[=value]&gt;]...
</PRE>
<P><TT>&lt;Name&gt;</TT> is the name by which this network interface
(aka Connection Provider) will be known on this machine.
<P><TT>LIBRARY</TT> is the name of the shared library / DLL
which implements the network interface (aka Connection Provider).
STAF provides one implementation library called STAFTCP which
provides support for both secure and non-secure TCP/IP communcation.
<P><TT>OPTION</TT> specifies a configuration option that will be passed on
to the shared library / DLL which implements the connection provider.
You may specify multiple <TT>OPTION</TT>s for a given connection provider.
See <A HREF="#HDRSTAFTCP">4.3.2, "STAFTCP Connection Provider"</A> for acceptable options for the STAFTCP shared
library / DLL.
<P><H4><A NAME="Header_28">Examples</A></H4>
<PRE>
INTERFACE ssl    LIBRARY STAFTCP OPTION SECURE=Yes OPTION PORT=6550
INTERFACE tcp    LIBRARY STAFTCP OPTION SECURE=No  OPTION PORT=6500
INTERFACE tcp2   LIBRARY STAFTCP 
INTERFACE tcp3   LIBRARY STAFTCP OPTION PORT=6600
INTERFACE serial LIBRARY STAFSER
</PRE>
<A NAME="IDX41"></A>
<A NAME="IDX42"></A>
<A NAME="IDX43"></A>
<A NAME="IDX44"></A>
<A NAME="IDX45"></A>
<A NAME="IDX46"></A>
<A NAME="IDX47"></A>
<A NAME="IDX48"></A>
<P><H3><A NAME="HDRSTAFTCP">4.3.2 STAFTCP Connection Provider</A></H3>
<P>The STAFTCP connection provider shared library / DLL supports
TCP/IP communication. STAF supports both secure and non-secure
TCP/IP communication on most platforms.
STAF supports both IPv4 and IPv6. IPv6 is supported in the IPv6 enabled version of STAF.
<P>Each STAFTCP connection provider configured on a single machine must use a unique
port number.  To communicate to a remote machine running STAF, your machine and the
remote machine must both have a STAFTCP connection provider configured with the same
SECURE option value and the same PORT option value.  A non-secure STAFTCP connection
provider cannot communicate to a secure STAFTCP connection provider.  Also, a secure
TCP connection provider can only communicate to another secure TCP connection provider
if the same certificate is used.
<P>The STAFTCP connection provider supports the following <TT>OPTIONs</TT>&#58;
<P><TT>CONNECTTIMEOUT=&lt;Number&gt;</TT> specifies the maximum time in milliseconds to wait
for a connection attempt to a remote system to succeed.  The default is 5000
(5 seconds).  You may need to increase this value if you are consistently
receiving return code 16 when trying to communicate with distant STAF systems.
Note that the total time to wait for a connection to a remote system to succeed
is <TT>(CONNECTTIMEOUT * CONNECTATTEMPTS) + (CONNECTRETRYDELAY * (CONNECTATTEMPTS - 1))</TT>.
If using the defaults, the maximum total time to wait for a connection to a remote
system to succeed is (5000 * 2) + (1000 * 1), which equals 11 seconds.
The <TT>CONNECTATTEMPTS</TT> and <TT>CONNECTRETRYDELAY</TT> values are operational
parameters that can be set in the STAF configuration file.
<P><TT>PORT=&lt;Number&gt;</TT> specifies the TCP/IP port on which this
connection provider listens for connections.
The default port is 6550 if option <TT>SECURE=Yes</TT>.
The default port is 6500 if option <TT>SECURE=No</TT>.
Each STAFTCP connection provider configured on a single machine
must use a unique port number.
<P><TT>PROTOCOL=&lt;IPv4 | IPv6 | IPv4_IPv6&gt;</TT> specifies the communication protocol that this
connection provider uses. The possible values are <TT>IPv4</TT>, <TT>IPv6</TT>,
or <TT>IPv4_IPv6</TT>.  When this option is absent, the default is <TT>IPv4_IPv6</TT>
which indicates to use both IPv4 and IPv6 protocols.
This option is only valid for IPv6 enabled versions of STAF.
<P><TT>SECURE=&lt;Yes | No&gt;</TT> specifies whether to use secure or
non-secure TCP/IP.  Secure TCP/IP uses OpenSSL.  This option is
not available on z/OS where only non-secure TCP/IP is currently supported.
The default is No.
<P><TT>SSL/CACertificate</TT> specifies the fully qualified path to the
file containing the STAF CA certificate list used for secure connections.
This option is only valid if option <TT>SECURE=Yes</TT> is specified.
The default is {STAF/Config/STAFRoot}/bin/CAList.crt which is a list
of the default server certificate provided with STAF.
<P><TT>SSL/ServerCertificate</TT> specifies the fully qualified path to
the file containing the STAF server certificate used for secure connections.
This option is only valid if option <TT>SECURE=Yes</TT> is specified.
The default is {STAF/Config/STAFRoot}/bin/STAFDefault.crt which is a
self-signed x509 default certificate provided with STAF.
<P><TT>SSL/ServerKey</TT> specifies the fully qualifed path to the file
containing the STAF server key used for secure connections.
This option is only valid if option <TT>SECURE=Yes</TT> is specified.
The default is {STAF/Config/STAFRoot}/bin/STAFDefault.key which is a
default server key provided with STAF.
<P>
<P><H4><A NAME="Header_30">Examples</A></H4>
<PRE>
INTERFACE ssl  LIBRARY STAFTCP OPTION SECURE=Yes OPTION PORT=6550
INTERFACE tcp  LIBRARY STAFTCP OPTION SECURE=No  OPTION PORT=6500
INTERFACE tcp2 LIBRARY STAFTCP OPTION PORT=6501
INTERFACE tcp3 LIBRARY STAFTCP OPTION PORT=6700 OPTION PROTOCOL=IPv6
INTERFACE tcp4 LIBRARY STAFTCP OPTION CONNECTTIMEOUT=15000
INTERFACE ssl2 LIBRARY STAFTCP OPTION SECURE=Yes OPTION PORT=6551 \
               OPTION SSL/CACertificate={STAF/Config/STAFRoot}/bin/MyCAList.crt \
               OPTION SSL/ServerCertificate={STAF/Config/STAFRoot}/bin/MySTAF.crt \
               OPTION SSL/ServerKey={STAF/Config/STAFRoot}/bin/MySTAF.key 
</PRE>
<A NAME="IDX49"></A>
<A NAME="IDX51"></A>
<A NAME="IDX53"></A>
<HR><H2><A NAME="HDRSERVICEREGCFG" HREF="#ToC_31">4.4 Service Registration</A></H2>
<P><H3><A NAME="Header_32">4.4.1 Description</A></H3>
<P>External services are registered with the SERVICE configuration statement.
<P><H4><A NAME="Header_33">Syntax</A></H4>
<PRE>
SERVICE &lt;Name&gt; LIBRARY &lt;Implementation library&gt; &#91;EXECUTE &lt;Executable&gt;&#93;
               &#91;OPTION &lt;Name[=Value]&gt;&#93;... &#91;PARMS &lt;Parameters&gt;&#93;
</PRE>
<P>or
<PRE>
SERVICE &lt;Name&gt; DELEGATE &lt;Machine&gt; &#91;TONAME &lt;Remote Service Name&gt;&#93;
</PRE>
<P>
<P><TT>&lt;Name&gt;</TT> is the name by which this service will be known on this
machine.
<P><TT>LIBRARY</TT> is the name of the shared library / DLL
which implements the service or acts as a proxy for the service.  See the
information for each external service to determine the appropriate value
for this option.
<P><TT>EXECUTE</TT> is used by service proxy libraries / DLLs to specify what
the proxy library should execute.  For example, for a Java service, this might
be the name of the Java jar file which actually implements the service.  This
option has no significance for non-proxy service libraries.  See below for
information regarding the JSTAF service proxy library.
Otherwise, see the documentation provided by the service proxy library.
<P><TT>OPTION</TT> specifies a configuration option that will be passed on
to the service library / DLL.  This is typically used by service proxy
libraries to further control the interface to the actual service
implementation.  You may specify multiple <TT>OPTION</TT>s for a given
service.  See below for acceptable options for the JSTAF
service proxy library.  Otherwise, see the documentation provided with the
service (proxy) library.
<P><TT>PARMS</TT> specifies optional parameters that will be passed to the
service during initialization.
<P><TT>DELEGATE</TT> specifies the machine to which to delegate this service.
This machine must be running STAF V3.0.0 or later.
<P><B>Note: </B>From a trust perspective, the tcp interface names on the "delegated to"
service machine and on the machine delegating service requests to it must match
or the trust statement for the machine that is delegating service requests
must use a wildcard to match any interface.
<P><TT>TONAME</TT> is the name of the service on <TT>&lt;Machine&gt;</TT> to
which the delegated requests will be sent.  The default is the same name as
specified with <TT>&lt;Name&gt;</TT>.
<P><H4><A NAME="Header_34">Examples</A></H4>
<PRE>
SERVICE MONITOR LIBRARY STAFMon PARMS "RESOLVEMESSAGE MAXRECORDSIZE 4096"
SERVICE LOG     LIBRARY STAFLog
SERVICE STAX    LIBRARY JSTAF  EXECUTE C:\STAF\service\STAX.jar \
                OPTION J2=-Xmx128m
SERVICE SAMPLEJ LIBRARY JSTAF  EXECUTE C:\STAF\services\Sample.jar \
                PARMS {STAF/Config/STAFRoot}\bin\sample.dft
SERVICE MYLOG   DELEGATE TestSrv1
SERVICE PAGER   DELEGATE pagesrv.austin.ibm.com
SERVICE EVENT   DELEGATE EventSrv TONAME DB2EVENT
SERVICE NOTIFY  LIBRARY Notify PARMS "24 Hours 7 Days"
SERVICE ZIP     LIBRARY STAFEXECPROXY EXECUTE STAFZip
</PRE>
<A NAME="IDX54"></A>
<A NAME="IDX55"></A>
<A NAME="IDX57"></A>
<P><H3><A NAME="HDRJVMCFG">4.4.2 JSTAF service proxy library</A></H3>
<P>The library JSTAF acts as a proxy for STAF services implemented in the
Java language.  The minimum version of Java that JSTAF requires depends on
the operating system for which STAF was built:
<UL>
<P><LI>Java 1.4.2 or newer is required by JSTAF provided in the STAF binaries for
Windows, Linux i386/amd64/ppc, zLinux, AIX, IBM i, and HP-UX.
<P><LI>Java 5.0 or newer is required by JSTAF provided in the STAF binaries for
Solaris and FreeBSD.
<P><LI>Java 6.0 or newer is required by JSTAF provided in the STAF binaries for
z/OS.
<P><LI>Java 7.1 or newer is required by JSTAF provided in the STAF binaries for
Linux ppc64le.
<P><LI>Java 8.0 or newer is required by JSTAF provided in the STAF binaries for
Mac OS X.
</UL>
<P><B>Note: </B>JSTAF in a 32-bit version of STAF requires a 32-bit version of Java.
Similarly, JSTAF in a 64-bit version of STAF requires a 64-bit version of Java.
<P>The <TT>EXECUTE</TT> option for a Java service should specify the
fully-qualified name of the jar file that implements the service.  The
jar file will be automatically added to the class path by JSTAF.
<P><B>Note: </B>In versions of STAF prior to 2.4.0, the name of the Java class that
implements the service was specified for the <TT>EXECUTE</TT> option and
you had to make sure that the service's class files were in the class path.
This is still supported, but this method is deprecated and will be removed
in a future version of STAF.
<P>JSTAF supports the following <TT>OPTION</TT>s&#58;
<P><TT>JVMName=&lt;Name&gt;</TT> specifies the name for the JVM you want the Java
service to run in.  If the JVM does not already exist, it will be created.
If no JVMName is specified, then the Java service will run in the default JVM,
named STAFJVM1, which is created the first time a Java service is registered
with no JVMName specified.
This option allows JSTAF to run Java services in different JVMs.
<P><TT>JVM=&lt;Executable&gt;</TT> specifies the name of the desired Java
executable.  The default is "java".  Note, this option is only valid for the
first service created with a given <TT>JVMName</TT>.
<P><TT>J2=&lt;Java option&gt;</TT> specifies one or more arbitrary Java option(s)
that should be passed to the JVM.  You can find more information on these
options by using the command "java" (for standard options) and "java -X"
(for non-standard options), or by consulting your Java documentation.
Note that -X options can vary depending on which Java implementation
(e.g. Oracle Java 7 vs IBM Java 6) you installed.  Note, this option
is only valid for the first service created with a given <TT>JVMName</TT>.
<P><B>Note: </B>If you are using the HP-UX IA64 64-bit version of STAF, you must specify
the -d64 option to the JVM.  This can be done by specifying <TT>J2=-d64</TT>
<P><TT>MAXLOGS=&lt;Number&gt;</TT> specifies the maximum number of log files
for the JVM that should be saved.  The default is 5.
The JVM log files are stored in the <TT>{STAF/DataDir}/lang/java/jvm/&lt;JVMName&gt;</TT>
directory and contain JVM start information such as the date/time when the JVM
was started, the JVM executable, and the J2 options used to start the JVM.
In addition, it contains any other information logged by the JVM, including any
errors that may have occurred while the JVM was running.
The current JVM log file is named <TT>JVMLog.1</TT> and saved JVM log files, if any,
are named <TT>JVMLog.2</TT> to <TT>JVMLog.&lt;MAXLOGS&gt;</TT>.
Note, this option is only valid for the first service created with a
given <TT>JVMName</TT>.
<P><TT>MAXLOGSIZE=&lt;Number&gt;</TT> specifies the maximum size, in bytes, for
the JVM log file(s).  The default is 1048576 (1M).
This option determines when to create a new JVM log file.  When the JVM is
started, if the size of a JVM log file exceeds the maximum size specified
by this option, a new JVM log file will be created.
Note, this option is only valid for the first service created with a
given <TT>JVMName</TT>.
<P>
<P><B>Note: </B>You can view the JVM log for a Java service that is currently
registered using the STAFJVMLogViewer utility.
Section <A HREF="#HDRSTAFJVMLOGVIEWER">9.2, "JVM Log Viewer Class"</A> provides more information on this utility.
<P>
<P><H4><A NAME="Header_36">Examples</A></H4>
<PRE>
OPTION J2=-verbose&#58;gc
OPTION "J2=-cp {STAF/Config/BootDrive}/MyJava/Extra.jar{STAF/Config/Sep/Path}{STAF/Env/Classpath}"
OPTION J2=-Xms128m
OPTION J2=-Xmx512m
OPTION J2=-d64
OPTION "J2=-Xmx1024m -XX&#58;MaxPermSize=256m -XX&#58;PermSize=256m"
OPTION JVMName=MyJVM1
OPTION JVM=/opt/sunjdk1.4.0/jre/bin/java
OPTION MAXLOGS=2
OPTION MAXLOGSIZE=2048
</PRE>
<P>
If you wanted to run the STAX Java service in a JVM, called MyJVM1, with a maximum heap
size of 1024M, and wanted the Event and EventManager Java services to run in a
different JVM, called MyJVM2, with a maximum heap size of 512M, you could specify
the following service registration lines in the STAF.cfg file (or dynamically
register the services in this order using the specified options).
<PRE>
SERVICE STAX  LIBRARY JSTAF  EXECUTE C:/STAF/service/STAX.jar \
              OPTION JVMName=MyJVM1 OPTION J2=-Xmx1024m
SERVICE Event LIBRARY JSTAF  EXECUTE C:/STAF/service/STAFEvent.jar \
              OPTION JVMName=MyJVM2 OPTION J2=-Xmx512m
SERVICE EventManager LIBRARY JSTAF  EXECUTE C:/STAF/services/EventManager.jar \
              OPTION JVMName=MyJVM2
</PRE>
<A NAME="IDX58"></A>
<A NAME="IDX59"></A>
<A NAME="IDX61"></A>
<P><H3><A NAME="HDRPLSTAF">4.4.3 PLSTAF service proxy library</A></H3>
<P>The library PLSTAF acts as a proxy for STAF services implemented in the
Perl language.  PLSTAF is currently supported on Windows (IA32), Linux (IA32),
and Mac OS X.  On Linux IA32, PLSTAF is currently only supported with Perl 5.8.0.
<P>The <TT>EXECUTE</TT> option for a Perl service should specify the  name of
the .pm file (without the .pm extension) that implements the service.
<P>PLSTAF supports the following <TT>OPTION</TT>s&#58;
<P><TT>USELIB=&lt;Directory&gt;</TT> specifies the directory containing the .pm file
that implements the service.  You must use the USELIB option unless you have
set (prior to starting STAFProc) environment variable PERLLIB to include the
directory containing the .pm file that implements the service.
<P><TT>MAXLOGS=&lt;Number&gt;</TT> specifies the maximum number of log files
for the Perl interpreter that should be saved.  The default is 5.
The Perl interpreter log files are stored in the
<TT>{STAF/DataDir}/lang/perl/&lt;serviceName&gt;</TT>
directory and contain the Perl interpreter start information such as the
date/time when the Perl interpreter was started and  the Perl service
executable. In addition, it contains any other information logged by the Perl
service and interpreter, including any errors that may have occurred while the
Perl interpreter was running.
The current Perl interpreter log file is named <TT>PerlInterpreter.1</TT>
and saved Perl interpreter log files, if any,
are named <TT>PerlInterpreter.2</TT> to <TT>PerlInterpreter.&lt;MAXLOGS&gt;</TT>.
<P><TT>MAXLOGSIZE=&lt;Number&gt;</TT> specifies the maximum size, in bytes, for
the Perl interpreter log file(s).  The default is 1048576 (1M).
This option determines when to create a new Perl interpreter log file.  When the
Perl interpreter is started, if the size of a Perl interpreter log file exceeds
the maximum size specified by this option, a new Perl interpreter log file will
be created.
<P><B>Note: </B>The PLSTAF service proxy library uses embedded Perl directly within the
STAFProc executable.  This means that if a Perl service has a fatal error which
terminates the Perl interpreter, the STAFProc executable will also be terminated.
To prevent this, you can use the STAFEXECPROXY service proxy library when
registering a Perl service.
<P><B>Note: </B>To configure Perl services, prior to starting STAFProc, environment
variable PERLLIB must be set to include the directory containing the PLSTAF.pm
and PLSTAFService.pm files (located in the "bin" directory in the STAF
installation root directory).
<P><B>Note: </B>To configure Perl services, the directory containing the PLSTAF library
(PLSTAF.dll on Windows, libPLSTAF.so on Linux, libPLSTAF.dylib on Mac OS X)
must be in the operating system's library path (PATH on Windows, LD_LIBRARY_PATH
on Linux, DYLD_LIBRARY_PATH on Mac OS X) prior to starting STAFProc.
<P><B>Note: </B>When configuring Perl services on Linux with Perl 5.8.0, the directory
containing the Perl 5.8.0 libperl.so file must be included in environment
variable LD_LIBRARY_PATH prior to starting STAFProc.
<P><B>Note: </B>When removing a Perl service (or when shutting down STAF if Perl
services had been configured), you may see a message in the STAFProc output
similar to: "Perl exited with active threads".  This message can be ignored.
<P>
<P><H4><A NAME="Header_38">Examples</A></H4>
<P>
<PRE>
SERVICE Device1  LIBRARY PLSTAF EXECUTE DeviceService 
SERVICE Device2  LIBRARY STAFEXECPROXY EXECUTE DeviceService \
                 OPTION PROXYLIBRARY=PLSTAF
SERVICE testA    LIBRARY STAFEXECPROXY EXECUTE myTestService \
                 OPTION PROXYLIBRARY=PLSTAF OPTION USELIB=C:\MyServices
</PRE>
<A NAME="IDX62"></A>
<A NAME="IDX63"></A>
<P><H3><A NAME="HDRSTAFEXECPROXY">4.4.4 STAFEXECPROXY service proxy library</A></H3>
<P>This library will allow you to execute an external STAF service within a
new executable, rather than directly within the STAFProc executable.  For
example, this library could be used to run the Zip service in a separate
executable, or run a Perl service where the Perl interpreter will run in a
separate executable.
<P>Running an external STAF service in a separate executable will ensure
that if the service has a fatal error, the error will not kill STAFProc.
In addition, this allows monitoring of the external service's system
resource utilization, since you can view the utilization for the new
executable (otherwise, if the service was running within the STAFProc
executable, then the service's resource utilization would be part of
the STAFProc resource utilization).
<P>Note that using the STAFEXECPROXY 
library will introduce a level of IPC communication for all service
requests to the service; rather than STAFProc sending the requests
directly to the service, STAFProc will send the request to the
STAFEXECPROXY library, which will then send the request to the new
executable, which will then send the request to the service (processing
the service result will have the same path in reverse).  So, for external
STAF services where performance is critical, such as the Log and Monitor
services, using the STAFEXECPROXY library is not recommended.
<P>Note that since the JSTAF proxy library already runs the Java STAF service
in a new executable (the JVM), using the STAFEXECPROXY library for Java STAF
services is not supported (if you attempt to register a Java STAF service
using the STAFEXECPROXY library, you will get an RC 27, Service
configuration error).
<P>The <TT>EXECUTE</TT> option is used to indicate the service library to 
execute, or if the
service will be executed by a proxy library, it will be used to indicate
what service executable the proxy library should execute.  For example,
for the Zip service, "STAFZip" would be used for the EXECUTE value.  For a
Perl service, which uses the PLSTAF proxy library, the service .pm module
would be used for the EXECUTE value.
<P>STAFEXECPROXY supports the following <TT>OPTION</TT>s
<PRE>
    [OPTION PROXYLIBRARY=&lt;ProxyLibrary&gt;]
    [OPTION PROXYENV=&lt;Variable=Value&gt;]...
</PRE>
(note that all other <TT>OPTION</TT>s will be passed to the service
library / DLL)&#58;
<P><TT>OPTION PROXYLIBRARY=&lt;ProxyLibrary&gt;</TT> is used to indicate the proxy
library to use for the
external service.  For example, you would use OPTION PROXYLIBRARY=PLSTAF
for a Perl service.  Note that this OPTION will not be passed on to the
service library / DLL.
<P><TT>OPTION PROXYENV=&lt;Variable=Value&gt;</TT> allows you to specify
environment variables that will be set for the STAFEXECPROXY executable (in
addition to or replacing the environment variables that were set when STAFProc
was started).  This allows you to set environment variables for the
STAFEXECPROXY executable without requiring that these environment variables be
set for STAFProc.
This option is particularly useful for Perl STAF services, which on many
Unix platforms require LD_PRELOAD to be set to the libperl library file
location.  However, setting LD_PRELOAD prior to starting STAFProc can
cause incompatibility issues for processes started via STAFProc.
So, you can use OPTION PROXYENV to specify the LD_PRELOAD environment
variable for the STAFEXECPROXY executable, without having it set for STAFProc's
environment.  To "unset" an environment variable, you can set the &lt;Value&gt; to
be blank.  You may specify any number of PROXYENV OPTIONs.
<P>STAFExecProxy.exe (STAFExecProxy on Unix) is the separate executable for the 
external service that will be displayed in the operating system's process
list.  You can determine the PID for the STAFExecProxy executable by 
running "HANDLE LIST HANDLES LONG".
<P>You may only run a single external service within a single STAFExecProxy
executable (multiple services that use the STAFEXECPROXY library will each
have a unique STAFExecProxy executable).
<P>
<P><H4><A NAME="Header_40">Examples</A></H4>
<PRE>
SERVICE Zip LIBRARY STAFEXECPROXY EXECUTE STAFZip
</PRE>
<PRE>
SERVICE Device LIBRARY STAFEXECPROXY EXECUTE DeviceService \
               OPTION PROXYLIBRARY=PLSTAF
</PRE>
<PRE>
SERVICE getenvvar LIBRARY STAFEXECPROXY EXECUTE \
        GetEnvVar OPTION PROXYLIBRARY=PLSTAF OPTION USELIB=/usr/local/staf/services \
        OPTION PROXYENV=LD_PRELOAD=/usr/lib/perl5/5.8.8/i386-linux-thread-multi/CORE/libperl.so \
        OPTION PROXYENV=TESTVAR=abcdef
 
</PRE>
<PRE>
SERVICE getenvvar LIBRARY STAFEXECPROXY EXECUTE \
        GetEnvVar OPTION PROXYLIBRARY=PLSTAF OPTION USELIB=/usr/local/staf/services \
        OPTION PROXYENV=LD_PRELOAD=/opt/ActivePerl-5.8/lib/CORE/libperl.so \
        OPTION PROXYENV=ANT_HOME= \
        OPTION "PROXYENV=MESSAGE=This is a test message"
 
</PRE>
<A NAME="IDX65"></A>
<A NAME="IDX67"></A>
<A NAME="IDX69"></A>
<HR><H2><A NAME="HDRSERVICELOADERCFCG" HREF="#ToC_41">4.5 Service Loader Registration</A></H2>
<P><H3><A NAME="Header_42">4.5.1 Description</A></H3>
<P>Service loaders are registered with the SERVICELOADER configuration statement.
<P><H4><A NAME="Header_43">Syntax</A></H4>
<PRE>
SERVICELOADER LIBRARY &lt;Implementation library&gt; &#91;EXECUTE &lt;Executable&gt;&#93;
              &#91;OPTION &lt;Name[=Value]&gt;&#93;... &#91;PARMS &lt;Parameters&gt;&#93;
</PRE>
<P>
<P><TT>LIBRARY</TT> is the name of the shared library / DLL
which implements the service loader or acts as a proxy for the service loader.  See the
information for each service loader to determine the appropriate value
for this option.
<P><TT>EXECUTE</TT> is used by service proxy libraries / DLLs to specify what
the proxy library should execute.  For example, this might be the name of
the Java jar file which actually implements the service loader.  This
option has no significance for non-proxy service libraries.  See the Service Registration
section for information regarding the JSTAF service proxy library.
<P><TT>OPTION</TT> specifes a configuration option that will be passed on
to the service loader library / DLL.  This is typically used by service proxy
libraries to further control the interface to the actual service loader
implementation.  You may specify multiple <TT>OPTION</TT>s for a given
service loader.  See the Service Registration section
for acceptable options for the JSTAF
service proxy library.  Otherwise, see the documentation provided with the
service (proxy) library.
<P><TT>PARMS</TT> specifies optional parameters that will be passed to the
service loader during initialization.
<P><H4><A NAME="Header_44">Examples</A></H4>
<PRE>
# Default Service Loader Service for LOG, MONITOR, RESPOOL, and ZIP services
SERVICELOADER LIBRARY STAFDSLS
 
# HTTP Service Loader Service for Java services (for Windows)
SERVICELOADER LIBRARY JSTAF EXECUTE C:/STAF/bin/STAFHTTPSLS.jar \
              PARMS "CONFIGFILE http://server1.company.com/project/stafhttpsls.cfg"
 
# HTTP Service Loader Service for Java services (for Unix)
SERVICELOADER LIBRARY JSTAF EXECUTE /usr/local/staf/lib/STAFHTTPSLS.jar \
              PARMS "CONFIGFILE http://server1.company.com/project/stafhttpsls.cfg"
 
# Custom Service Loader Service written in Java
SERVICELOADER LIBRARY JSTAF EXECUTE C:/STAF/services/CustomServiceLoader.jar
</PRE>
<P>
<A NAME="IDX71"></A>
<P><H3><A NAME="HDRSTAFDSLS">4.5.2 Default Service Loader Service (STAFDSLS)</A></H3>
<P>The default service loader service is implemented by library STAFDSLS and
is written in C++.  It can dynamically load the Log, Zip, Monitor, and ResPool
C++ services.  This service loader is configured automatically in the default
STAF.cfg file as follows:
<PRE>
# Add default service loader
serviceloader library STAFDSLS
</PRE>
<P>
<A NAME="IDX73"></A>
<P><H3><A NAME="HDRSTAFHTTPSLS">4.5.3 HTTP Service Loader Service (STAFHTTPSLS)</A></H3>
<P>The HTTP service loader service is implemented by jar file STAFHTTPSLS.jar
and is written in Java and is installed as part of STAF Java support in a typical
installation of STAF.  It can dynamically load any STAF service written in Java.
It can download the jar file for a STAF Java service (or a zip file that contains
the jar file) from a web server or from a file on the local machine.  It uses a
configuration file to determine what services it can load.  To use the HTTP
service loader service, a Java runtime must be installed and you must add a
<TT>SERVICELOADER</TT> configuration statement to the STAF configuration file
including a <TT>CONFIGFILE</TT> parameter specifying the location of the
HTTPSLS configuration file you created for it.
<P>
When STAF encounters a request for a service that isn't currently registered,
it checks each service loader that is registered in the STAF configuration file
to see if it handles this service.  The HTTP service loader service reads its
HTTPSLS configuration file (first downloading it from a web server if needed)
to see if it can handle this service.  If so, it downloads the service from the
specified location to a temporary directory on the local machine (and unzips it 
if necessary to access the STAF service jar file) and submits an <TT>ADD</TT>
request to the <TT>SERVICE</TT> service to register the service.  This way,
STAF is able to load whatever Java services you want.  Also, note that each
time the HTTP service loader service attempts to load a service, it reads its
HTTPSLS configuration file, so you can update the HTTPSLS configuration file
and it will read it the next time it attempts to load a service (without
restarting STAFProc).  Note that whenever STAF is restarted, the <TT>tmp</TT>
directory in the STAF data directory is deleted which means the temporary jar
files that the HTTP service loader service downloaded will be deleted since
they are stored in the STAF <TT>tmp</TT> data directory's
<TT>service/&lt;Serviceloader Name&gt;</TT> sub-directory.
<P>
The HTTP service loader service can reduce the maintenance for obtaining and
managing STAF Java services by:
<UL>
<P><LI>Obtaining specified versions of STAF Java services from a web server
instead of having to manually download each service and manually configure the
service in the STAF configuration file on all machines that require the service(s).
<P><LI>Providing the ability to specify a zip file on a web server that contains
a jar file for a STAF Java services (e.g. STAF Java services are provided in
zip files on the SourceForge website) and automatically unzipping the file to
obtain the jar file for the STAF Java service.
<P><LI>Providing the ability to specify where to download STAF Java services from
via a configuration file that resides on a web server as this file only needs
to exist in one place and can be used by many machines.
</UL>
<P>
<P><H4><A NAME="Header_47">Syntax</A></H4>
<PRE>
SERVICELOADER LIBRARY JSTAF EXECUTE &lt;Fully-qualified name of STAFHTTPSLS.jar&gt;
              [OPTION &lt;Name[=Value]&gt;]...
              PARMS "CONFIGFILE &lt;ConfigFileLocation&gt;
                     [DOWNLOADATTEMPTS &lt;NumDownloadAttempts&gt;]
                     [DOWNLOADRETRYDELAY &lt;DelayInSeconds&gt;]"
</PRE>                     
<P>
<TT>LIBRARY</TT> must always be <TT>JSTAF</TT> which is the STAF Java
service proxy library (because the HTTP Service Loader is written in Java).
<P>
<TT>EXECUTE</TT> specifies the location of the jar file which implements
the HTTP service loader service.  On Windows, specify
<TT>{STAF/Config/STAFRoot}/bin/STAFHTTPSLS.jar</TT>.
On Unix, specify <TT>{STAF/Config/STAFRoot}/lib/STAFHTTPSLS.jar</TT>.
<P>
<TT>OPTION</TT> specifies a configuration option that will be passed to JSTAF
to further control the interface to the JVM where this service loader will be run.
You may specify multiple <TT>OPTION</TT>s.  See section <A HREF="#HDRJVMCFG">4.4.2, "JSTAF service proxy library"</A>
for acceptable options to the JSTAF service proxy library.
For example, you can override the version of Java that you want the HTTP service
loader service to use via the <TT>JVM=&lt;Java Path&gt;</TT> option when you create
a new JVM by also using the <TT>JVMName=&lt;JVM Name&gt;</TT> option.
<P>
<TT>PARMS</TT> specifies the parameters that will be passed to the service
loader during initialization where:
<UL>
<P><LI><TT>CONFIGFILE</TT> specifies the location of the configuration file
used by the HTTP service loader service.  This can be a fully-qualified path
to a file on the local machine or it can be a url to the location of the
HTTPSLS configuration file on a web server.  The contents of this file must
follow the syntax specified in section <A HREF="#HDRHTTPSLSCONFIGFILE">"HTTPSLS Configuration File"</A> or the
HTTP Service Loader Service registration will fail.  This parameter is required.
This option will resolve STAF variables.
<P><LI><TT>DOWNLOADATTEMPTS</TT> specifies the maximum number of attempts that the
HTTP Service Loader will make to try to download a file.  The default is 3.
This option will resolve STAF variables.
<P><LI><TT>DOWNLOADRETRYDELAY</TT> specifies the number of seconds that the HTTP
Service Loader will delay before retrying to download a file if the
previous download attempt failed.  The default is 5.  This option will
resolve STAF variables.
</UL>
<P>
<P><H4><A NAME="Header_48">Examples</A></H4>
<P>
<PRE>
# Add HTTP Service Loader Service on Windows using local HTTPSLS config file
SERVICELOADER LIBRARY JSTAF EXECUTE {STAF/Config/STAFRoot}/bin/STAFHTTPSLS.jar \
              PARMS "CONFIGFILE {STAF/Config/STAFRoot}/bin/httpsls.cfg"
 
# Add HTTP Service Loader Service on Unix using HTTPSLS config file on SourceForge website
SERVICELOADER LIBRARY JSTAF EXECUTE {STAF/Config/STAFRoot}/lib/STAFHTTPSLS.jar \
              PARMS "CONFIGFILE http://staf.sourceforge.net/current/STAFHTTPSLS.cfg"
              
# Add HTTP Service Loader Service on Windows using HTTPSLS config file on a web server
SERVICELOADER LIBRARY JSTAF EXECUTE {STAF/Config/STAFRoot}/bin/STAFHTTPSLS.jar \
              OPTION JVMName=HTTPSLS OPTION JVM=C:/java1.5.0_12/bin/java \
              PARMS "CONFIGFILE http://server.company.com/project/httpsls.cfg \
                     DOWNLOADATTEMPTS 3 DOWNLOADRETRYDELAY 7"
</PRE>
<P>Note that you can register the HTTP service loader service multiple times
specifying unique values for the <TT>CONFIGFILE</TT> parameter.
For example, you may have one HTTP service loader service that downloads STAF
Java services like STAX, Event, Cron, and Email from the SourceForge website
and you may have a second HTTP service loader service that downloads your
custom STAF Java services from your own web server.
<P>
<P><H4><A NAME="HDRHTTPSLSCONFIGFILE">HTTPSLS Configuration File</A></H4>
<P>
<P>The HTTP service loader service is configured through a text file
called the HTTPSLS configuration file.  This file may have any name you
desire and can be located on a web server or on the local machine.  The
HTTPSLS configuration file is read and processed line by line.  Whitespace
at the front and end of each line is removed before processing.  Blank
lines, or lines containing only whitespace, are ignored.  You may continue
a configuration statement onto the next line by placing a "\" as the last
character of the line.
<P>Each service that you want the HTTP service loader service to load must
have a <TT>SERVICE</TT> entry in the HTTPSLS configuration file.  The syntax
for each service is similar to the <TT>SERVICE</TT> syntax used when
registering a STAF service in the STAF configuration file.
<P>
<P><I><B><A NAME="Header_50">Comments</A>:&nbsp;</B></I>&nbsp;
<P>You specify a comment by placing a pound sign, #, as the first non-blank
character in the line.  Comment lines are ignored.  For example:
<PRE>
# This is a comment line
</PRE>
<P>
<P><I><B><A NAME="Header_51">Service Registration</A>:&nbsp;</B></I>&nbsp;
<P>External Java services are registered with the <TT>SERVICE</TT>
configuration statement.  The syntax is:
<PRE>
SERVICE &lt;Name&gt; LIBRARY JSTAF EXECUTE &lt;Location of Service Jar or Zip File&gt;
               [ZIPPATH &lt;Path to Service Jar File&gt;]
               [OPTION &lt;Name[=Value]&gt;]...
               [PARMS "&lt;Service Parameters&gt;"]
</PRE>               
<P>
<TT>SERVICE</TT> specifies the name of the STAF service to be
registered.
<P>  
<TT>LIBRARY</TT> must always be JSTAF which is the STAF Java service
proxy library as the HTTP Service Loader only supports loading Java
services.
<P>
<TT>EXECUTE</TT> specifies the url for the Java jar file which
implements the service.  Or, it can specify the url of a zip file that
contains the Java jar file if the <TT>ZIPPATH</TT> option is also
specified.  Or, it can specify the fully-qualified name of the Java jar
file that resides on the local machine.  This option will resolve STAF
variables.  For example:
<PRE>
  http://server1.company.com/staf/myservice.jar
  http://prdownloads.sourceforge.net/staf/STAXV333.zip
  C:/STAF/services/stax/STAX.jar
  {STAF/Config/STAFRoot}/services/email/STAFEmail.jar
</PRE>
<P>
<TT>ZIPPATH</TT> specifies the path to the service jar file in the
zip file specified by the <TT>EXECUTE</TT> option.  Note that this
option should only be used if the <TT>EXECUTE</TT> option specifies
a url for a zip file that can be unzipped using the STAF ZIP service.
This option does not resolve STAF variables.  For example:
<PRE>
  stax/STAX.jar
  myService.jar
</PRE>
<P>
<TT>OPTION</TT> specifies a configuration option that will be passed
on to JSTAF to further control the interface to the JVM where this
service will be run.  You may specify multiple <TT>OPTION</TT>s for
a given service.  See section <A HREF="#HDRJVMCFG">4.4.2, "JSTAF service proxy library"</A> for valid
options that can be specified for the JSTAF service proxy library.
<P>
<TT>PARMS</TT> specifies parameters that will be passed to the
service during initialization.
<P>
<P><I><B><A NAME="Header_52">Examples</A>:&nbsp;</B></I>&nbsp;
<PRE>
# Register the custom SERVICE1 service, downloading it from a web server
SERVICE SERVICE1 LIBRARY JSTAF EXECUTE http://www.company.com/service1.jar
 
# Register the custom SERVICE2 service, downloading it from a web server
SERVICE SERVICE2 LIBRARY JSTAF EXECUTE http://www.company.com/service2.jar \
        OPTION JVMName=SERVICE2
 
# Register the STAX V3.3.0 service, downloading it from the SourceForge website
SERVICE STAX LIBRARY JSTAF \
             EXECUTE http://prdownloads.sourceforge.net/staf/STAXV333.zip \
             ZIPPATH stax/STAX.jar \
             OPTION JVMName=STAX OPTION J2=-Xmx1024m \
             PARMS "EXTENSIONXMLFILE C:/staf/services/extensions.xml"
 
# Register the Cron V3.3.2 service, downloading it from the SourceForge website
SERVICE CRON LIBRARY JSTAF \
             EXECUTE http://server.company.com/staf/CronV332.zip \
             ZIPPATH cron/STAFCron.jar OPTION JVMName=CRON
 
# Register the Email service (which resides in a jar file on the local machine)
SERVICE EMAIL LIBRARY JSTAF EXECUTE C:/STAF/services/email/STAFEmail.jar \
              PARMS "MAILSERVER NA.relay.ibm.com \
                     BACKUPMAILSERVERS \"LA.relay.ibm.com EMEA.relay.ibm.com\""
</PRE>
<P>
A sample HTTP Service Loader Service Configuration File is available
on SourceForge that can be used to download the latest versions of
STAF Java services available on SourceForge such as STAX, Event,
Cron, EventManager, etc.  It is located at
http://staf.sourceforge.net/current/STAFHTTPSLS.cfg.
Note that you may need to customize this HTTPSLS configuration file
for the services that you use by changing parameters for some services
(like the <TT>MAILSERVER</TT> and <TT>BACKUPMAILSERVERS</TT> parameters
for the Email service) and/or you may need to run some services like STAX
in its own JVM with a larger maximum heap size for the JVM by adding some
<TT>OPTION</TT>s.  Or, you may not use use some of the services so you
may want to remove them, or you may want to download the STAF Java service
zip files and put them on your own web server for faster download times, etc.
<P>
<A NAME="IDX74"></A>
<A NAME="IDX76"></A>
<A NAME="IDX78"></A>
<HR><H2><A NAME="Header_53" HREF="#ToC_53">4.6 Authenticator Registration</A></H2>
<P><H3><A NAME="Header_54">4.6.1 Description</A></H3>
<P>Authenticator services are registered with the AUTHENTICATOR configuration statement.
The first Authenticator registered is the default, unless overridden by using the
<TT>DEFAULTAUTHENTICATOR</TT> operational parameter.
<P><H4><A NAME="Header_55">Syntax</A></H4>
<PRE>
AUTHENTICATOR &lt;Name&gt; LIBRARY &lt;Implementation library&gt; &#91;EXECUTE &lt;Executable&gt;&#93;
                     &#91;OPTION &lt;Name[=Value]&gt;&#93;... &#91;PARMS &lt;Parameters&gt;&#93;
</PRE>
<P>
<P><TT>&lt;Name&gt;</TT> is the name by which this authenticator service will be
known on this machine.  The name cannot be "none" as this is reserved for use by STAF.
If you want to authenticate across systems, you must register the authenticator on
each system using the same name (case-insensitive).
<P><TT>LIBRARY</TT> is the name of the shared library / DLL which implements
the authenticator service or acts as a proxy for the authenticator service.
See the information for each authenticator to determine the appropriate value
for this option.
<P><TT>EXECUTE</TT> is used by service proxy libraries to specify what
the proxy library should execute.  For example, this might be the name of the
Java jar file which actually implements the authenticator service.
This option has no significance for non-proxy service libraries.  See the
Service Registration section for information regarding the JSTAF
service proxy library.
<P><TT>OPTION</TT> specifies a configuration option that will be passed on
to the shared library / DLL.  This is typically used by service proxy
libraries to further control the interface to the actual service
implementation.  You may specify multiple <TT>OPTION</TT>s for a given
authenticator service.  See the Service Registration section for acceptable options
for the JSTAF service proxy library.  Otherwise, see the documentation
provided with the service (proxy) library.
<P><TT>PARMS</TT> specifies optional parameters that will be passed to the
authenticator service during initialization.
<P>
<P><H4><A NAME="Header_56">Examples</A></H4>
<PRE>
AUTHENTICATOR MyAuth LIBRARY JSTAF EXECUTE C:/STAF/services/MyAuth.jar
 
AUTHENTICATOR AuthSample LIBRARY JSTAF \
              EXECUTE {STAF/Config/STAFRoot}\services\AuthSampleV300.jar \
              OPTION JVMName=Auth \
              PARMS "UserPropertiesFile {STAF/Config/STAFRoot}/services/authsample.properties"
</PRE>
<A NAME="IDX80"></A>
<P><H3><A NAME="HDRSAMPLEAUTH">4.6.2 Sample Authenticator</A></H3>
<P>A sample authenticator service is provided by STAF and is available
via the
<A HREF="http://staf.sourceforge.net/getcurrent.php">Download STAF</A> website.
It is called AuthSample and is available as a jar file called
AuthSampleV300.jar.
<P>
<P><H4><A NAME="Header_58">Registration Syntax</A></H4>
<P>To try out user trust, you can register the sample authenticator as
follows (assuming you downloaded it to a services directory created in the
STAF root directory).
<PRE>
AUTHENTICATOR AuthSample LIBRARY JSTAF \
              EXECUTE {STAF/Config/STAFRoot}\services\AuthSampleV300.jar \
              PARMS "USERPROPERTIESFILE {STAF/Config/STAFRoot}/services/authsample.properties"
</PRE>
<P>
<P><TT>LIBRARY</TT> must be JSTAF for this sample authenticator
as it is implemented in Java.
<P><TT>EXECUTE</TT> must be the fully-qualified name of the AuthSampleV300.jar
file.
<P>This sample authenticator has the following required parameter:
<UL>
<P><LI><TT>UserPropertiesFile</TT> specifies the fully-qualified name of
a file that contains the user identifiers and passwords that this
authenticator supports.  The format of a user properties file must be
that of a Java Properties file.  A property file contains a set of strings.
Properties in a file are declared with the syntax name=value.  The
name specifies the user identifier and the value specifies its password.
</UL>
<P>To perform user authentication across systems, the authenticator
must be registered as the same name (case-insensitive) on all machines
where you want to use user trust authentication and with the same
user properties file (e.g. one that supports the same user identifiers
and passwords).
<P>
<P><H4><A NAME="Header_59">User Properties File</A></H4>
<P>An example of a user properties file is:
<PRE>
# User Properties File for the Sample Authenticator
 
User1=Password1
User2=Password2
User3=Password3
User4=Password4
User5=Password5
</PRE>
<P>You can specify any user identifiers and passwords that you want
in a user properties file.
However, if you specify any confidential information (e.g. any real
passwords that you want to protect), you should only use the secure
TCP interface so that this information is protected when sent over
the network.
<A NAME="IDX81"></A>
<A NAME="IDX83"></A>
<HR><H2><A NAME="HDROPPARMS" HREF="#ToC_60">4.7 Operational parameters</A></H2>
<P><H3><A NAME="Header_61">4.7.1 Description</A></H3>
<P>STAFProc allows you to set various parameters which affect the general
operation of STAF.  The SET configuration statement lets you set
these general operational parameters.
<P><H4><A NAME="Header_62">Syntax</A></H4>
<PRE>
SET &#91;CONNECTATTEMPTS &lt;Number&gt;&#93;
    &#91;CONNECTRETRYDELAY &lt;Number&gt;&#91;s|m|h|d|w&#93;&#93;
    &#91;MAXQUEUESIZE &lt;Number&gt;&#93;
    &#91;MAXRETURNFILESIZE &lt;Number&gt;&#91;k|m&#93;&#93;
    &#91;HANDLEGCINTERVAL &lt;Number&gt;&#91;s|m|h|d&#93;&#93;
    &#91;INITIALTHREADS &lt;Number&gt;&#93;
    &#91;THREADGROWTHDELTA &lt;Number&gt;&#93;
    &#91;DATADIR &lt;Directory Name&gt;&#93;
    &#91;INTERFACECYCLING &lt;Enabled | Disabled&gt;&#93;
    &#91;DEFAULTINTERFACE &lt;Name&gt;&#93;
    &#91;DEFAULTAUTHENTICATOR &lt;Name&gt;&#93;
    &#91;ENABLEDIAGS&#93;
    &#91;STRICTFSCOPYTRUST&#93;
    &#91;RESULTCOMPATIBILITYMODE &lt;Mode&gt;&#93;
    &#91;DEFAULTSTOPUSING &lt;Method&gt;&#93;
    &#91;DEFAULTNEWCONSOLE | DEFAULTSAMECONSOLE&#93;
    &#91;DEFAULTFOCUS &lt;Background | Foreground | Minimized&gt;&#93;
    &#91;PROCESSAUTHMODE &lt;Authentication Mode&gt;&#93;
    &#91;DEFAULTAUTHUSERNAME&#93;
    &#91;DEFAULTAUTHPASSWORD&#93;
    &#91;DEFAULTAUTHDISABLEDACTION &lt;Disabled Action&gt;&#93;
    &#91;DEFAULTSHELL &lt;Shell&gt;&#93;
    &#91;DEFAULTNEWCONSOLESHELL &lt;Shell&gt;&#93;
    &#91;DEFAULTSAMECONSOLESHELL &lt;Shell&gt;&#93;
</PRE>
<P><TT>CONNECTATTEMPTS</TT> specifies the maximum number of times to attempt
to connect to a remote system.  The default is 2.
Note that a trace warning message is generated for each failed attempt if the
Warning trace point is enabled.
You may also change this setting dynamically using the MISC service's SET command.
<P><TT>CONNECTRETRYDELAY</TT> specifies the maximum time in milliseconds to
wait after a failed connection attempt to a remote system before trying to connect
again (if the maximum number of times to attempt to connect to a remote system has
not been reached yet).  The default is 1000 (i.e., 1 second).
You may also change this setting dynamically using the MISC service's SET command.
The retry delay time may be expressed in milliseconds, seconds, minutes, hours,
days, or weeks.  Its format is <TT>&lt;Number&gt;[s|m|h|d|w]</TT>, where <TT>&lt;Number&gt;</TT>
is an integer &gt;= 0 and indicates milliseconds unless one of the
following case-insensitive suffixes is specified:  s (for seconds),
m (for minutes), h (for hours), d (for days), or w (for weeks).
Examples of valid values include <TT>2s</TT> or <TT>2000</TT>.
<P><TT>MAXQUEUESIZE</TT> specifies the maximum size of the queue associated
with each process' handle.  The default is 100.
You may also change this setting dynamically using the MISC service's SET command.
<P><TT>MAXRETURNFILESIZE</TT> specifies the maximum size of a file that
can be returned by a START request submitted to the PROCESS service running
on this machine or by a GET FILE request submitted to the FS service running
on this machine.  The default is 0 which indicates not to limit the maximum
size of returned files. Limiting the maximum returned file size can
help prevent out of memory issues as these requests put the entire returned file
contents in a result string which can consume a lot of memory for large files.
This value may be expressed in bytes, kilobytes, or megabytes.
Its format is <TT>&lt;Number&gt;[k|m]</TT> where <TT>&lt;Number&gt;</TT> is an integer
&gt;= 0 and indicates bytes unless one of the following case-insensitive suffixes
is specified:  <TT>k</TT> (for kilobytes) or <TT>m</TT> (for megabytes).
The calculated value cannot exceed <TT>4294967295</TT> bytes.
Examples of valid values include <TT>100000</TT>, <TT>500k</TT>, or
<TT>5m</TT>.
<P>Note that in addition to setting the <TT>MAXRETURNFILESIZE</TT> operational
parameter, you can also set the STAF/MaxReturnFileSize variable in the request
variable pool of the handle that submitted the request.  The lowest of these two
values is used as the maximum return file size (not including 0 which indicates
no limit).  Or, if you're using STAX, it also provides a <TT>MAXRETURNFILESIZE</TT>
parameter that can be set when registering the STAX service or dynamically via the
STAX service's SET MAXRETURNFILESIZE request.  See the
<A HREF="http://staf.sourceforge.net/current/STAX/staxug.html">STAX User's Guide</A>
for more information.
<P><TT>HANDLEGCINTERVAL</TT> specifies the time interval that the
Handle Manager's garbage collection polling loop will wait between
loops before polling each remote handle specified in the notification
list to see if the remote machine is still running the same instance
of STAFProc and if the handle still exists.  The default is 60000
(i.e. 1 minute).  You may also change this setting dynamically using
the MISC service's SET command.  The time interval may be expressed in
milliseconds, seconds, minutes, hours, or days.  Its format is
<TT>&lt;Number&gt;[s|m|h|d]</TT>, where <TT>&lt;Number&gt;</TT> is an integer
&gt;= 0 and indicates milliseconds unless one of the following
case-insensitive suffixes is specified:  s (for seconds), m (for minutes),
h (for hours), or d (for days).  Note that the calculated value
cannot be less than 5 seconds and cannot exceed 24 hours.  Examples of
valid values include <TT>2m</TT>, <TT>45s</TT>, or <TT>50000</TT>.
<P><TT>INITIALTHREADS</TT> specifies the number of threads initially created
to handle service requests.  The default is 5.
<P><TT>THREADGROWTHDELTA</TT> specifies the number of additional threads which
should be created when all existing threads are busy.  The default is 1.
<P><TT>DATADIR</TT> specifies the directory that STAF and its services will
use to write data.  The default is <TT>{STAF/Config/STAFRoot}/data/{STAF/Config/InstanceName}</TT>.
Note that this directory name must be unique per instance of
STAFProc running on a single machine.  Also, make sure to include the
"SET DATADIR" line in the STAF configuration file at the beginning of the
file, before any services are registered, since the data directory can be
used during service registration.
See <A HREF="#HDRDATADIRCFG">4.14, "Data Directory Structure"</A> for more information about the 
STAF data directory and its contents.
<P><TT>INTERFACECYCLING</TT> specifies whether to enable or disable automatic
interface cycling.  The default is to enable automatic interface cycling.
You may also change this setting dynamically using the MISC service's SET command.
Recognized values are the following:
<UL COMPACT>
<LI><TT>ENABLED</TT> - Enables automatic interface cycling which means that
if you do not specify an interface in the endpoint when submitting a STAF
request, STAF will attempt to connect to the endpoint using all of the
interfaces (aka connection providers) that are configured (instead of just the
default interface).  STAF will first try to connect via the cached interface
(if one exists for this endpoint).  If this endpoint is not cached, STAF will
first attempt to connect via the default interface.  If the connect attempt
fails, STAF will start attempting to connect using other configured interfaces
until one works or there are no more interfaces left to try.  If a connect
attempt succeeds, STAF will cache the interface that worked for this endpoint
so that the next STAF request that specifies this endpoint will try to connect
first using the cached interface.
<P>Note that automatic interface cycling only has an effect if there are
multiple interfaces configured in the STAF configuration file on the
machine that is submitting a STAF request.
Also, note that the MISC service provides a LIST ENDPOINTCACHE request to
show the cached endpoints and a PURGE ENDPOINTCACHE request to purge one
or more cached endpoints.
<P>
<LI><TT>DISABLED</TT> - Disables automatic interface cycling which means that
if you do not specify an interface in the endpoint when submitting a STAF request,
STAF will only try to connect to the endpoint using the default interface.
</UL>
<P><TT>DEFAULTINTERFACE</TT> specifies the name of the network interface
(aka connection provider) to use, by default.  If not specified, the first
interface registered is the default.
You may also change this setting dynamically using the MISC service's SET command.
<P><TT>DEFAULTAUTHENTICATOR</TT> specifies the name of the Authenticator to 
use, by default.  If not specified, the first Authenticator registered is the
default.  If no authenticators are registered, the default authenticator is
<TT>none</TT>.
You may also change this setting dynamically using the MISC service's SET command.
<P><TT>ENABLEDIAGS</TT> specifies to enable diagnostics.  The default is
to disable diagnostics.
You may also enable (or disable) recording diagnostics dynamically
using the DIAG service.
<P><TT>STRICTFSCOPYTRUST</TT> specifies to enable strict trust checking
when copying a file or directory using the FS service.  The default is
to disable strict trust checking (e.g. do lenient trust checking) on a FS
COPY request when the machine submitting the request is the same as the
machine where which the file/directory is being copied.
That is, <TT>STRICTFSCOPYTRUST</TT> specifies that a trust check should be done to
verify that MachineA trusts MachineB when MachineA submits a COPY request to the
FS service on MachineB to copy a file or directory back to MachineA.
The default is to do lenient trust checking so that MachineA does not have
to trust MachineB since why would MachineA ask MachineB to copy the file/directory
if he didn't want the copy to work.
You may also change this setting dynamically using the FS service's SET command.
<P><TT>RESULTCOMPATIBILITYMODE</TT> specifies the compatibility mode used
when sending the result from a STAF service request back to a pre-STAF V3 system.
Recognized values are the following:
<UL COMPACT>
<LI><TT>VERBOSE</TT> - 
When structured data (see <A HREF="#HDRMARSHALL">6.1, "Marshalling Structured Data"</A>) is returned in
the result buffer string, this option indicates to automatically unmarshall
the data and provide it in a "verbose format" which is easy to read.
This "verbose format" is equivalent to the output provided when using the
STAF executable's -verbose option (see <A HREF="#HDRSTAFEXECMD">5.2, "STAF"</A>).
This is the default mode.
<LI><TT>NONE</TT> - This indicates that no changes to the result buffer string will
be made.  Note that marshalled data is not as easy to read.
</UL>
You may also change this setting dynamically using the MISC service's SET command.
<P><TT>DEFAULTSTOPUSING</TT> allows you to specify the default method used
to STOP processes.  See <A HREF="#HDRPSSTOP">8.13.3, "STOP"</A> for more information on available
methods.
You may also change this setting dynamically using the PROCESS service's SET command.
<P><TT>DEFAULTNEWCONSOLE</TT> specifies that processes should be STARTed in a
new console window.  So, if a process's stdout/stderr is not redirected, it will be
unavailable.  This is the default for Windows systems.
You may also change this setting dynamically using the PROCESS service's SET command.
<P><TT>DEFAULTSAMECONSOLE</TT> specifies that processes should be STARTed in
the same console as STAFProc.  So, if a process's stdout/stderr is not redirected,
it will be written to STAFProc's stdout/stderr.  This is the default on Unix systems.
You may also change this setting dynamically using the PROCESS service's SET command.
<P><TT>DEFAULTFOCUS</TT> specifies the focus that is to be given to new windows
opened when starting a process on a Windows system. The default focus mode is Background.
This option only has effect on Windows systems.  This option will resolve variables.
See <A HREF="#HDRPROCSTR">8.13.2, "START"</A> for more information on the <TT>FOCUS</TT> option.
You may also change this setting dynamically using the PROCESS service's SET command.
<P><TT>PROCESSAUTHMODE</TT> specifies the mode by which usernames/passwords
are authenticated when starting processes.  The value of this option is platform
specific.  Recognized values are the following:
<UL COMPACT>
<LI><TT>DISABLED</TT> - This indicates that the user may not specify a username/password
with which to authenticate when starting a process.  This mode is available on
all platforms.  This is default mode.
<LI><TT>WINDOWS</TT> - This indicates that windows-based authentication should be used.
This mode is only available on Windows systems.
See <A HREF="#HDRWINUSER">"Starting a Process Under a Different User on Windows"</A> for more information.
<LI><TT>NONE</TT> - This indicates that usernames will be honored but not authenticated.
In this mode, passwords are ignored and processes are started under the indicated
username.  This mode is only available on Unix systems.
</UL>
<P><B>Note: </B>Previously, <TT>PASSWD</TT> and <TT>SHADOW</TT> were supported values
for the <TT>PROCESSAUTHMODE</TT> on Unix systems, but support for for these
modes has been removed.
<P>
You may also change this setting dynamically using the PROCESS service's SET command.
<P><TT>DEFAULTAUTHUSERNAME</TT> specifies the username under which processes
will be started, by default.  Note, this option IS valid even if process
authentication has been disabled.
You may also change this setting dynamically using the PROCESS service's SET command.
<P><TT>DEFAULTAUTHPASSWORD</TT> specifies the password with which processes
will be authenticated, by default.  Note, this option IS valid even if process
authentication has been disabled.
You may also change this setting dynamically using the PROCESS service's SET command.
<P><TT>DEFAULTAUTHDISABLEDACTION</TT> specifies what default action should be
taken if the user specifies a username/password on a request to start a process
when process authentication has been disabled.  The following values are
recognized:
<UL COMPACT>
<LI><TT>IGNORE</TT> - This indicates that the username/password should be ignored.  The
request will be processed as if the user had not specified these parameters.
This is the default.
<LI><TT>ERROR</TT> - This indicates that an error should be passed back to the user.
</UL>
You may also change this setting dynamically using the PROCESS service's SET command.
<P><TT>DEFAULTSHELL</TT> specifies the default shell to use when starting a
process via a separate shell.  The default shell used for Unix systems is /bin/sh.
The default shell used for Windows systems is "cmd.exe /c".
You may also change this setting dynamically using the PROCESS service's SET command.
<P><TT>DEFAULTNEWCONSOLESHELL</TT> specifies the default shell to use when
starting a process in a new console window (e.g. <TT>NEWCONSOLE</TT>) via a separate shell, overriding
the <TT>DEFAULTSHELL</TT> value if specified.
You may also change this setting dynamically using the PROCESS service's SET command.
<P><TT>DEFAULTSAMECONSOLESHELL</TT> specifies the default shell to use when
starting a process in the same console as STAFProc (e.g. <TT>SAMECONSOLE</TT>) via a separate shell,
overriding the <TT>DEFAULTSHELL</TT> value if specified.
You may also change this setting dynamically using the PROCESS service's SET command.
<P>
A shell value can contain substitution characters described in the following table.
<BR>
<P><B><A NAME="Table_1">Table 1. Substitution Characters for Shells</A></B><BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Substitution character
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Description
</TH><TH ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Supported systems
</TH></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">%c
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Substitute the values specified by the <TT>COMMAND</TT> and
<TT>PARMS</TT> options.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Windows and Unix
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">%C
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Same as %c, except the substituted value will be quoted (with all
nested quotes properly escaped).
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Windows and Unix
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">%p
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Substitute the value specified by the <TT>PASSWORD</TT> option,
or an empty string if no <TT>PASSWORD</TT> is provided.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Windows and Unix
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">%P
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Same as %p, except the substituted value will be quoted (with all
nested quotes properly escaped).
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Windows and Unix
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">%t
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Substitute the value specified by the <TT>TITLE</TT> option,
or &lt;Unknown&gt; if no <TT>TITLE</TT> is provided.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Windows and Unix
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">%T
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Same as %t, except the substituted value will be quoted (with all
nested quotes properly escaped).
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Windows and Unix
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">%u
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Substitute the value specified by the <TT>USERNAME</TT> option,
or an empty string if no <TT>USERNAME</TT> is provided.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Windows and Unix
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">%U
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Same as %u, except the substituted value will be quoted (with all
nested quotes properly escaped).
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Windows and Unix
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">%w
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Substitute the value specified by the <TT>WORKLOAD</TT> option,
or &lt;Unknown&gt; if no <TT>WORKLOAD</TT> is provided.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Windows and Unix
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">%W
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Same as %w, except the substituted value will be quoted (with all
nested quotes properly escaped).
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Windows and Unix
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">%x
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Substitute the values specified by the <TT>COMMAND</TT> and
<TT>PARMS</TT> options followed by input/output redirection, if
I/O options are specified on the <TT>PROCESS START</TT> request
(e.g. <TT>STDIN, STDOUT</TT>).  When using this option, do not
specify any redirection in the <TT>COMMAND/PARMS</TT> values.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Windows and Unix
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">%X
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Same as %x, except the substituted value will be quoted (with all
nested quotes properly escaped).
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Windows and Unix
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">%%
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Substitute a %.
</TD><TD ALIGN="CENTER" VALIGN="TOP" WIDTH="17%">Windows and Unix
</TD></TR></TABLE>
<P>
<P><B>Notes: </B><OL COMPACT>
<LI>When specifying a shell value, it must contain one of the following: %c, %C, %x, %X.
<LI>The use of %c versus %C, as well as %x versus %X, is highly dependent
on the shell you specify.
If the shell expects the command and parameters to be parsed as a single string,
then use %C or %X.  If the shell expects the command and parameters to be parsed as separate
strings, then use %c or %x.
<LI>Specifying 'su - %u -c %C' as the shell when starting a process on a UNIX system
(so that it simulates the environment of the user specified by the <TT>USERNAME</TT> option)
will cause variables specified via an ENV option to not be set for the process.
</OL>
<P>
<P><H4><A NAME="Header_63">Examples</A></H4>
<PRE>
SET CONNECTATTEMPTS 5 CONNECTRETRYDELAY 2s
SET MAXQUEUESIZE 1000
SET MAXRETURNFILESIZE 25m
SET HANDLEGCINTERVAL 50s
SET INITIALTHREADS 10 THREADGROWTHDELTA 3
SET DATADIR /test/stafdata
SET DEFAULTINTERFACE tcp
SET DEFAULTAUTHENTICATOR SampleAuth
SET ENABLEDIAGS
SET RESULTCOMPATIBILITYMODE none
SET DEFAULTSTOPUSING SIGTERM DEFAULTSAMECONSOLE
SET DEFAULTFOCUS minimized
SET PROCESSAUTHMODE windows DEFAULTAUTHUSERNAME testuser DEFAULTAUTHPASSWORD tupass
SET PROCESSAUTHMODE none DEFAULTAUTHUSERNAME guest DEFAULTAUTHDISABLEDACTION error
SET DEFAULTSHELL "C:/cygwin/bin/bash.exe -c %C"
SET DEFAULTSAMECONSOLESHELL "/bin/csh -c %C"
SET DEFAULTNEWCONSOLESHELL "xterm -title %T -e /bin/sh -c %X"
SET DEFAULTSHELL "su - %u -c %C"
</PRE>
<A NAME="IDX85"></A>
<A NAME="IDX87"></A>
<HR><H2><A NAME="HDRVARCFG" HREF="#ToC_64">4.8 Variables</A></H2>
<P><H3><A NAME="Header_65">4.8.1 Description</A></H3>
<P>You may set STAF variables in the system or shared variable pool at startup by
using the SET VAR configuration statement. SET VAR will set a variable to a certain
value. The variable is created if it does not exist.
<P>Note that you may SET multiple variables with a single request.
<P><H4><A NAME="Header_66">Syntax</A></H4>
<PRE>
SET &#91;SYSTEM | SHARED&#93; VAR &lt;Name=Value&gt; &#91;VAR &lt;Name=Value&gt;&#93; ...
</PRE>
<P><TT>SYSTEM</TT> means the variable is to be set in system variable pool.
This is the default.
<P><TT>SHARED</TT> means the variable is to be set in shared variable pool.
<P><TT>VAR</TT> means the variable to be set. Name is the name of the variable
and Value is the value of the variable.
<P><H4><A NAME="Header_67">Examples</A></H4>
<PRE>
SET VAR WebServer=testsrv1.test.austin.ibm.com
SET SHARED VAR "Author1=Jane Tester" VAR "Author2=John Tester"
SET SYSTEM VAR STAF/Service/Log/Directory={STAF/Config/BootDrive}\STAF\Log
</PRE>
<A NAME="IDX89"></A>
<A NAME="IDX91"></A>
<HR><H2><A NAME="HDRTRUSTCFG" HREF="#ToC_68">4.9 Trust</A></H2>
<P><H3><A NAME="Header_69">4.9.1 Description</A></H3>
<P>You may grant access to machines or users by using the TRUST configuration
statement.
<P>Trust configuration statements for machines are based on the network
identification of the system.  In particular, different trust levels can be
given to the same system coming in through different networking interfaces.
Both logical and physical identifiers may be used in trust configuration
statements for machines.
<P>Trust configuration statements for users require that you have
an authenticator registered.
<P><H4><A NAME="Header_70">Syntax</A></H4>
<PRE>
TRUST LEVEL &lt;Level&gt; &lt; DEFAULT | MACHINE &lt;Machine&gt; &#91;MACHINE &lt;Machine&gt;&#93;... |
                      USER &lt;User&gt; &#91;USER &lt;User&gt;&#93;... &gt;
</PRE>
<P><TT>LEVEL</TT> is the level of trust that you wish to grant,
see <A HREF="#HDRTRSTCON">2.5, "Security"</A> for a list of trust levels.
This option will resolve variables.
<P><TT>DEFAULT</TT> indicates that you wish to set the default trust level.
This is the trust level that will be used for machines which have no
explicit trust level set.  If no default has been specified in the STAF
Configuration file, the default is set to 3.
<P><TT>MACHINE</TT> indicates a specific machine for which to set a trust
level.
This option will resolve variables.
The format for &lt;Machine&gt; is:
<PRE>
  &#91;&lt;Interface&gt;&#58;//&#93;&lt;System Identifier&gt;
</PRE>
where:
<UL COMPACT>
<LI><TT>&lt;Interface&gt;</TT> is the name of the network interface.
It is case-insensitive.
If the name of a network interface is not specified, wildcard '*' is
substituted which will match any network interface name.
<LI><TT>&lt;System Identifier&gt;</TT> is a valid network identifier for the network
interface.  It is case-insensitive.
Logical or physical identifiers may be specified for the system
identifier.  Physical identifiers are the lowest-level identifier
available via the specified network interface.  Logical identifiers are more
human readable identifiers that ultimately map to physical identifiers.
For example, for a TCP/IP interface, the physical identifier for a
machine is the IP address, while the logical identifier for a machine
is the hostname.
</UL>
<P>Note that you can specify match patterns (e.g. wild cards) in the
interface and the system identifier.  These patterns recognize two
special characters, '*' and '?', where '*' matches a string of
characters (including an empty string) and '?' matches any single
character (the empty string does not match).
<P>Note that if you specify the hostname in a trust specification
for a TCP/IP interface, you must specify the long host name
(and/or wildcards).
<P>Note that if you specify a port (e.g. @6500) at the end of the
system identifier, it will be removed.
<P>Requests coming from the local system will now appear as though
they came from an interface named "local" and a system identifier
of "local".  This allows you to specify a trust level for local
requests.  (In STAF V2.x, local requests were automatically granted
a trust level of 5.)
<P><TT>USER</TT> indicates a user for which to set a trust level.
This option will resolve variables.
The format for &lt;User&gt; is:
<PRE>
  &#91;&lt;Authenticator&gt;&#58;//&#93;&lt;User Identifier&gt;
</PRE>
where:
<UL COMPACT>
<LI>&lt;Authenticator&gt; is the name of the authenticator.
It is case-insensitive.  If an authenticator is not specified, the default
authenticator is used.
<LI>&lt;User Identifier&gt; is a valid user identifier for the authenticator.
It is case sensitive.
</UL>
<P>Note that you can specify match patterns in the authenticator name
and the user identifier.  These patterns recognize two special characters,
'*' and '?', where '*' matches a string of characters (including an
empty string) and '?' matches any single character (the empty string
does not match).
<P>
<P><H4><A NAME="HDRUSERTRUSTMATCHING">How to determine Effective Trust for a User</A></H4>
<P>If multiple trust specifications would match the same user,
STAF will rank the matching specifications as follows and use the
match with the highest (i.e. lowest numbered) rank:
<OL COMPACT TYPE=1>
<LI>Exact match of authenticator and user identifier
<LI>Exact match of authenticator, wildcard match of user identifier
<LI>Wildcard authenticator match, exact match of user identifier
<LI>Wildcard authenticator match, wildcard match of user identifier
</OL>
If multiple trust specifications match within the same rank, the
lowest matching trust level will be used.
<P>
<P><H4><A NAME="HDRMACHINETRUSTMATCHING">How to determine Effective Trust for a Machine</A></H4>
<P>
<P>If multiple trust specifications would match the same system,
STAF will rank the matching specifications as follows and use the
match with the highest (i.e. lowest numbered) rank:
<OL COMPACT TYPE=1>
<LI>Exact match of interface and physical network identifier
<LI>Exact match of interface and logical network identifier
<LI>Exact match of interface, wildcard match of physical network identifier
<LI>Exact match of interface, wildcard match of logical network identifier
<LI>Wildcard interface match, exact match of physical network identifier
<LI>Wildcard interface match, exact match of logical network identifier
<LI>Wildcard interface match, wildcard match of physical network identifier
<LI>Wildcard interface match, wildcard match of logical network identifier
</OL>
If multiple trust specifications match within the same rank, the
lowest matching trust level will be used.
<P>
<P><B>Note: </B>The user authentication overrides the machine authentication.
For example, if the machine trust level is 3 and the authenticated user
has a trust level of 4, then the handle will have a trust level of 4.
If the user has been authenticated, but there are no user authentication
trust matches, the machine trust level is used.  If there is no
machine trust level specified, then the default trust level is used.
<P>
<A NAME="IDX93"></A>
<P><H4><A NAME="Header_73">Examples</A></H4>
<PRE>
TRUST DEFAULT LEVEL 3
TRUST LEVEL 5 MACHINE local&#58;//local
TRUST LEVEL 5 MACHINE client1.austin.ibm.com MACHINE client3.raleigh.ibm.com
TRUST LEVEL 5 MACHINE 9.3.224.16
TRUST LEVEL 4 MACHINE tcp&#58;//mysystem.site.com
TRUST LEVEL 0 MACHINE badguy.austin.ibm.com
TRUST LEVEL 3 MACHINE tcp2&#58;//9.3.224.*
TRUST LEVEL 2 MACHINE *.austin.ibm.com
TRUST LEVEL 2 MACHINE tcp*&#58;//*.site.com
TRUST LEVEL 5 USER John@company.com USER Jane@company.com
TRUST LEVEL 0 USER badguy@company.com
TRUST LEVEL 3 USER *@company.com
TRUST LEVEL 4 USER SampleAuth&#58;//*@company.com
TRUST LEVEL 1 USER *&#58;//*
</PRE>
<A NAME="IDX95"></A>
<A NAME="IDX97"></A>
<HR><H2><A NAME="HDRNOTIFYCFG" HREF="#ToC_74">4.10 Start/Shutdown Notifications</A></H2>
<P><H3><A NAME="Header_75">4.10.1 Description</A></H3>
<P>You may specify that you want notifications sent to certain
machines/processes when STAF is either started or shutdown.  You do this by
using the NOTIFY configuration statement.  Notifications are handled by the
STAF Queue service, see <A HREF="#HDRQUEUESRV">8.14, "Queue Service"</A> for more information.
<P>
<P><B>Note: </B>You may also dynamically register for SHUTDOWN notifications via the
SHUTDOWN service, see <A HREF="#HDRSHUTDS">8.18, "Shutdown Service"</A>.
<P><B>Warning: </B>In order for the receiving machine to accept the
notifications, it must specify a default or explicit trust level of at least
3 for this machine.  As of version 2.2.0 of STAF, the default trust level
is 3, so no explicit action is necessary on systems running this version of
STAF (or higher).
<P><H4><A NAME="Header_76">Syntax</A></H4>
<PRE>
NOTIFY &lt;ONSTART | ONSHUTDOWN&gt; MACHINE &lt;Machine&gt; &#91;PRIORITY &lt;Priority&gt;&#93;
       &lt;NAME &lt;Name&gt; | HANDLE &lt;Handle&gt;&gt;
</PRE>
<P><TT>ONSTART</TT> indicates that a notification should be sent when
STAF is fully initialized.  The type of the message will be the string <TT>STAF/Start</TT>
with a blank message.
<P><TT>ONSHUTDOWN</TT> indicates that a notification should be sent when
STAF is shutdown.  The type of the message will be the string <TT>STAF/Shutdown</TT>
with a blank message.
<P><TT>MACHINE</TT> indicates the machine to receive the message.
<P><TT>PRIORITY</TT> indicates the priority of the message.  The default is
5.
<P><TT>NAME</TT> specifies that all processes with the given registered
name on the given machine should be notified.  This option is usually
preferred over <TT>HANDLE</TT>, as it is difficult to know the desired
handle in advance.
<P><TT>HANDLE</TT> specifies that the process with the given handle on the
given machine should be notified.
<P><H4><A NAME="Header_77">Examples</A></H4>
<PRE>
NOTIFY ONSTART MACHINE Server1 PRIORITY 3 NAME EventManager
NOTIFY ONSHUTDOWN MACHINE Server1 NAME EventManager
</PRE>
<A NAME="IDX99"></A>
<A NAME="IDX101"></A>
<HR><H2><A NAME="HDRTRACECFG" HREF="#ToC_78">4.11 Tracing</A></H2>
<P><H3><A NAME="Header_79">4.11.1 Description</A></H3>
<P>STAF provides various tracing facilities to help in auditing and debugging.
STAF externalizes these facilities through trace points.  Enabling a particular
trace point causes trace messages to be generated whenever a particular event
occurs, such as a service request resulting in an "Insufficient Trust Level"
(aka "Access Denied") error code.
Care should be taken when enabling trace points, as certain trace points,
such as ServiceResult, can lead to large quantities of trace messages being
generated.  In these cases, it is best to limit tracing to only specific
services.
<P>You may enable or disable STAF trace points and STAF services for tracing
using the <TT>TRACE</TT> configuration statement.  In addition, you can set the
trace output destination and set the default tracing state for newly
registered services.  By default, all STAF services are enabled for tracing.
Also, if you are using the default STAF configuration file provided, 
only the <TT>ERROR</TT> and <TT>DEPRECATED</TT> trace points are enabled
by default.
<P><B>Note: </B>The <TT> TRACE ENABLE/DISABLE SERVICE(S) </TT>statements affect the current
list of services.  So, if you add line <TT> TRACE DISABLE ALL SERVICES </TT>
to the configuration file and then register any external services later in the
configuration file, those services will not necessarily be disabled.
To ensure that all registered services are disabled, either set the default
service state to disabled, or add the <TT>TRACE</TT> statements after the
<TT>SERVICE</TT> configuration statements in the configuration file.
<P>
<P><H4><A NAME="Header_80">Syntax</A></H4>
<PRE>
TRACE ENABLE ALL  [ TRACEPOINTS | SERVICES ]
TRACE ENABLE TRACEPOINTS &lt;Trace point list&gt; | SERVICES &lt;Service list&gt;
TRACE ENABLE TRACEPOINT &lt;Trace point&gt; [TRACEPOINT &lt;Trace point&gt;]...
TRACE ENABLE SERVICE &lt;Service&gt; [SERVICE &lt;Service&gt;]...
 
TRACE DISABLE ALL  [ TRACEPOINTS | SERVICES ]
TRACE DISABLE TRACEPOINTS &lt;Trace point list&gt; | SERVICES &lt;Service list&gt;
TRACE DISABLE TRACEPOINT &lt;Trace point&gt; [TRACEPOINT &lt;Trace point&gt;]...
TRACE DISABLE SERVICE &lt;Service&gt; [SERVICE &lt;Service&gt;]...
 
TRACE SET DESTINATION TO &lt; [STDOUT | STDERR] [FILE &lt;File name&gt; [APPEND]] &gt;
TRACE SET DEFAULTSERVICESTATE &lt;Enabled | Disabled&gt;
TRACE SET MAXSERVICERESULTSIZE &lt;Number&gt;[k|m]
</PRE>
<P>See the TRACE service, section <A HREF="#HDRTRACESRV">8.19, "Trace Service"</A>,
for information on the above options.
<P>See table <A HREF="#HDRTRACEPOINTREF">8.19.2, "Trace Points Reference"</A> for a list of valid trace points.
<P>
<P><H4><A NAME="Header_81">Examples</A></H4>
<PRE>
TRACE SET DESTINATION TO STDERR
TRACE SET DESTINATION TO FILE {STAF/Config/STAFRoot}/bin/STAF.trc
TRACE SET DESTINATION TO FILE {STAF/Config/STAFRoot}/bin/STAF.trc APPEND
TRACE SET DESTINATION TO STDOUT FILE {STAF/Config/STAFRoot}/bin/STAF.trc
TRACE SET DESTINATION TO STDERR FILE {STAF/Config/STAFRoot}/bin/STAF.trc
TRACE ENABLE ALL
TRACE DISABLE SERVICE "Sem"
TRACE ENABLE TRACEPOINTS "Error ServiceAccessDenied"
TRACE DISABLE SERVICES "Process Queue Var"
TRACE SET DEFAULTSERVICESTATE Enabled
TRACE SET MAXSERVICERESULTSIZE 10k
</PRE>
<P> In order to ensure that you are only tracing service results on
the var and sem services, and that tracing for all other services is
disabled (including services registered in the future) do this &#58;
<PRE>
TRACE SET DEFAULTSERVICESTATE Disabled
TRACE DISABLE ALL SERVICES
TRACE DISABLE ALL TRACEPOINTS
TRACE ENABLE TRACEPOINTS "ServiceResult"
TRACE ENABLE SERVICES "VAR SEM"
</PRE>
<P>
<A NAME="IDX103"></A>
<A NAME="IDX105"></A>
<P>
<HR><H2><A NAME="HDREXAMPLESCFG" HREF="#ToC_82">4.12 Configuration File Examples</A></H2>
<P>
<P><H3><A NAME="HDRDEFAULTCFG">4.12.1 Default Configuration File</A></H3>
<P>This is the default configuration file provided with STAF.
<PRE>
# Turn on tracing of internal errors and deprecated options
trace enable tracepoints "error deprecated"
 
# Enable TCP/IP connections
interface ssl library STAFTCP option Secure=Yes option Port=6550
interface tcp library STAFTCP option Secure=No  option Port=6500
 
# Set default local trust
trust machine local://local level 5
 
# Add default service loader
serviceloader library STAFDSLS
</PRE>
<P>
<P><H3><A NAME="HDREXAMPLECFG">4.12.2 Configuration File Example</A></H3>
<P><B>Warning: </B>This configuration file contains references to fictional services,
machines, etc. and is provided for informational purposes only.  Please do
not try to use this as your actual STAF.cfg file.  It is unlikely to
work.
<PRE>
# ---------------------------------------------------------------------
# STAF Configuration File
# ---------------------------------------------------------------------
# Set the writeable location where STAF can write data
SET DATADIR E:\test\stafdata
 
# Enable TCP/IP connections
interface ssl library STAFTCP option Secure=Yes option Port=6550
interface tcp library STAFTCP option Secure=No  option Port=6500 option ConnectTimeout=10000
 
# Set default local trust
trust machine local&#58;//local level 5
 
# Add default service loader
serviceloader library STAFDSLS
 
# ---------------------------------------------------------------------
# STAF Log Mask Variable
# ---------------------------------------------------------------------
SET SHARED VAR STAF/Service/Log/Mask="START STOP WARNING FATAL ERROR"
 
# ---------------------------------------------------------------------
# Setup Trust Levels
# ---------------------------------------------------------------------
TRUST DEFAULT LEVEL 2
TRUST LEVEL 3 MACHINE test1.austin.ibm.com MACHINE test2.test.austin.ibm.com
TRUST LEVEL 5 MACHINE automate.austin.ibm.com
TRUST LEVEL 4 MACHINE *.test.austin.ibm.com
TRUST LEVEL 3 USER IBM&#58;//*@us.ibm.com
TRUST LEVEL 4 USER JohnDoe@company.com
TRUST LEVEL 0 USER BadGuy@company.com
 
# ---------------------------------------------------------------------
# Delegated Services
# ---------------------------------------------------------------------
SERVICE pager DELEGATE globpager.test.austin.ibm.com
 
# ---------------------------------------------------------------------
# Java Services
# ---------------------------------------------------------------------
 
# Operating system independent name for my STAF services directory
SET SYSTEM VAR myServiceDir={STAF/Config/STAFRoot}{STAF/Config/Sep/File}services
 
SERVICE STAX  LIBRARY JSTAF \
              EXECUTE {myServiceDir}{STAF/Config/Sep/File}STAX.jar \
              OPTION J2=-Xms64m OPTION J2=-Xmx128m
SERVICE Event LIBRARY JSTAF \
              EXECUTE {myServiceDir}{STAF/Config/Sep/File}STAFEvent.jar
 
# ---------------------------------------------------------------------
# C++ Services
# ---------------------------------------------------------------------
SERVICE log      LIBRARY STAFLog
SERVICE monitor  LIBRARY STAFMon
SERVICE respool  LIBRARY STAFPool
 
# ---------------------------------------------------------------------
# Notifications
# ---------------------------------------------------------------------
NOTIFY ONSTART MACHINE automate.austin.ibm.com PRIORITY 3 NAME EventManager
NOTIFY ONSHUTDOWN MACHINE automate.austin.ibm.com NAME EventManager
 
# ---------------------------------------------------------------------
# Activate tracing
# ---------------------------------------------------------------------
TRACE SET DESTINATION TO FILE {STAF/DataDir}/user/STAF.trc
TRACE ENABLE TRACEPOINTS "ServiceAccessDenied Error"
TRACE ENABLE SERVICES "Process Trust"
</PRE>
<A NAME="IDX107"></A>
<A NAME="IDX109"></A>
<HR><H2><A NAME="HDRTUNECFG" HREF="#ToC_85">4.13 Tuning</A></H2>
<P><H3><A NAME="Header_86">4.13.1 Description</A></H3>
<P>STAF provides a way to tune its thread stack size. This is done via setting 
a "STAF_THREAD_STACK_SIZE" environment variable before STAFProc gets started. User 
can use this environment variable to set STAF's thread stack size in kilobytes. 
<P><H4><A NAME="Header_87">Examples, to set the thread stack size to 128KB</A></H4>
<PRE>
On Unix: export STAF_THREAD_STACK_SIZE=128
On Windows: set STAF_THREAD_STACK_SIZE=128
</PRE>
<A NAME="IDX111"></A>
<A NAME="IDX113"></A>
<HR><H2><A NAME="HDRDATADIRCFG" HREF="#ToC_88">4.14 Data Directory Structure</A></H2>
<P>
By default, STAF and its services will write data to:
<TT>{STAF/Config/STAFRoot}/data/{STAF/Config/InstanceName}</TT>. 
For example: <TT>C:\STAF\data\STAF</TT> on Windows systems or <TT>/usr/local/staf/data/STAF</TT>
on Unix systems or <TT>/Library/staf/data/STAF</TT> on Mac OS X systems.
The <TT>STAF/DataDir</TT> system variable is set to the fully-qualified name
of this directory.
<P>
You may use the DATADIR operational parameter to change the writeable data directory for STAF. 
This directory name must be unique per instance of STAF running on a single machine.
<P>
Note that the ability to change the data directory allows you to install STAF to a shared location
(e.g. a read-only directory that is accessible via a mounted drive, etc.) and use a unique
writeable data directory per instance of STAF.
<P>
The following table describes the structure of the STAF data directory:
<BR>
<P><B><A NAME="Table_2">Table 2. Data Directory Structure</A></B><BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Directory Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Description
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>{STAF/DataDir}/tmp</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">This is the location where temporary data can be stored.
This directory and all of its contents will be removed and an empty <TT>tmp</TT>
directory is created whenever STAFProc is restarted.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>{STAF/DataDir}/user</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Other user data (e.g. from testcases, applications, etc.) can be stored in this
directory.  You should create subdirectories within this directory to when storing your
data.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>{STAF/DataDir}/service</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">This directory exists if one or more external services are (or have been) registered.
If a service stores persistent data, it should create a subdirectory within this
directory using its registered service name (in lower-case) and store its data in this
subdirectory.  For example:
<PRE>
{STAF/DataDir}/service/event
{STAF/DataDir}/service/log
{STAF/DataDir}/service/stax
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>{STAF/DataDir}/lang/java/jvm</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">This directory exists if one or more external Java services are (or have been) registered.
For each JVM created for Java services, STAF will create a subdirectory within this
directory using the name of the JVM.  The log files for the JVM (e.g. <TT>JVMLog.1</TT>)
will be stored in this subdirectory.  For example:
<PRE>
{STAF/DataDir}/lang/java/STAFJVM1/JVMLog.1
{STAF/DataDir}/lang/java/STAX/JVMLog.1
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>{STAF/DataDir}/lang/java/service</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">This directory exists if one or more external Java services are (or have been) registered.
For each Java service registered, STAF will create a subdirectory within this
directory using the registered service name and a subdirectory with it named <TT>jars</TT>.  
This subdirectory will contain nested jar files for the service, if any are provided
by the service.  For example:
<PRE>
{STAF/DataDir}/lang/java/service/Event/jars
{STAF/DataDir}/lang/java/service/STAX/jars
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>{STAF/DataDir}/register</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">For STAF's use only.  This directory is used for storing registration data, if any,
specified when this version of STAF was installed.
</TD></TR></TABLE>
<P>
<A NAME="IDX115"></A>
<A NAME="IDX117"></A>
<P><H3><A NAME="HDRTEMPDIR">4.14.1 Unix STAF Temporary Directory</A></H3>
<P>
On Unix systems, STAF also writes a few files to the /tmp directory by default
for each instance of STAFProc that is running.
You can override the location of the directory by setting the STAF_TEMP_DIR
environment variable.  However, you must use the same STAF_TEMP_DIR environment
variable for all instances of STAFProc in order for STAF to make sure that each
STAFProc instance has a unique STAF_INSTANCE_NAME and a unique {STAF/DataDir}.
Note that you should not specify {STAF/DataDir}/tmp for the value of the
STAF_TEMP_DIR environment variable because each time STAFProc starts, it
deletes the {STAF/DataDir}/tmp directory and this occurs after STAF creates
some of these files.
<P>
The following files are created in the Unix STAF Temporary Directory when
starting STAFProc (and are deleted when STAFProc is shutdown).
<P>
<UL>
<P><LI><TT>&lt;STAF_INSTANCE_NAME&gt;.tmp</TT>
<P><B>Note: </B><TT>&lt;STAF_INSTANCE_NAME&gt;</TT> will be replaced with the actual
STAF Instance Name which defaults to "STAF" unless it is overridden by setting
the STAF_INSTANCE_NAME environment variable.
<P><LI><TT>DataDir_&lt;DATADIR&gt;.tmp</TT>
<P><B>Note: </B><TT>&lt;DATADIR&gt;</TT> will be replaced with the resolved value of the
{STAF/DataDir}variable, with the slashes replaced with dashes.
For example: <TT>DataDir_-usr-local-staf-data-STAF.tmp</TT>
<P><LI><TT>STAFIPC_&lt;STAF_INSTANCE_NAME&gt;</TT>
<P>
This is a socket file used by the Unix Local IPC connection provider.
If this socket file is inadvertently deleted, local service requests will fail
with RC 21 (STAF Not Running).
<P><LI><TT>STAFIPC_&lt;STAF_INSTANCE_NAME&gt;JSTAF_&lt;JVMName&gt;</TT>
<P>
This is a socket file used by a STAF JVM that was created when registering a
STAF Java service.  There will be one socket file for each STAF JVM.
<P><B>Note: </B><TT>&lt;JVMName&gt;</TT> will be replaced by the actual STAF JVM name.
</UL>
<P>
<P><B>Warning!<BR><I>Do not delete these files while the STAFProc instance
is running.</I></B><P>
<P>
When submitting a request to the "local" interface to communicate with
a STAFProc instance, the STAF_INSTANCE_NAME environment variable must be
set (if the STAFProc instance is not using the default name "STAF").  Also,
on Unix only, the STAF_TEMP_DIR environment variable must be set
(if the STAFProc instance is not using the default "/tmp" directory).
Otherwise, the local service request will not be able to communicate with
that STAFProc instance and RC 21 (STAF Not Running) will be returned. 
<P>
<P>
<P>
<A NAME="IDX118"></A>
<A NAME="IDX120"></A>
<HR><H1><A NAME="HDRCOMMANDS" HREF="#ToC_90">5.0 Commands</A></H1>
<HR><H2><A NAME="HDRSTPROC" HREF="#ToC_91">5.1 STAFProc</A></H2>
<P>STAFProc is what starts STAF running on a machine.
<P><H4><A NAME="Header_92">Syntax</A></H4>
<PRE>
STAFProc &#91;STAF Configuration File&#93;
</PRE>
<P><H4><A NAME="Header_93">Examples</A></H4>
<PRE>
STAFProc d:\staf\bin\mystaf.cfg
</PRE>
<P>If <TT>&#91;STAF Configuration File&#93;</TT> is not specified, STAFProc
will try to use the file staf.cfg.  It will search for this file in the current
directory, as well as the directory in which STAFProc resides.
<P><B>Warning: </B>In order to stop the STAFProc daemon process, you should
enter the command "<TT>STAF local shutdown shutdown</TT>" (or use the
associated program in your "Start" menu on Windows systems).  Pressing CTRL-C (or
issuing a "kill" command) will terminate STAFProc, but will not allow it
to properly cleanup, which may cause problems and/or delays when trying
to restart STAFProc.  See section <A HREF="#HDRSHUTDS">8.18, "Shutdown Service"</A> for more information
on the SHUTDOWN service.
<P><B>Note: </B>Any changes made to the STAF Configuration File after STAFProc has been started
will not take effect until you shutdown and restart STAFProc.
<P><H3><A NAME="HDRMULTIPLEINSTANCES">5.1.1 Running Multiple Instances of STAFProc</A></H3>
<P>Multiple instances of STAFProc can be run at the same time on the
same system .  This makes it possible to use STAF to install/upgrade STAF itself.
To run multiple instances of STAF, system-specific resources need to be
differentiated.  There is a special environment variable, STAF_INSTANCE_NAME,
that can be used to specify a name for each STAFProc instance to differentiate
between multiple instances of STAF.  If this environment variable is not set, the
default value, "STAF", is used for the instance name.
If the STAF_INSTANCE_NAME environment variable is not set to a unique value
prior to starting a new instance of STAFProc, you will see a
"STAFProc already started" error.
<P>
For each instance of STAFProc running on a system, the following settings must be unique:
<UL>
<P><LI>Ports used by TCP Connection Providers:
<P>The ports used by STAF TCP connection providers must be unique,
otherwise, you'll get a "Error starting tcp interface" error when starting STAFProc.
If one instance of STAF is running using a ssl interface with port 6550 and
a tcp interface port 6500,
then to start another instance of STAF that also uses a ssl and tcp interface,
you must specify a different ports in its STAF configuration file.  For example:
<PRE>
interface tcp library STAFTCP option SECURE=Yes option PORT=6551
interface tcp library STAFTCP option SECURE=No  option PORT=6501
</PRE>
<P><LI>Data directory:
<P>Each STAFProc instance must use a different data directory.
However, since the default setting for the data directory
is {STAF/Config/STAFRoot}/data/{STAF/Config/InstanceName}, the data
directory names will be different if they are not overridden using
the DATADIR operational setting (and as long as the STAF_INSTANCE_NAME
environment variable is set to a unique value).
If the data directory for a STAFProc instance is not unique, you'll get a
"Data directory is already in use" error when starting STAFProc
</UL>
<P>
The installer creates a STAFEnv script file in the root STAF install
location that can be used to set the required environment variables
for a version of STAF.  On Windows, the script file is called
STAFEnv.bat and on Unix, the script file is called STAFEnv.sh.
The STAFEnv script files are especially useful if you are going to be
running two versions of STAF on the same machine and need a convenient
way to switch settings for each version of STAF.
An optional argument specifying the STAF instance name can be passed
to a STAFEnv script file.
A similar STAFEnv script file will also be created for setting up the
environment for STAF V2, if STAF V2 is installed on the same machine
as STAF V3.
<P>
Here's a sample STAFEnv.bat file for Windows: 
<PRE>
@echo off
REM STAF environment variables for 3.0.2
set PATH=C:\STAF\bin;%PATH%
set CLASSPATH=C:\STAF\bin\JSTAF.jar;C:\STAF\samples\demo\STAFDemo.jar;%CLASSPATH%
set STAFCONVDIR=C:\STAF\codepage
if "%1" EQU "" set STAF_INSTANCE_NAME=STAF
if "%1" NEQ "" set STAF_INSTANCE_NAME=%1
</PRE>
<P>
Here's a sample STAFEnv.sh file for Linux: 
<PRE>
#!/bin/sh
# STAF environment variables for 3.0.2
PATH=/usr/local/staf/bin&#58;$PATH
LD_LIBRARY_PATH=/usr/local/staf/lib&#58;$LD_LIBRARY_PATH
CLASSPATH=/usr/local/staf/lib/JSTAF.jar&#58;/usr/local/staf/samples/demo/STAFDemo.jar&#58;$CLASSPATH
STAFCONVDIR=/usr/local/staf/codepage
if [ $# = 0 ]
then
    STAF_INSTANCE_NAME=STAF
else
    STAF_INSTANCE_NAME=$1
fi
export PATH LD_LIBRARY_PATH CLASSPATH STAFCONVDIR STAF_INSTANCE_NAME
</PRE>
<P>
The sample scripts that are created automatically by STAF will use
the actual install directories in the STAFEnv script files.
<P>
Here's an example of starting STAF V2 and STAF V3 on a Windows system,
where STAF V2 is installed in C:\STAF and STAF V3 is installed in
C:\STAF3.  The STAF configuration file used by each STAFProc
instance specify different port numbers for each TCP Connection Provider.
<PRE>
  C:
  cd \STAF
  STAFEnv.bat
  STAFProc
</PRE>
In another command prompt:
<PRE>
  C:
  cd \STAF3
  STAFEnv.bat
  STAFProc
</PRE>
<P>
Here's an example of starting two instances of STAF V3 on a Unix system,
specifying instance name STAF (the default) for one instance and
instance name STAF2 for another instance.  The STAF configuration file
used by each STAFProc instance specify different port numbers for each
TCP Connection Provider.
<PRE>
  cd /usr/local/staf
  . ./STAFEnv.sh
  STAFProc /usr/local/staf/bin/STAF.cfg & 
  
  . ./STAFEnv.sh STAF2
  STAFProc /usr/local/staf/bin/STAF2.cfg & 
</PRE>
<P>
<P><B>Note: </B>The STAF_INSTANCE_NAME environment variable must be set to the same
value for a given STAFProc daemon and any applications/testcases that want
to communicate to the instance of STAF.
<P>
<P><H3><A NAME="HDRWINVISTA">5.1.2 Running STAFProc on Windows with User Account Controls (UAC) Enabled</A></H3>
<P>
On Windows Vista and Windows Server 2008 and later (including Windows 7,
Windows 8, Windows 8.1, Windows Server 2012, Windows Server 2012 R2,
Windows 10, etc)
with User Account Controls (UAC) enabled, STAFProc is run using the least amount
of privileges (e.g. that of a standard user) even if you are logged in as an
administrator.  If you want to run a process via
the STAF PROCESS START request that requires administrative privileges,
such as an install program, and not get UAC prompts, you may need to
run STAFProc as an administrator.  There are several ways to do this:
<UL COMPACT>
<LI>Find STAFProc.exe (e.g. C:\STAF\bin\STAFProc.exe) via Windows Explorer and
right mouse click on it.  To change just this one instance of starting STAFProc,
select "Run as administrator".
<LI>Or, find STAFProc.exe (e.g. C:\STAF\bin\STAFProc.exe) via Windows Explorer and
right mouse click on it.  Select "Properties" and then select the "Compatibility" tab,
and check the box under "Privilege Level" labeled "Run the program as an administrator"
and select OK.  Now, any time you start STAFProc it will be run as an administrator.
<LI>Or find "Command Prompt" and right mouse on it and select "Run as administrator".
Any program such as STAFProc that is run from an "Administrator: Command Prompt", will be
run as an administrator.
</UL>
<P>
<P><B>Note: </B>When STAFProc.exe is run as an Administrator, you must also run STAF.exe
as an Administrator if you want to submit STAF requests from a command prompt
on the local Windows sytems.  Otherwise, you'll get "Error registering with STAF, RC: 21".
The same is true if you run a program on this Windows system that submits
STAF service requests using the STAF APIs for Java, C/C++, Perl, Python, Tcl, etc,
such as the STAX Monitor Java application.  The program must also be
run as an Administrator (e.g. by running it from an "Administrator: Command Prompt"). 
<P>
<A NAME="IDX121"></A>
<A NAME="IDX123"></A>
<HR><H2><A NAME="HDRSTAFEXECMD" HREF="#ToC_96">5.2 STAF</A></H2>
<P>STAF is an executable that is used to submit requests to STAF from the
command line.  Please see <A HREF="#HDRSTAFSHS">"Using the STAF command from shell-scripts"</A> for more information
on using the STAF command from within shell-scripts.
<P><H4><A NAME="Header_97">Syntax</A></H4>
<PRE>
STAF [-verbose] &lt;Endpoint&gt; &lt;Service&gt; &lt;Request&gt;
</PRE>
<P>
<UL>
<P><LI><TT>-verbose</TT> specifies to force the use of the verbose mode for
the output.
<P>
<P><LI><TT>&lt;Endpoint&gt;</TT> is either LOCAL, if you wish to make a request of the
local machine, or the name of the machine of which you wish to make a request.
When making a STAF request to a remote system, in addition to specifying
the machine name, you may also specify the network interface over which
communication will take place.  The format for this is: 
<PRE>  [&lt;Interface&gt;://]&lt;System Identifier&gt;[@&lt;Port&gt;]
</PRE>
where:
  <UL COMPACT>
  <LI><TT>&lt;Interface&gt;</TT> is the name of the network interface.
  If not specified, the default interface is used.
  <LI><TT>&lt;System Identifier&gt;</TT> is a valid network identifier for
  the interface in question.  You may specify logical or physical
  identifiers.  For example, for a TCP/IP interface, the physical identifier
  for a system is the IP address, while the logical identifier is the hostname.
  <LI><TT>&lt;Port&gt;</TT> is a valid port to use for a TCP/IP interface.
  If not specified, the port for the default interface is used.
  One of the things this allows you to do is communicate with an instance of
  STAF that is using a different TCP/IP port.  Note that the port specified
  does not have to be configured on the machine submitting the request.
  </UL>
<P>
<P><LI><TT>&lt;Service&gt;</TT> is the name of the service to which you are
submitting a request.  Note the name of a service is case-insensitive.
<P>
<P><LI><TT>&lt;Request&gt;</TT> is the actual request string that you wish to submit
to the service.  Note that the options for requests to STAF services are
case-insensitive.
</UL>
<P>
<P><H4><A NAME="Header_98">Examples</A></H4>
<PRE>
STAF local PING PING
STAF local sem event SynchSem post
STAF testmach1 PROCESS START COMMAND notepad
STAF testmach1.company.com PROCESS LIST
STAF -verbose testmach1.company.com PROCESS LIST
STAF ssl&#58;//testmach1 PROCESS START SHELL COMMAND /tests/myTest RETURNSTDOUT STDERRTOSTDOUT WAIT
STAF tcp&#58;//testmach1 TRUST LIST
STAF alt-tcp2&#58;//9.3.283.13 SERVICE LIST
STAF testmach1@6600 PROCESS START COMMAND notepad NOTIFY ONEND
STAF tcp&#58;//testmach.company.com@6500 MISC WHOAMI
STAF local ECHO ECHO "Hi there"
STAF 9.3.823.20 LOG MACHINE LOGNAME MyLog LEVEL info MESSAGE "This is a message"
STAF local var set SYSTEM var "SomeName=Some  text  string"
</PRE>
<P><H4><A NAME="Header_99">Notes</A></H4>
<OL TYPE=1>
<P><LI>Take a closer look at the last three examples.  Quotes are required around the
value to the echo, message, and set options because their values contain spaces.
When calling STAF APIs directly from testcases/applications, you should normally use the
colon-length-colon delimited format described in <A HREF="#HDROVFORM">7.2, "Option Value Formats"</A>.
<P><LI>Older versions of STAF (prior to V2.1.0) required extra effort when
quoting things on the command line.  If you should need to resort to the
old command line handling algorithm, simply set the environment variable
STAF_OLDCLI to any non-empty value.
<P><LI>If running multiple instances of STAFProc, the STAF_INSTANCE_NAME
environment variable must be set to the instance name of the STAFProc
daemon that you want the STAF command to talk to.  For example:
<PRE>
set STAF_INSTANCE_NAME=MySTAF
staf local ping ping
</PRE>
</OL>
<P>
<P><H4><A NAME="Header_100">Output</A></H4>
<P>On a successful STAF request (i.e., a request with a zero return code), the
output from the STAF command will be as follows
<PRE>
Response
--------
&lt;Result string&gt;
</PRE>
<P>where <TT>&lt;Result string&gt;</TT> is any information that was returned from
the STAF service request.
<P>For example, the output of <TT>STAF LOCAL PING PING</TT> should be
<PRE>
Response
--------
PONG
</PRE>
<P>On an unsuccessful STAF request (i.e., a request with a non-zero return
code), the output from the STAF command will be as follows
<PRE>
Error submitting request, RC: &lt;Return code&gt;
Additional info
---------------
&lt;Result string&gt;
</PRE>
<P>where <TT>&lt;Return code&gt;</TT> is the actual return code from the request,
and <TT>&lt;Result string&gt;</TT> is any information returned from the request.
<TT>&lt;Result string&gt;</TT> usually contains information that explains why the
error occurred.  Note, the "Additional info" will only be present if a non-empty
result string was returned.  Additionally, you may refer to
<A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A> for information about the <TT>&lt;Return code&gt;</TT>
<P>For example, the output of <TT>STAF LOCAL SEM LIST</TT> should be
<PRE>
Error submitting request, RC: 7
Additional info
---------------
You must have at least 1, but no more than 1 of the option(s), MUTEX EVENT
</PRE>
<P><B>Note: </B>If the <TT>&lt;Result string&gt;</TT> from a STAF command contains any null
characters, you can set the environment variable STAF_REPLACE_NULLS
to any non-empty value.  This will cause the STAF command to replace any null
characters in the <TT>&lt;Result string&gt;</TT> with the specified value.
Otherwise, the <TT>&lt;Result string&gt;</TT> will be truncated at the first null
character found.
<P>When structured data (see <A HREF="#HDRMARSHALL">6.1, "Marshalling Structured Data"</A>) is returned in the result
strings above, the STAF command will automatically unmarshall the data and
print it in the most appropriate format.  If the data is a
<TT>&lt;List&gt; of &lt;String&gt;</TT>, then each entry in the list will be printed
on its own line.  For example,
<PRE>
C:\&gt; staf local fs list directory c:\
Response
--------
AUTOEXEC.BAT
boot.ini
CONFIG.SYS
Documents and Settings
i387
IO.SYS
MSDOS.SYS
My Music
NTDETECT.COM
ntldr
PAGEFILE.SYS
Program Files
Recycled
RECYCLER
System Volume Information
temp
WINNT
</PRE>
<P>If the data is a <TT>&lt;Map&gt;</TT> (or <TT>&lt;Map:&lt;Class&gt;&gt;</TT>) which
has values which are all of type <TT>&lt;String&gt;</TT>, then each key/value pair will
be printed on its own line.  For example,
<PRE>
C:\&gt; staf local monitor list settings
Response
--------
Max Record Size    : 1024
Resolve Message    : Disabled
Resolve Message Var: Disabled
</PRE>
<P>The above two types of formatted output are frequently referred to as
"default format".
<P>If the data is a <TT>&lt;List&gt; of &lt;Map:&lt;Class&gt;&gt;</TT> where every item in
the list is an instance of the same map class, then the data will be printed
out in a tabular format, called "table format".  For example,
<PRE>
$ staf local handle list handles
Response
--------
Handle Handle Name                     State      Last Used Date-Time
------ ------------------------------- ---------- -------------------
1      STAF_Process                    InProcess  20040929-13:57:40
2      STAF/Service/STAFServiceLoader1 InProcess  20040929-16:06:47
5      STAF/Service/LOG                InProcess  20040929-13:57:52
7      STAF/Service/RESPOOL            InProcess  20040929-13:58:04
51     STAF/Service/MONITOR            InProcess  20040929-16:06:47
57     STAF/Client                     Registered 20040929-16:09:35
</PRE>
<P>
The column headings in the table format are determined using the display name
specified for each key.  Short display names may be used as column headings
by the STAF executable when displaying the result in a tabular form if the
total width of the display names exceeds 80 characters.
<P>
By default a single record in the table format will only display the first
20 lines (the last line will show "(More...)" to indicate that there were
more lines in the record).  You can override the maximum number of lines that
are displayed per record by setting the environment variable
STAF_TABLE_LINES_PER_RECORD to the maximum number of lines.
<P>You can disable the output of tables by setting the environment variable
STAF_PRINT_NO_TABLES to any value.  If you disable the output of tables, their
data will show up in the more verbose mode (described below).
<P>If the data is more complex than the above (or tables have been turned off),
the output will be printed in a hierarchical nested format, called "verbose
format".  The best way to describe it is with an example.
<PRE>
C:\&gt; staf local sem query event Test
Response
--------
{
  State      : Reset
  Last Posted: {
    Machine    : crankin3
    Handle Name: STAF/Client
    Handle     : 62
    User       : none://anonymous
    Date-Time  : 20040929-16:20:56
  }
  Last Reset : {
    Machine    : crankin3
    Handle Name: STAF/Client
    Handle     : 65
    User       : none://anonymous
    Date-Time  : 20040929-16:21:43
  }
  Waiters    : [
    {
      Machine    : crankin3
      Handle Name: TestHandle
      Handle     : 67
      User       : none://anonymous
      Date-Time  : 20040929-16:22:16
    }
  ]
}
</PRE>
<P>You can change the amount of indentation used by setting the environment
variable STAF_INDENT_DELTA to any non-negative integer.
<P>You can use the -verbose option to force the use of the verbose
mode on a command basis.  For example,
<PRE>
C:\&gt; staf -verbose local fs list directory c:\
Response
--------
[
  AUTOEXEC.BAT
  boot.ini
  CONFIG.SYS
  Documents and Settings
  i387
  IO.SYS
  MSDOS.SYS
  My Music
  NTDETECT.COM
  ntldr
  PAGEFILE.SYS
  Program Files
  Recycled
  RECYCLER
  System Volume Information
  temp
  WINNT
]
</PRE>
<P>You can force the exclusive use of the verbose mode by setting the
environment variable STAF_PRINT_MODE to "verbose".  For example,
<PRE>
C:\&gt; set STAF_PRINT_MODE=verbose
 
C:\&gt; staf local fs list directory c:\
Response
--------
[
  AUTOEXEC.BAT
  boot.ini
  CONFIG.SYS
  Documents and Settings
  i387
  IO.SYS
  MSDOS.SYS
  My Music
  NTDETECT.COM
  ntldr
  PAGEFILE.SYS
  Program Files
  Recycled
  RECYCLER
  System Volume Information
  temp
  WINNT
]
</PRE>
<P>If you should ever need to get at the raw result string (instead of the
structured output), you can set the environment variable STAF_PRINT_MODE to "raw".
For example,
<PRE>
C:\&gt; set STAF_PRINT_MODE=raw
 
C:\&gt; staf local fs list directory C:/temp/docs
Response
--------
@SDT/*:267&#58;@SDT/{&#58;26::13&#58;map-class-map@SDT/{&#58;0&#58;@SDT/[10:218&#58;@SDT/$S:11&#58;STAFTcl.h
tm@SDT/$S:12&#58;STAFPerl.htm@SDT/$S:14&#58;STAFPython.htm@SDT/$S:7&#58;History@SDT/$S&#58;12&#58;ST
AFCMDS.htm@SDT/$S:11&#58;STAFFAQ.htm@SDT/$S:10&#58;STAFGS.pdf@SDT/$S:12&#58;STAFHome.htm@SDT
/$S:10&#58;STAFRC.htm@SDT/$S:10&#58;STAFUG.htm
</PRE>
<P>Note, by default, any <TT>&lt;String&gt;</TT> value that looks as though it, itself,
is a marshalled data structure will be recursively unmarshalled.  For example,
if someone marshalls a data structure and uses the resultant string as the
message for a log request, and then you query the log, the data structure
in the log message string will automatically be unmarshalled.  If you want
to turn off this behavior from the command line, and, instead, see the
marshalled string in the message, set the environment variable
STAF_IGNORE_INDIRECT_OBJECTS to any value.
<P><H4><A NAME="HDRSTAFSHS">Using the STAF command from shell-scripts</A></H4>
<P>There are two special environment variables that can be used to make the
STAF command blend in with shell-scripts.  The first is STAF_QUIET_MODE.
Setting this environment variable to any non-null value will cause the STAF
command to only output the <TT>&lt;Result string&gt;</TT> that the request
generated.  For example, the "STAF local ping ping" command above would simply
return
<PRE>
PONG
</PRE>
<P>This makes it easy to call STAF from shell-scripts.  For example,
<PRE>
export STAF_QUIET_MODE=1
 
STAFResult=`STAF local ping ping`
 
if [ $? -ne 0 ]; then
   echo "Non-zero return code from ping request";
elif [ "$STAFResult" != "PONG" ]; then
   echo "Expected PONG, received $STAFResult";
else
   echo "ping request succeeded"
fi
</PRE>
<P>The second environment variable is STAF_STATIC_HANDLE.  If this environment
variable is set, the STAF command will use the handle number indicated by this
environment variable.  This ensures that the shell-script can use the same
handle throughout its execution.  You may obtain a static handle in one of two
ways.  The first is using the CREATE command of the HANDLE service
(see <A HREF="#HDRHANDCRT">8.6.2, "CREATE"</A>).  For example,
<PRE>
export STAF_STATIC_HANDLE=`STAF local handle create handle name "My Test"`
</PRE>
<P>In this case, you are responsible for deleting the shell-scripts handle prior
to your shell-script exiting.  For example,
<PRE>
STAF local handle delete handle $STAF_STATIC_HANDLE
</PRE>
<P>The second way is by using the STATICHANDLENAME option when starting your
script through the PROCESS service (see <A HREF="#HDRPROCSTR">8.13.2, "START"</A>).  In this case
the STAF_STATIC_HANDLE environment variable will already be set for you.  In
addition, the handle will automatically be deleted by STAF when your
shell-script completes.
<P>You can test for the existence of the STAF_STATIC_HANDLE environment variable
to determine if your shell-script was started via STAF, or whether it was
started by hand from the command line.
<P>
<A NAME="IDX124"></A>
<HR><H1><A NAME="HDRAPIREF" HREF="#ToC_102">6.0 API Reference</A></H1>
<HR><H2><A NAME="HDRMARSHALL" HREF="#ToC_103">6.1 Marshalling Structured Data</A></H2>
<P>STAF supports the automatic marshalling and unmarshalling of structured data.
The act of marshalling takes a data structure and converts it into a
string-based representation.  The act of unmarshalling reverses this and
converts the string-based representation back into a data structure.
<P>STAF supports the following generic data types with its marshalling.
<UL COMPACT>
<LI>None - a unique type representing the absence of a value
<LI>String - an arbitrary string value
<LI>List - an ordered collection of other objects
<LI>Map - an unordered collection of key/value pairs
<LI>Map class - a Map with intrinsic metadata
<LI>Marshalling context - represents a set of map class definitions and a
data structure defined in terms of them
</UL>
<P>Most languages support some form of the None, String, List, and Map
data types.  However, a map class and a marshalling context are likely new
concepts.
<P>A map class is really just a specialized map that is associated with a 
map class definition.  The map class definition is used to reduce the size of
a marshalling map class in comparison to a map containing the same data.  It
also contains information about how to display instances of the map class.
A map class definition contains for following information for each key
defined for a map class:
<UL COMPACT>
<LI>key -  The name of the key in the map class
<LI>display-name - The display name for the key
<LI>display-short-name - The short display name for the key (Optional)
</UL>
<P>You indicate that a map is an instance of a map class by setting the key
"staf-map-class-name" to the name of the map class.  And, when you unmarshall
a data structure, if you see that a map has a key called "staf-map-class-name",
you know that the map is really an instance of a map class.  You get and set
map class definitions using a marshalling context.
<P>A marshalling context is simply a container for map class definitions and
a data structure that uses (or is defined in terms of) them.  In order to
use a map class when marshalling data, you must add the map class definition
to the marshalling context, set the root object of the marshalling context to
the object you want to marshall, and then marshall the marshalling context
itself.  When you unmarshall a data structure, you will always receive a
marshalling context.  Any map class definitions referenced by map classes
within the data structure will be present in the marshalling context.
<P>When a string is unmarshalled into a data structure, it is possible that
one of the string objects that is unmarshalled is itself the string form of
another marshalled data structure.  By default, STAF will recursively
unmarshall these nested objects.  However, each language has a way to
disable these additional processing.
<HR><H2><A NAME="HDRCAPI" HREF="#ToC_104">6.2 C</A></H2>
<P>STAF externalizes six primary APIs to C/C++ programs.  These APIs allow you
to register/unregister with STAF, submit service requests, and free the memory
associated with service request results.  In addition, STAF provides a wide
range of APIs for defining, manipulating, and marshalling data structures.
Also, STAF provides some APIs for handling private data.
<P>
<P><B>Note: </B>STAF-enabled programs written in C must be linked with the C++ compiler
(or by using any other means which allows the C++ runtime to get initialized).
Otherwise, the C++ runtime won't get a chance to initialize so the STAF
static data doesn't get initialized.  Most systems require mixed C and C++ code
to get linked by the C++ compiler.
<A NAME="IDX126"></A>
<A NAME="IDX128"></A>
<P><H3><A NAME="Header_105">6.2.1 STAFRegister</A></H3>
<P><H4><A NAME="Header_106">Description</A></H4>
<P>The STAFRegister call is used by a C program to register with STAF.
<P><H4><A NAME="Header_107">Syntax</A></H4>
<PRE>
STAFRC_t STAFRegister(char *handleName, STAFHandle *handle)
</PRE>
<P><TT>handleName</TT> points to the name by which you want this handle to
be known.
<P><TT>handle</TT> is a pointer to the STAFHandle that will be set on
successful return from the function.  You will use this handle on all other
subsequent STAF calls.
<A NAME="IDX131"></A>
<P><H4><A NAME="Header_108">Examples</A></H4>
<PRE>
char *myName = "MyProgram";
STAFHandle_t myHandle = 0;
STAFRC_t rc = STAFRegister(myName, &myHandle);
</PRE>
<A NAME="IDX133"></A>
<A NAME="IDX135"></A>
<P><H3><A NAME="Header_109">6.2.2 STAFRegisterUTF8</A></H3>
<P><H4><A NAME="Header_110">Description</A></H4>
<P>The STAFRegisterUTF8 API is identical in all respects with STAFRegister,
except that <TT>handleName</TT> is a string in UTF-8 format.  This API is
used primarily by the Java interfaces.
<A NAME="IDX137"></A>
<A NAME="IDX139"></A>
<P><H3><A NAME="Header_111">6.2.3 STAFUnRegister</A></H3>
<P>The STAFUnRegister call is used by a C program to unregister with
STAF, which frees up any internal STAF resources used by the handle.
<P><H4><A NAME="Header_112">Syntax</A></H4>
<PRE>
STAFRC_t STAFUnRegister(STAFHandle handle)
</PRE>
<P><TT>handle</TT> is the handle that you received on the call to
STAFRegister.
<A NAME="IDX142"></A>
<P><H4><A NAME="Header_113">Examples</A></H4>
<PRE>
/* myHandle was previously set by STAFRegister */
 
STAFRC_t rc = STAFUnRegister(myHandle);
</PRE>
<A NAME="IDX144"></A>
<P><H3><A NAME="Header_114">6.2.4 STAFSubmit</A></H3>
<P><H4><A NAME="Header_115">Description</A></H4>
<P>The STAFSubmit call is the primary API that you will use.  It is what
allows you to submit a request to a service.
<P><H4><A NAME="Header_116">Syntax</A></H4>
<PRE>
STAFRC_t STAFSubmit(STAFHandle handle, char *where, char *service,
                    char *request, unsigned int requestLength,
                    char **resultPtr, unsigned int *resultLength);
</PRE>
<P><TT>handle</TT> is the handle you received on the call to STAFRegister.
<P><TT>where</TT> points to a string containing the destination machine for
the service request.  This should be either LOCAL or the name of a machine.
<P><TT>service</TT> points to the name of the service to which you are
submitting the request.
<P><TT>request</TT> points to the actual request that you are sending to the
service. This request may contain NULL (0x00) bytes.
<P><TT>requestLength</TT> indicates the length of the request buffer passed
in.
<P><TT>resultPtr</TT> points to a char * that will contain the address of the
result on return from the function.  If, on return from STAFSubmit,
<TT>*resultPtr</TT> is not 0, you must use STAFFree to free the result, even
if the return code from STAFSubmit was non-zero.  Note, if resultPtr is
non-zero, then the buffer that resultPtr points to will always be NULL
terminated.  However, this buffer may contain NULL (0x00) bytes, therefore, it
is not safe to determine the length of the buffer via strlen().  Instead, you
should use the length provided by <TT>resultLength</TT> below.
<P><TT>resultLength</TT> points to an unsigned int which, on return from
STAFSubmit, will contain the length of the result buffer.
<A NAME="IDX147"></A>
<P><H4><A NAME="Header_117">Examples</A></H4>
<PRE>
/* myHandle was previously set by STAFRegister */
 
char *someMachine = "testmach1";
char *service = "PING";
char *request = "PING";
unsigned int requestLength = strlen(request);
char *result = 0;
unsigned int resultLength = 0;
STAFRC_t rc = 0;
 
rc = STAFSubmit(myHandle, someMachine, service, request, requestLength,
                &result, &resultLength);
</PRE>
<A NAME="IDX148"></A>
<P><H3><A NAME="HDRAPISS2">6.2.5 STAFSubmit2</A></H3>
<P><H4><A NAME="Header_119">Description</A></H4>
<P>The STAFSubmit2 API is identical to the STAFSubmit API except that
it has an additional parameter, syncOption, which allows submission of
asynchronous requests.
<P><H4><A NAME="Header_120">Syntax</A></H4>
<PRE>
STAFRC_t STAFSubmit2(STAFHandle_t handle, STAFSyncOption_t syncOption,
                     char *where, char *service,
                     char *request, unsigned int requestLength,
                     char **resultPtr, unsigned int *resultLength)
</PRE>
<P>syncOption can be any of the following:
<UL COMPACT>
<LI>kSTAFReqSync - This indicates the request should be submitted synchronously.
This is equivalent to calling the STAFSubmit() API.
<LI>kSTAFReqFireAndForget - This indicates the request should be submitted
asynchronously.  The request number will be passed back in the result buffer.
The request's results will not be sent to the submitter's queue nor will they
be retained by the Service service.
<LI>kSTAFReqQueue - This indicates the request should be submitted
asynchronously. The request number will be passed back in the result buffer.
When the request completes, the results will be placed on the submitter's queue.
The format of this message is described below.
<LI>kSTAFReqRetain - This indicates the request should be submitted
asynchronously.  The request number will be passed back in the result buffer.
The submitter can determine the results of the request by using the
<TT>FREE</TT> command of the Service service (see <A HREF="#HDRSRVREQF">8.17.6, "FREE"</A> for
more information).
<LI>kSTAFReqQueueRetain - This indicates the request should be submitted
asynchronously.  The request number will be passed back in the result buffer.
When the request completes, the results will be placed on the submitter's queue.
The format of this message is described below.  The submitter should also free
the results of the request by using the <TT>FREE</TT> command of the Service
service (see <A HREF="#HDRSRVREQF">8.17.6, "FREE"</A> for more information).
</UL>
<P>The format of the queued message obtained when specifying kSTAFReqQueue or
kSTAFReqQueueRetain will be a marshalled <TT>&lt;Map&#58;STAF/RequestComplete&gt;</TT>
which represents the request completion information.  See table
<A HREF="#TBLSTAFREQUESTCOMPLETETABLE">Table 3</A> for the map class definition.
<BR>
<P><B><A NAME="TBLSTAFREQUESTCOMPLETETABLE">Table 3. Definition of map for "STAF/RequestComplete" type message</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="3" WIDTH="100%"><B>Description&#58; </B>This map represents STAF/RequestComplete message information.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">requestNumber
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR></TABLE>
<P>
For example, if you submitted the request "RESOLVE STRING {STAF/Config/OS/Name}"
to the VAR service using kSTAFReqQueue, and received a request number of 42,
then the message you would receive when the request completed might look like
<PRE>
{
  requestNumber: 42
  rc           : 0
  result       : WinNT
}
</PRE>
<P>
The queued message will always be delivered with the default priority of 5.
<A NAME="IDX150"></A>
<P><H3><A NAME="Header_121">6.2.6 STAFSubmitUTF8</A></H3>
<P><H4><A NAME="Header_122">Description</A></H4>
<P>The STAFSubmitUTF8 API is identical in all respects with STAFRegister,
except that <TT>where</TT>, <TT>service</TT>, <TT>request</TT>,
and <TT>*resultPtr</TT> are all strings in UTF-8 format.  This API is
used primarily by the Java interfaces.
<A NAME="IDX152"></A>
<P><H3><A NAME="Header_123">6.2.7 STAFSubmit2UTF8</A></H3>
<P><H4><A NAME="Header_124">Description</A></H4>
<P>The STAFSubmit2UTF8 API is identical in all respects with STAFSubmit2,
except that <TT>where</TT>, <TT>service</TT>, <TT>request</TT>,
and <TT>*resultPtr</TT> are all strings in UTF-8 format.  This API is
used primarily by the Java interfaces.
<A NAME="IDX154"></A>
<P><H3><A NAME="Header_125">6.2.8 STAFFree</A></H3>
<P><H4><A NAME="Header_126">Description</A></H4>
<P>STAFFree is used to free the memory occupied by the result buffer on a call
to STAFSubmit.  You only need to call this if result buffer pointer is not zero
on return from STAFSubmit.
<P><H4><A NAME="Header_127">Syntax</A></H4>
<PRE>
STAFRC_t STAFFree(STAFHandle handle, char *result);
</PRE>
<P><TT>handle</TT> is the handle you received on the call to STAFRegister.
<P><TT>result</TT> is the pointer passed back from the STAFSubmit call.
<A NAME="IDX157"></A>
<P><H4><A NAME="Header_128">Examples</A></H4>
<PRE>
/* myHandle was previously set by STAF     */
/* result was previously set by STAFSubmit */
 
STAFRC_t rc = 0;
 
if (result != 0) rc = STAFFree(myHandle, result);
</PRE>
<A NAME="IDX159"></A>
<P><H3><A NAME="Header_129">6.2.9 Data Structure and Marshalling APIs</A></H3>
<P>STAF externalizes a wide range of APIs for defining data structures and
(un)marshaling data structures.  Here is a list of the APIs.  A later version
of this documentation will provide more details.
<PRE>
typedef enum
{
    kSTAFNoneObject               = 0,
    kSTAFScalarStringObject       = 1,
    kSTAFListObject               = 2,
    kSTAFMapObject                = 3,
    kSTAFMarshallingContextObject = 4
} STAFObjectType_t;
 
typedef enum
{
    kSTAFMarshallingDefaults = 0x00000000
} STAFObjectMarshallingFlags_t;
 
 
typedef enum
{
    kSTAFUnmarshallingDefaults = 0x00000000,
    kSTAFIgnoreIndirectObjects = 0x00000001
} STAFObjectUnmarshallingFlags_t;
 
 
// Object constructors/destructors
//
// Note: When a STAFObject is destructed, it recursively deletes all nested
//       objects
 
STAFRC_t STAFObjectConstructCopy(STAFObject_t *copy, STAFObject_t source);
STAFRC_t STAFObjectConstructReference(STAFObject_t *ref, STAFObject_t source);
STAFRC_t STAFObjectConstructNone(STAFObject_t *pNone);
STAFRC_t STAFObjectConstructScalarString(STAFObject_t *pScalar,
                                         STAFStringConst_t string);
STAFRC_t STAFObjectConstructList(STAFObject_t *list);
STAFRC_t STAFObjectConstructMap(STAFObject_t *map);
STAFRC_t STAFObjectConstructMarshallingContext(STAFObject_t *context);
STAFRC_t STAFObjectDestruct(STAFObject_t *object);
 
// General functions
 
STAFRC_t STAFObjectIsStringMarshalledData(STAFStringConst_t string,
                                          unsigned int *isMarshalledData);
 
// Object functions
 
STAFRC_t STAFObjectGetType(STAFObject_t object, STAFObjectType_t *type);
STAFRC_t STAFObjectGetSize(STAFObject_t object, unsigned int *size);
STAFRC_t STAFObjectIsReference(STAFObject_t object, unsigned int *isRef);
STAFRC_t STAFObjectUnmarshallFromString(STAFObject_t *newContext,
                                        STAFStringConst_t string,
                                        STAFObject_t context,
                                        unsigned int flags);
STAFRC_t STAFObjectMarshallToString(STAFObject_t object, STAFObject_t context,
                                    STAFString_t *string, unsigned int flags);
STAFRC_t STAFObjectGetStringValue(STAFObject_t object, STAFString_t *string);
 
// Scalar functions
 
STAFRC_t STAFObjectScalarGetStringValue(STAFObject_t object,
                                        STAFStringConst_t *string);
STAFRC_t STAFObjectScalarGetUIntValue(STAFObject_t object,
                                      unsigned int *uInt,
                                      unsigned int defaultValue);
 
// List functions
 
STAFRC_t STAFObjectListAppend(STAFObject_t list, STAFObject_t object);
 
// Iterator functions
 
STAFRC_t STAFObjectConstructListIterator(STAFObjectIterator_t *iter,
                                         STAFObject_t list);
STAFRC_t STAFObjectIteratorHasNext(STAFObjectIterator_t iter,
                                   unsigned int *hasNext);
STAFRC_t STAFObjectIteratorGetNext(STAFObjectIterator_t iter,
                                   STAFObject_t *object);
STAFRC_t STAFObjectIteratorDestruct(STAFObjectIterator_t *iter);
 
// Map functions
 
STAFRC_t STAFObjectMapGet(STAFObject_t map, STAFStringConst_t key,
                          STAFObject_t *object);
STAFRC_t STAFObjectMapPut(STAFObject_t map, STAFStringConst_t key,
                          STAFObject_t object);
STAFRC_t STAFObjectMapHasKey(STAFObject_t map, STAFStringConst_t key,
                             unsigned int *hasKey);
STAFRC_t STAFObjectConstructMapKeyIterator(STAFObjectIterator_t *pIter,
                                           STAFObject_t map);
STAFRC_t STAFObjectConstructMapValueIterator(STAFObjectIterator_t *pIter,
                                             STAFObject_t map);
 
// Marshalling Context functions
 
STAFRC_t STAFObjectMarshallingContextSetMapClassDefinition(
    STAFObject_t context,
    STAFStringConst_t name,
    STAFObject_t mapClassDefinition);
 
STAFRC_t STAFObjectMarshallingContextGetMapClassDefinition(
    STAFObject_t context,
    STAFStringConst_t name,
    STAFObject_t *mapClassDefinition);
 
STAFRC_t STAFObjectMarshallingContextHasMapClassDefinition(
    STAFObject_t context,
    STAFStringConst_t name,
    unsigned int *pHasMapClassDefinition);
 
STAFRC_t STAFObjectMarshallingContextSetRootObject(STAFObject_t context,
                                                   STAFObject_t object);
STAFRC_t STAFObjectMarshallingContextGetRootObject(STAFObject_t context,
                                                   STAFObject_t *object);
STAFRC_t STAFObjectMarshallingContextAdoptRootObject(STAFObject_t context,
                                                     STAFObject_t *object);
STAFRC_t STAFObjectMarshallingContextGetPrimaryObject(STAFObject_t context,
                                                      STAFObject_t *object);
STAFRC_t STAFObjectConstructMapClassDefinitionIterator(
    STAFObjectIterator_t *pIter, STAFObject_t context);
</PRE>
<P>
<A NAME="IDX161"></A>
<P><H3><A NAME="Header_130">6.2.10 Private Data Manipulation APIs</A></H3>
<P>STAF externalizes some APIs for handling private data in STAF command
request options.  Here are the definitions for these APIs.
<PRE>
// This method adds privacy delimiters to the data.
// For example, if data passed in is "secret", sets result
// to "!!@secret@!!".
 
STAFRC_t STAFAddPrivacyDelimiters(STAFStringConst_t data,
                                  STAFString_t *result);
 
// This method removes the specified number of levels of privacy
// delimiters from the data.  Set numLevels to 0 to remove all
// levels of privacy delimiters.
// For example, if data passed in is "!!@secret@!!", sets
// result to "secret".
                                  
STAFRC_t STAFRemovePrivacyDelimiters(STAFStringConst_t data,
                                     unsigned int numLevels,
                                     STAFString_t *result);
 
// This method masks any private data indicated by the privacy
// delimiters by replacing the private data with asterisks.
// For example, if data passed in is "!!@secret@!!", sets
// result to "************".
                                     
STAFRC_t STAFMaskPrivateData(STAFStringConst_t data, STAFString_t *result);
 
// This method escapes any privacy delimiters found in the data.
// For example, if data passed in is "!!@secret@!!", sets
// result to "^!!@secret^@!!".
 
STAFRC_t STAFEscapePrivacyDelimiters(STAFStringConst_t data,
                                     STAFString_t *result);
</PRE>
<A NAME="IDX163"></A>
<P><H3><A NAME="Header_131">6.2.11 Other Utility APIs</A></H3>
<P>STAF externalizes some other general utility APIs.
Here are the definitions for these APIs.
<PRE>
/*********************************************************************/
/* STAFUtilFormatString - Generates a string based on a format       */
/*                        string, ala printf().  This is generally   */
/*                        used to format STAF request strings.       */
/*                                                                   */
/* Accepts: (In)  The format string                                  */
/*          (Out) A pointer to the output string                     */
/*          (In)  All data indicated in the format string            */
/*                                                                   */
/* Returns:  Standard return codes                                   */
/*                                                                   */
/* Notes  :  1) The caller is responsible for destructing the        */
/*              output string                                        */
/*********************************************************************/
/* Valid format string specifiers:                                   */
/*                                                                   */
/* %d - an unsigned integer                                          */
/* %s - a STAFString_t                                               */
/* %C - a STAFString_t which will be formatted in colon-length-colon */
/*      delimited format                                             */
/* %% - a percent sign                                               */
/*                                                                   */
/* Any other %&lt;char&gt; is simply ignored (and not copied)              */
/*********************************************************************/
unsigned int STAFUtilFormatString(STAFStringConst_t formatString,
                                  STAFString_t *outputString, ...);
 
 
/*********************************************************************/
/* STAFUtilFormatString2 - Generates a string based on a format      */
/*                         string, ala printf().  This is generally  */
/*                         used to format STAF request strings.      */
/*                                                                   */
/* Accepts: (In)  The format string                                  */
/*          (Out) A pointer to the output string                     */
/*          (In)  A variable argument list                           */
/*                                                                   */
/* Returns:  Standard return codes                                   */
/*                                                                   */
/* Notes  :  1) The caller is responsible for destructing the        */
/*              output string                                        */
/*           2) Valid format strings are the same as defined for     */
/*              STAFUtilFormatString()                               */
/*********************************************************************/
unsigned int STAFUtilFormatString2(STAFStringConst_t formatString,
                                   STAFString_t *outputString, va_list args);
 
 
/*********************************************************************/
/* STAFUtilStripPortFromEndpoint - Removes @&lt;Port&gt; from the end of   */
/*     an endpoint if present.                                       */
/*                                                                   */
/* Accepts: (In/Out)  A pointer to a string containing the endpoint  */
/*                    with format:                                   */
/*                      [&lt;Interface&gt;://&lt;Machine Identifier&gt;[@&lt;Port&gt;] */
/*          (Out)     A pointer to a string containing the stripped  */
/*                    endpoint with format:                          */
/*                      [&lt;Interface&gt;://&lt;Machine Identifier&gt;          */
/*                                                                   */
/* Returns:  0                                                       */
/* Notes  :  1) The caller is responsible for destructing the output */
/*              string containing the stripped endpoint              */
/*********************************************************************/
STAFRC_t STAFUtilStripPortFromEndpoint(STAFStringConst_t endpoint,
                                       STAFString_t *strippedEndpoint);
 
                                       
/*********************************************************************/
/* STAFUtilConvertDurationString - Converts the time duration        */
/*   expressed as a string to a numeric value in milliseconds.       */
/*                                                                   */
/* Accepts: (In)  The duration string                                */
/*                The duration string may be expressed in            */
/*                milliseconds, seconds, minutes, hours, days, or    */
/*                weeks.  Its format is:                             */
/*                  &lt;Number&gt;[&lt;Type&gt;]                                 */
/*                where &lt;Number&gt; is an integer &gt;= 0 and &lt;Type&gt;, if   */
/*                specified, is one of the following:                */
/*                s (for seconds), m (for minutes), h (for hours),   */
/*                d (for days), or w (for weeks). For example:       */
/*                - 100 specifies 100 milliseconds,                  */
/*                - 10s specifies 10 seconds,                        */
/*                - 5m specifies 5 minutes,                          */
/*                - 2h specifies 2 hours,                            */
/*                - 1d specifies 1 day,                              */
/*                - 1w specifies 1 week                              */
/*          (Out) The numeric duration value in milliseconds         */
/*          (Out) A pointer to an error string                       */
/*                                                                   */
/* Returns:  0,  if successful                                       */
/*           47  if unsuccessful (*errorBuffer will be set)          */
/*********************************************************************/
STAFRC_t STAFUtilConvertDurationString(STAFStringConst_t durationString,
                                       unsigned int *duration,
                                       STAFString_t *errorBuffer);
</PRE>
<A NAME="IDX165"></A>
<P><H3><A NAME="Header_132">6.2.12 Other APIs</A></H3>
<P>STAF externalizes other APIs that fall into the following general classes
<UL COMPACT>
<LI>STAFString* - Handles UTF-8 strings (#include "STAFString.h")
<LI>STAFMutexSem* - Handles mutex semaphores (#include "STAFMutexSem.h")
<LI>STAFEventSem* - Handles event semaphores (#include "STAFEventSem.h")
<LI>STAFThread* - Handles threading support (#include "STAFThread.h" and
#include "STAFTimestamp.h")
<LI>STAFDynamicLibrary* - Handles shared library / DLL support
(#include "STAFDynamicLibrary.h")
</UL>
<P>Please see the indicated header files for more information on syntax and
use of these families of APIs.
<HR><H2><A NAME="HDRC++API" HREF="#ToC_133">6.3 C++</A></H2>
<P>STAF externalizes five primary classes to C++ programs.  These class are
<UL COMPACT>
<LI>STAFHandle - Handles (un)registering with STAF as well as submitting
service requests (#include "STAF.h")
<LI>STAFResult - Contains the result of a STAFHandle-&gt;submit() call and some
utility functions (#include "STAF.h")
<LI>STAFObject - A generic class representing a variety of object types,
including None, Strings, Lists, Maps, and Marshalling Contexts
<LI>STAFObjectIterator - Handles iterating over various data structures
<LI>STAFMapClassDefinition - Defines the metadata for a map class
</UL>
<P>Additionally, these classes use several other classes which are
<UL COMPACT>
<LI>STAFString - Encapsulates UTF-8 strings (#include "STAFString.h)
<LI>STAFRerPtr template - A smart-pointer class which handles memory management
(#include "STAFRefPtr.h")
<LI>STAFException - The base of the STAF exception hierarchy
(#include "STAFException.h")
</UL>
<P>STAF also provides some other miscellaneous C++ classes, which are
<UL COMPACT>
<LI>STAFMutexSem and STAFMutexSemLock - Handles mutex semaphores
(#include "STAFMutexSem.h")
<LI>STAFEventSem - Handles event semaphores (#include "STAFEventSem.h")
<LI>STAFTimestamp - Handles times and timestamps (#include "STAFTimestamp.h")
<LI>STAFDynamicLibrary - Handles shared library / DLL support
(#include "STAFDynamicLibrary.h")
</UL>
<P>In addition, C++ applications are able to take advantage of the C-only
APIs, such as Thread support.
<A NAME="IDX167"></A>
<A NAME="IDX169"></A>
<A NAME="IDX170"></A>
<P><H3><A NAME="Header_134">6.3.1 STAFHandle and STAFResult</A></H3>
<P>The STAFHandle class is used to register with, and submit service requests
to, STAF.  In C++ STAFHandles are reference counted, so they are automatically
freed for you.  To obtain a STAFHandle, you call one of the create() methods.
The first is the standard call you will use, and it allows you to specify the
name by which your program should be known.  The second create method allows
you to create a STAFHandle object from an existing STAFHandle_t which would
have been obtained from the C API STAFRegister().  By default, a STAFHandle
obtained through the first method will automatically be unregistered when the
STAFHandle is destructed.  A STAFHandle created via the second method will
not automatically be unregistered when the STAFHandle is destructed.  In either
case, you can change this behavior with the setDoUnreg() method.
<P>Once you have a valid STAFHandlePtr, you can begin submitting requests
to STAF.  To do this, you use the submit() method, to which you specify the
machine and service which should handle the request, as well as the request
string itself.  An optional fourth parameter defines whether this will be
a synchronous or asynchronous request (if the parameter is not specified,
the request will be synchronous).  See the documentation for the C API
STAFSubmit2 for the values allowed for this parameter.
In return you get a reference counted pointer to a STAFResult
object. Again, the underlying STAFResult object will be automatically freed
when the reference count reaches zero.  The STAFResult object itself contains
a return code 'rc', a result string variable 'result', a result object variable
'resultObj', and a result marshalling context object variable 'resultContext'.
If the STAFHandle's fDoUnmarshallResult flag is set to true (which it will be
by default when a STAFHandle is created), then auto-unmarshalling will be
performed which means the 'resultContext' variable will be set to the
marshalling context obtaining from unmarshalling the string result data, and 
the 'resultObj' variable will contain the root object of this marshalling
context.  This allows you to not have to call the unmarshall() method to
unmarshall the result immediately after call a submit() method.
Note that if the STAFHandle's fDoUnmarshallResult flag is set to a false
(which can be done using the setDoUnmarshallResult() method), the
'resultContext' and 'resultObj' variables will be set to the None object.
<P>You may examine the underlying STAFHandle_t via getHandle().  You may take
ownership of the underlying STAFHandle_t via adoptImpl().  In this latter case,
you are now responsible for the STAFHandle_t and are required to call
STAFUnRegister().  Additionally, after a call to adoptImpl(), the existing
STAFHandle object is invalidated and may not be used to call the submit() method.
<P>The utility function wrapData returns the colon-length-colon delimited
version of the specified string.  This is useful for specifying the values in
STAF request string.  See <A HREF="#HDROVFORM">7.2, "Option Value Formats"</A> for more information.
<P>The utility function stripPortFromEndpoint returns an endpoint with
the @port removed from the end of the endpoint, if present.
<P>Several utility functions are provided to handle private data that can
be specified in values in a STAF request string.
These functions are addPrivacyDelimiters, escapePrivacyDelimiters,
removePrivacyDelimiters, and maskPrivateData.
See <A HREF="#HDRPRIVATEDATA">7.3, "Private Data"</A> for more information about handling private data.
<P>
<P><H4><A NAME="Header_135">Definition</A></H4>
<PRE>
// STAFResult - This class contains the results of a STAFSubmit call
 
class STAFResult
{
public:
 
    STAFResult(STAFRC_t theRC = kSTAFOk,
               const STAFString &theResult = STAFString())
        : rc(theRC), result(theResult)
    { /* Do Nothing */ }
 
    STAFResult(STAFRC_t theRC, const char *data, unsigned int dataLen,
               STAFString&#58;&#58;CodePageType codePageType)
        : rc(theRC), result(data, dataLen, codePageType)
    { /* Do Nothing */ }
 
    STAFResult(STAFRC_t theRC, const char *data, unsigned int dataLen,
               STAFString&#58;&#58;CodePageType codePageType, bool doUnmarshallResult)
        : rc(theRC), result(data, dataLen, codePageType)
    {
        if (doUnmarshallResult)
        {
            resultContext = STAFObject&#58;&#58;unmarshall(
                result, kSTAFUnmarshallingDefaults);
            resultObj = resultContext-&gt;getRootObject();
        }
        else
        {
            resultContext = STAFObject&#58;&#58;createNone();
            resultObj = STAFObject&#58;&#58;createNone();
        }
    }
 
    STAFRC_t rc;
    STAFString result;
    STAFObjectPtr resultObj;
    STAFObjectPtr resultContext;
};
 
 
class STAFHandle;
typedef STAFRefPtr&lt;STAFResult&gt; STAFResultPtr;
typedef STAFRefPtr&lt;STAFHandle&gt; STAFHandlePtr;
 
 
// STAFHandle - This class is used to interact with STAF.  You obtain a
//              STAFHandle via the create() call.
 
class STAFHandle
{
    // This is the standard call to create a STAFHandle.  By default, this
    // STAFHandle object will unregister with STAF when destructed.
    static STAFRC_t create(const STAFString &name, STAFHandlePtr &handle);
 
    // This call is used to create a STAFHandle which uses an existing
    // STAFHandle_t.  By default, this STAFHandle object will not unregister
    // with STAF when destructed.
    static STAFRC_t create(STAFHandle_t handleT, STAFHandlePtr &handle,
                           bool doUnreg = false);
 
    STAFResultPtr submit(const STAFString &where, const STAFString &service,
                         const STAFString &request,
                         const STAFSyncOption_t synchOption = kSTAFReqSync);
 
    // This returns the colon-length-colon delimited version of a string
    static STAFString wrapData(const STAFString &data);
 
    // This will format a string for you.  See STAFUtilFormatString() in
    // STAFUtil.h
    //
    // Note: DO NOT try to pass STAFString's into the ... portion of this
    //       function.  The only supported data types are "unsigned int" and
    //       STAFString_t.  Therefore be sure to call getImpl() on all
    //       STAFString's before passing them to this method.
 
    static STAFString formatString(STAFStringConst_t formatString, ...);
 
    // This returns the endpoint without the port (strips @nnnn from the end
    // of the endpoint, if present)
    static STAFString stripPortFromEndpoint(const STAFString &endpoint);
 
    // This method returns the data with privacy delimiters added.
    // For example, if pass in "secret", it returns "!!@secret@!!".
    static STAFString addPrivacyDelimiters(const STAFString &data);
 
    // This method removes any privacy delimiters from the data.
    // For example, if pass in "!!@secret@!!", it returns "secret".
    static STAFString removePrivacyDelimiters(const STAFString &data,
                                              unsigned int numLevels = 0);
 
    // This method masks any private data indicated by the privacy delimiters
    // by replacing the private data with asterisks.
    // For example, if pass in "!!@secret@!!", it returns "************".
    static STAFString maskPrivateData(const STAFString &data);
    
    // This method returns the data with privacy delimiters escaped.
    // For example, if pass in "!!@secret@!!", it returns "^!!@secret^@!!".
    static STAFString escapePrivacyDelimiters(const STAFString &data);
 
    STAFHandle_t getHandle() { return fHandle; }
 
    // This call allows you to claim ownership of the underlying STAFHandle_t.
    // Once this call is made, this STAFHandle object is no longer valid, and
    // it is your responsibility to unregister the STAFHandle_t with STAF.
    STAFHandle_t adoptHandle();
 
    bool getDoUnreg() { return fDoUnreg; }
    void setDoUnreg(bool doUnreg) { fDoUnreg = doUnreg; }
 
    bool getDoUnmarshallResult() { return fDoUnmarshallResult; }
 
    void setDoUnmarshallResult(bool flag)
    {
        fDoUnmarshallResult = flag;
    }
 
    ~STAFHandle();
 
protected:
 
    STAFHandle(STAFHandle_t handle, bool doUnreg)
        : fDoUnreg(doUnreg), fHandle(handle)
    {
        fDoUnmarshallResult = true;
    }
 
    bool fDoUnreg;
    STAFHandle_t fHandle;
    bool fDoUnmarshallResult;
 
};
</PRE>
<A NAME="IDX173"></A>
<P><H4><A NAME="Header_136">Examples</A></H4>
<PRE>
#include "STAF.h"
#include "STAF_iostream.h"
 
int main(void)
{
    STAFHandlePtr handle;
    unsigned int rc  = STAFHandle&#58;&#58;create("MyApplication", handle);
 
    if (rc != 0)
    {
        cout &lt;&lt; "Error registering with STAF, RC: " &lt;&lt; rc &lt;&lt; endl;
        return 1;
    }
 
    STAFResultPtr result = handle-&gt;submit("LOCAL", "PING", "PING");
 
    cout &lt;&lt; "PING RC: " &lt;&lt; result-&gt;rc &lt;&lt; ", Result: " &lt;&lt; result-&gt;result &lt;&lt; endl;
 
    STAFString semName("Sem name with spaces");
 
    result = handle-&gt;submit("LOCAL", "SEM", "POST EVENT " +
                            STAFHandle&#58;&#58;wrapData(semName));
 
    cout &lt;&lt; "Sem Post RC: " &lt;&lt; result-&gt;rc &lt;&lt; ", Result: " &lt;&lt; result-&gt;result
         &lt;&lt; endl;
 
    // Send an Asynchronous request
    result = handle-&gt;submit("LOCAL", "SERVICE", "LIST", kSTAFReqQueueRetain);
 
    cout &lt;&lt; "Service List Request Number: " &lt;&lt; result-&gt;result &lt;&lt; endl;
 
    return 0;
}
</PRE>
<A NAME="IDX175"></A>
<A NAME="IDX177"></A>
<P><H3><A NAME="Header_137">6.3.2 STAFObject</A></H3>
<P>The STAFObject class is used to represent a variety of structured data types.
Unlike newer languages, C++ doesn't have a reflective type system allowing us to
marshall arbitrary data structures.  Therefore, we introduced a class which
would allow us to provide general data structures which could be reflectively
marshalled.  Note, that all data structure methods are provided in the one
STAFObject class.
<P>All data types are created via static methods.  Note the createReference()
method.  This allows you to create a reference to another object.  This is
important to note, as when you add an object to another object (for example,
adding a string to a list) the recipient takes ownership of the object.  Thus,
if you want to keep ownership of the object, you will need to add a reference of
the object to the other object, instead of the object itself.
<P>Note, when a STAFObject is destructed, all objects it contains are
destructed (recursively) as well.  At this point, any references to objects
that were contained in that data structure are now "dangling".  The only
valid methods for a "dangling" reference are isRef(), type(), and destruction.
<PRE>
typedef enum
{
    kSTAFNoneObject               = 0,
    kSTAFScalarStringObject       = 1,
    kSTAFListObject               = 2,
    kSTAFMapObject                = 3,
    kSTAFMarshallingContextObject = 4
} STAFObjectType_t;
 
typedef enum
{
    kSTAFMarshallingDefaults = 0x00000000
} STAFObjectMarshallingFlags_t;
 
 
typedef enum
{
    kSTAFUnmarshallingDefaults = 0x00000000,
    kSTAFIgnoreIndirectObjects = 0x00000001
} STAFObjectUnmarshallingFlags_t;
 
 
typedef STAFRefPtr&lt;STAFObject&gt; STAFObjectPtr;
 
class STAFObject
{
public:
    // Creation methods
 
    static STAFObjectPtr createReference(const STAFObject &source);
    static STAFObjectPtr createReference(const STAFObjectPtr &source);
    static STAFObjectPtr createReference(STAFObject_t source);
    static STAFObjectPtr createNone();
    static STAFObjectPtr createScalar(const STAFString &aString);
    static STAFObjectPtr createList();
    static STAFObjectPtr createMap();
    static STAFObjectPtr createMarshallingContext();
 
    // General methods
 
    static bool isMarshalledData(const STAFString &aString);
 
    // General object methods
 
    STAFObjectType_t type();
    unsigned int size();
 
    bool isRef();
    STAFObjectPtr reference();
 
    STAFString asString();
 
    STAFString marshall(unsigned int flags = kSTAFMarshallingDefaults);
    void marshall(STAFString &output,
                  unsigned int flags = kSTAFMarshallingDefaults);
 
    // Note: This method always returns a Marshalling Context
    static STAFObjectPtr unmarshall(const STAFString &input,
                                    unsigned int flags =
                                    kSTAFUnmarshallingDefaults);
 
    // List methods
 
    void append(const STAFObjectPtr &objPtr);
    void append(const STAFString &aString);
 
    STAFObjectIteratorPtr iterate();
 
    // Map methods
 
    bool hasKey(const STAFString &key);
 
    STAFObjectPtr get(const STAFString &key);
 
    void put(const STAFString &key, const STAFObjectPtr &objPtr);
    void put(const STAFString &key, const STAFString &aString);
 
    STAFObjectIteratorPtr keyIterator();
    STAFObjectIteratorPtr valueIterator();
 
    // Marshalling Context methods
 
    void setMapClassDefinition(const STAFMapClassDefinitionPtr &defPtr);
 
    STAFMapClassDefinitionPtr getMapClassDefinition(const STAFString &name);
 
    bool hasMapClassDefinition(const STAFString &name);
 
    STAFObjectIteratorPtr mapClassDefinitionIterator();
 
    void setRootObject(const STAFObjectPtr &objPtr);
    STAFObjectPtr getRootObject();
 
    // Destructor
 
    ~STAFObject();
};
</PRE>
<P>
<A NAME="IDX180"></A>
<P><H4><A NAME="Header_138">Examples</A></H4>
<P>
<P>This example submits a request to the PROCESS service to start a
command and wait for it to complete.  The result from this request
is a marshalled map containing the process completion information.
So this example demonstrates how to get the process return code from the
result object (the root object of the marshalling context for the result).
<PRE>
#include "STAF.h"
#include "STAF_iostream.h"
 
int main(void)
{
    STAFHandlePtr handlePtr;
 
    unsigned int rc = STAFHandle&#58;&#58;create("STAF/TestProcess", handlePtr);
 
    if (rc != 0)
    {
        cout &lt;&lt; "Error registering with STAF, RC: " &lt;&lt; rc &lt;&lt; endl;
        return rc;
    }
 
    // Submit a request to start a process on a machine and wait for
    // it to complete.  For this example, simply starting the process
    // on the local machine and listing and contents of C:/temp.
 
    STAFString machine = STAFString("local");
    STAFString command = STAFString("dir C:/temp");
 
    STAFResultPtr res = handlePtr-&gt;submit(
        machine, "PROCESS", "START COMMAND " +
        STAFHandle&#58;&#58;wrapData(command) + " RETURNSTDOUT RETURNSTDERR WAIT");
 
    if (res-&gt;rc != kSTAFOk)
    {
        cout &lt;&lt; "PROCESS START request failed with RC=" &lt;&lt; STAFString(res-&gt;rc)
             &lt;&lt; " Result=" &lt;&lt; res-&gt;result &lt;&lt; endl;
        return res-&gt;rc;
    }
 
    // The result buffer from a successful PROCESS START WAIT request
    // returns a marshalled map containing the process completion information.
    // The marshalling context (e.g. the unmarshalled result) is available in
    // the 'resultContext' variable of the STAFResultPtr and the root object
    // for the marshalling context (which, in this case, is a map) is available
    // in the 'resultObj' variable of the STAFResultPtr.  That is,
    //   res-&gt;resultContext = STAFObject&#58;&#58;unmarshall(res-&gt;result);
    //   res-&gt;resultObj = res-&gt;resultContext-&gt;getRootObject();
    // assuming auto-unmarshalling has not been disabled for the handle.
    
    // Print the result from the PROCESS START WAIT request in a
    // "Pretty Print" format using the asFormattedString() method
    
    cout &lt;&lt; "Process Result (Pretty Printed): " &lt;&lt; endl
         &lt;&lt; res-&gt;resultContext-&gt;asFormattedString() &lt;&lt; endl &lt;&lt; endl;
 
    // Check if the process RC is 0 by getting the "rc" key from the
    // process completion map
 
    if (res-&gt;resultObj-&gt;get("rc")-&gt;asString() == "0")
        cout &lt;&lt; "Process completed successfully" &lt;&lt; endl;
    else
        cout &lt;&lt; "Process failed with RC="
             &lt;&lt; res-&gt;resultObj-&gt;get("rc")-&gt;asString() &lt;&lt; endl;
 
    return 0;
}
</PRE>
<P>
<A NAME="IDX182"></A>
<P><H3><A NAME="Header_139">6.3.3 STAFObjectIterator</A></H3>
<P>The STAFObjectIterator class represents an iterator over other objects.
You can not directly create a STAFObjectIterator.  You obtain a
STAFObjectIterator via calling an iteration method on a STAFObject.  You can
iterate over the items in a list, the keys in a map, the values in a map, and
the names of the map class definitions in a marshalling context.
<P><H4><A NAME="Header_140">Definition</A></H4>
<PRE>
typedef STAFRefPtr&lt;STAFObjectIterator&gt; STAFObjectIteratorPtr;
 
class STAFObjectIterator
{
public:
    bool hasNext();
    STAFObjectPtr next();
 
    ~STAFObjectIterator();
};
</PRE>
<P>
<A NAME="IDX185"></A>
<P><H4><A NAME="Header_141">Examples</A></H4>
<P>
<P>This example submits a request to the FS service to list the
contents of a directory (in the long, detailed format).  The
result from this request is a marshalled list of maps, so this
example demonstrates how to get list object from the result object
and how to iterate through this list using the STAFObjectIterator
class.
<PRE>
#include "STAF.h"
#include "STAF_iostream.h"
 
int main(void)
{
    STAFHandlePtr handlePtr;
 
    unsigned int rc = STAFHandle&#58;&#58;create("STAF/TestProcess", handlePtr);
 
    if (rc != 0)
    {
        cout &lt;&lt; "Error registering with STAF, RC: " &lt;&lt; rc &lt;&lt; endl;
        return rc;
    }
    // Submit a request to the FS service to list the contents of a
    // directory in the long format with detailed information about
    // the entries in the directory
    
    STAFString directory = "C:/temp/staf";
 
    STAFResultPtr res = handlePtr-&gt;submit(
        machine, "FS", "LIST DIRECTORY " +
        STAFHandle&#58;&#58;wrapData(directory) + " LONG DETAILS");
 
    if (res-&gt;rc != kSTAFOk)
    {
        cout &lt;&lt; "FS LIST DIRECTORY " &lt;&lt; directory &lt;&lt; " LONG DETAILS request"
             &lt;&lt; " failed with RC=" &lt;&lt; STAFString(res-&gt;rc)
             &lt;&lt; " Result=" &lt;&lt; res-&gt;result &lt;&lt; endl;
        return res-&gt;rc;
    }
 
    // The result buffer from a successful LIST DIRECTORY LONG DETAILS
    // request returns a marshalled list of maps containing information
    // about the entries in the directory.
    // The marshalling context (e.g. the unmarshalled result) is available in
    // the 'resultContext' variable of the STAFResultPtr and the root object
    // for the marshalling context (which, in this case, is a map) is available
    // in the 'resultObj' variable of the STAFResultPtr.  That is,
    //   res-&gt;resultContext = STAFObject&#58;&#58;unmarshall(res-&gt;result);
    //   res-&gt;resultObj = res-&gt;resultContext-&gt;getRootObject();
    // assuming auto-unmarshalling has not been disabled for the handle.
    
    // Print the result in a "Pretty Print" format using the 
    // asFormattedString() method
    
    cout &lt;&lt; endl &lt;&lt; "LIST DIRECTORY Result (Pretty Printed): " &lt;&lt; endl
         &lt;&lt; res-&gt;resultContext-&gt;asFormattedString() &lt;&lt; endl &lt;&lt; endl;
 
    // Iterate through the result object (which is a List containing a Map
    // for each entry in the directory).
    // Check if the directory contains a file named test.txt that
    // was last modified after 20060306-00:00:00.
    
    STAFObjectIteratorPtr iter = res-&gt;resultObj-&gt;iterate();
 
    while (iter-&gt;hasNext())
    {
        STAFObjectPtr entryMap = iter-&gt;next();
 
        if (entryMap-&gt;get("name")-&gt;asString() == "test.txt")
        {
            if (entryMap-&gt;get("lastModifiedTimestamp")-&gt;asString() &gt;
                "20060306-00:00:00")
            {
                cout &lt;&lt; "Entry test.txt was modified at "
                     &lt;&lt; entryMap-&gt;get("lastModifiedTimestamp")-&gt;asString()
                     &lt;&lt; endl;
            }
        }
    }
 
    return 0;
}
</PRE>
<P>
<A NAME="IDX187"></A>
<A NAME="IDX189"></A>
<P><H3><A NAME="Header_142">6.3.4 STAFMapClassDefinition</A></H3>
<P>The STAFMapClassDefinition class is used to represent the metadata
associated with a map class.  Note, the order with which keys are added
determines their display order.
<P><H4><A NAME="Header_143">Definition</A></H4>
<PRE>
typedef STAFRefPtr&lt;STAFMapClassDefinition&gt; STAFMapClassDefinitionPtr;
 
class STAFMapClassDefinition
{
public:
    static STAFMapClassDefinitionPtr create(const STAFString &name);
    static STAFMapClassDefinitionPtr createReference(
        STAFMapClassDefinitionPtr source);
 
    STAFObjectPtr createInstance();
 
    STAFMapClassDefinitionPtr reference();
 
    void addKey(const STAFString &keyName);
    void addKey(const STAFString &keyName, const STAFString &displayName);
 
    void setKeyProperty(const STAFString &keyName, const STAFString &propName,
                        const STAFString &propValue);
 
    STAFObjectIteratorPtr keyIterator();
 
    STAFString name() const;
 
    STAFObjectPtr getMapClassDefinitionObject();
};
</PRE>
<HR><H2><A NAME="HDRREXXAPI" HREF="#ToC_144">6.4 Rexx</A></H2>
<P>STAF externalizes three APIs to Rexx programs.  These APIs allow you to
register/unregister with STAF and submit service requests.  These APIs are
located in the RXStaf DLL.  A Rexx program wishing to use these APIs must
be sure to load them from the DLL, with the following two lines of code.
<PRE>
call RxFuncAdd "STAFLoadFuncs", "RXSTAF", "STAFLoadFuncs"
call STAFLoadFuncs
</PRE>
<P>STAF also provides wrapper interfaces around the LOG, MONITOR, and RESPOOL
services, as well as a small set of utility functions.  These wrapper
interfaces and utility functions are provided in Rexx Library files which
have the extension .rxl.  In order to incorporate these wrappers into your
Rexx programs, you may do one of the following:
<UL COMPACT>
<LI>Cut and paste the wrapper functions into your programs
<LI>Import them into you Rexx programs using the Rexx Pre-Processor (RxPP).
</UL>
<P>The names of these libraries are as follows:
<UL COMPACT>
<LI>STAFMon.rxl - Wrapper interface around the MONITOR service
<LI>STAFLog.rxl - Wrapper interfaces around the LOG service
<LI>STAFPool.rxl - Wrapper interfaces around the RESPOOL service
<LI>STAFUtil.rxl - Utility functions
</UL>
<A NAME="IDX191"></A>
<A NAME="IDX193"></A>
<P><H3><A NAME="Header_145">6.4.1 STAFRegister</A></H3>
<P><H4><A NAME="Header_146">Description</A></H4>
<P>The STAFRegister call is used by a Rexx program to register with STAF.
<P><H4><A NAME="Header_147">Syntax</A></H4>
<PRE>
call STAFRegister handleName&#91;, handleVarName&#93;
</PRE>
<P><TT>handleName</TT> is the name by which you want this handle to be
known.
<P><TT>handleVarName</TT> is the name of the Variable which you want to
contain the handle that you will use on all other subsequent STAF calls.
If this parameter is not specified, the handle will be placed in the variable
STAFHandle.
<A NAME="IDX196"></A>
<P><H4><A NAME="Header_148">Examples</A></H4>
<PRE>
call STAFRegister "MyHandleName", "MyHandle"
say "My handle is:" MyHandle
</PRE>
<P>or
<PRE>
call STAFRegister "MyHandleName"
say "My handle is:" STAFHandle
</PRE>
<A NAME="IDX198"></A>
<P><H3><A NAME="Header_149">6.4.2 STAFUnRegister</A></H3>
<P><H4><A NAME="Header_150">Description</A></H4>
<P>The STAFUnRegister call is used by a Rexx program to unregister with
STAF, which frees up any internal STAF resources used by the handle.
<P><H4><A NAME="Header_151">Syntax</A></H4>
<PRE>
call STAFUnRegister &#91;handle&#93;
</PRE>
<P><TT>handle</TT> is the handle that you received on the call to
STAFRegister.  If this parameter is not specified, the handle will be
retrieved from the STAFHandle variable.
<A NAME="IDX201"></A>
<P><H4><A NAME="Header_152">Examples</A></H4>
<PRE>
call STAFUnRegister MyHandle
</PRE>
<P>or
<PRE>
call STAFUnRegister
</PRE>
<A NAME="IDX203"></A>
<P><H3><A NAME="Header_153">6.4.3 STAFSubmit</A></H3>
<P><H4><A NAME="Header_154">Description</A></H4>
<P>The STAFSubmit call is the primary API that you will use.  It is what
allows you to submit a request to a service.
<P><H4><A NAME="Header_155">Syntax</A></H4>
<PRE>
call STAFSubmit &#91;handle,&#93;  where, service, request &#91;, resultVarName&#93;
</PRE>
<P><TT>handle</TT> is the handle you received on the call to STAFRegister.
If this parameter is not specified, the handle will be retrieved from the
STAFHandle variable.
<P><TT>where</TT> is the destination machine for the service request.  This
should be either LOCAL or the name of a machine.
<P><TT>service</TT> is the name of the service to which you are submitting
the request.
<P><TT>request</TT> is the actual request that you are sending to the service.
<P><TT>resultVarName</TT> is the name of a variable that will contain the
result of the service request. If you specify <TT>resultVarName</TT>, you
must also specify <TT>handle</TT>
<P><B>Note: </B>The Rexx variable "STAFResult" will always be set to the result of the
service request.  However, <TT>resultVarName</TT> allows you to get another
variable set if needed.
<P><B>Note: </B>To define whether a submit request should be synchronous or asynchronous,
the STAFSyncOption variable should be set prior to calling STAFSubmit (if it 
is not set, the submit will be synchronous).  The possible values for 
STAFSyncOption are defined in STAFUtil.
<A NAME="IDX206"></A>
<P><H4><A NAME="Header_156">Examples</A></H4>
<PRE>
/* myHandle was previously set by a call to STAFRegister */
 
someMachine = "testmach1"
service = "PING"
request = "PING"
 
call STAFSubmit myHandle, someMachine, service, request, "SomeVar"
say "STAFSubmit return code     :" RESULT
say "Service request result     :" STAFResult
say "Also service request result:" SomeVar
</PRE>
<P>or
<PRE>
/* STAFHandle was previously set by a call to STAFRegister */
 
someMachine = "testmach1"
service = "PING"
request = "PING"
 
call STAFSubmit someMachine, service, request
say "STAFSubmit return code     :" RESULT
say "Service request result     :" STAFResult
 
call STAFSyncValues
STAFSyncOption = STAFSync.!ReqRetain
call STAFSubmit someMachine, service, request
say "Asynchronous Service request number     :" STAFResult
 
</PRE>
<A NAME="IDX208"></A>
<P><H3><A NAME="Header_157">6.4.4 STAFMon wrapper library</A></H3>
<P><H4><A NAME="Header_158">Description</A></H4>
<P>The STAFMon wrapper library provides a wrapper around the MONITOR service.
The following functions are provided:
<UL COMPACT>
<LI>STAFMonitorErrorText - Initializes STAF Monitor error codes
<LI>STAFMonitor - Logs data to the Monitor service
</UL>
<P><H4><A NAME="Header_159">Syntax</A></H4>
<PRE>
call STAFMonErrorText
call STAFMonitor &lt;Message&gt;[, &lt;Extra request data&gt;]
</PRE>
<P><TT>&lt;Message&gt;</TT> is the message that you wish to log to the MONITOR
service.
<P><TT>&lt;Extra request data&gt;</TT> is any additional information that should
be passed along with the MONITOR service LOG request, such as additional
options like RESOLVEMESSAGE.
<A NAME="IDX211"></A>
<P><H4><A NAME="Header_160">Examples</A></H4>
<PRE>
/* STAFHandle was set by a previous call to STAFRegister */
call STAFMonErrorText
 
do i = 1 to numLoops
    call STAFMonitor "Beginning of loop #"i
      ...
      ...
end
</PRE>
<A NAME="IDX213"></A>
<P><H3><A NAME="Header_161">6.4.5 STAFLog wrapper library</A></H3>
<P><H4><A NAME="Header_162">Description</A></H4>
<P>The STAFLog wrapper library provides a wrapper around the LOG service.
The following functions are provided:
<UL COMPACT>
<LI>STAFLogErrorText - Initializes STAF Logging error codes
<LI>STAFInitLog - Initializes the data structures used for logging to a
particular STAF log
<LI>STAFSetCurrentLog - Sets the current log
<LI>STAFLog - Logs data to the current log
</UL>
<P><H4><A NAME="Header_163">Syntax</A></H4>
<PRE>
call STAFLogErrorText
call STAFInitLog &lt;Reference&gt;, &lt;Log name&gt;[, [Log type], [Monitor mask]]
call STAFSetCurrentLog &lt;Reference&gt;
call STAFLog &lt;Log level&gt;, &lt;Message&gt;[, &lt;Extra request data&gt;]
</PRE>
<P><TT>&lt;Reference&gt;</TT> is a text string of your desire that is used to
refer to a log.  This facilitates switching between several different log
files.
<P><TT>&lt;Log name&gt;</TT> is the name of the log to which you wish to log
messages
<P><TT>[Log type]</TT> is the type of log.  This should be one of GLOBAL,
MACHINE, or HANDLE.  The default is MACHINE.
<P><TT>[Monitor mask]</TT> is a string which specifies which logging levels
should also be sent to the MONITOR service.  The default is "FATAL ERROR
WARNING INFO STATUS"
<P><TT>&lt;Log level&gt;</TT> is the logging level of the message to be logged,
e.g. ERROR or WARNING.
<P><TT>&lt;Message&gt;</TT> is the message that you wish to log to the LOG
service.
<P><TT>&lt;Extra request data&gt;</TT> is any additional information that should
be passed along with the LOG service LOG request, such as additional
options like RESOLVEMESSAGE.
<A NAME="IDX216"></A>
<P><H4><A NAME="Header_164">Examples</A></H4>
<PRE>
/* STAFHandle was set by a previous call to STAFRegister */
call STAFLogErrorText
 
call STAFInitLog "Public", "Testcase1", "MACHINE"
call STAFInitLog "Private", "Testcase1", "HANDLE", "FATAL ERROR WARNING"
 
call STAFSetCurrentLog "Public"
call STAFLog "INFO", "Beginning testcase 1"
 
  ...
 
call STAFSetCurrentLog "Private"
call STAFLog "DEBUG", "Some private debug data"
</PRE>
<A NAME="IDX218"></A>
<P><H3><A NAME="Header_165">6.4.6 STAFPool wrapper library</A></H3>
<P><H4><A NAME="Header_166">Description</A></H4>
<P>The STAFPool wrapper library provides a wrapper around the RESPOOL service.
The following functions are provided:
<UL COMPACT>
<LI>STAFPoolErrorText - Initializes STAF Resource Pool error codes
<LI>STAFPoolRequest - Requests an entry from resource pool
<LI>STAFPoolRelease - Releases a resource pool entry
</UL>
<P><H4><A NAME="Header_167">Syntax</A></H4>
<PRE>
call STAFPoolErrorText
call STAFPoolRequest &lt;Pool name&gt;, &lt;Entry variable name&gt;[, [Entry type], [Timeout]]
call STAFPoolRelease &lt;Pool name&gt;, &lt;Entry&gt;[, &lt;Force&gt;]
</PRE>
<P><TT>&lt;Pool name&gt;</TT> is the name of the pool from which to request or
release an entry.
<P><TT>&lt;Entry variable name&gt;</TT> is the name of the variable in which to
place the actual requested entry's value.
<P><TT>[Entry type]</TT> is the type of entry requested.  This should be
either FIRST or RANDOM.  The default is RANDOM.
<P><TT>[Timeout]</TT> is an amount of time, in milliseconds, after which
the request should timeout.  The default is to wait indefinitely.
<P><TT>&lt;Force&gt;</TT> specifies whether the entry should be forceable released.
This should be either FORCE or NOFORCE.  The default is NOFORCE.
<A NAME="IDX221"></A>
<P><H4><A NAME="Header_168">Examples</A></H4>
<PRE>
/* STAFHandle was set by a previous call to STAFRegister */
call STAFPoolErrorText
 
call STAFPoolRequest "Pool1", "Entry1"
say "The entry obtained was:" Entry1
 
  ...
 
call STAFPoolRelease Entry1
</PRE>
<A NAME="IDX223"></A>
<P><H3><A NAME="Header_169">6.4.7 STAFUtil library</A></H3>
<P><H4><A NAME="Header_170">Description</A></H4>
<P>The STAFUtil library provides some utilitiy functions for use by Rexx
programs.  The following functions are provided:
<UL COMPACT>
<LI>STAFErrorText - Initializes general STAF error codes
<LI>STAFSyncValues - Initializes constants uses to indicate whether
submit requests should be synchronous or asynchronous
<UL COMPACT>
<LI>STAFSync.!ReqSync - This indicates the request should be submitted
synchronously.  This is equivalent to calling STAFSubmit without setting the
STAFSyncOption variable.
<LI>STAFSync.!ReqFireAndForget - This operates identically to the
kSTAFReqFireAndForget value of the C STAFSubmit2 API (see <A HREF="#HDRAPISS2">6.2.5, "STAFSubmit2"</A>
for more information).
<LI>STAFSync.!ReqQueue - This operates identically to the kSTAFReqQueue value of
the C STAFSubmit2 API (see <A HREF="#HDRAPISS2">6.2.5, "STAFSubmit2"</A> for more information).
<LI>STAFSync.!ReqRetain - This operates identically to the kSTAFReqRetain value
of the C STAFSubmit2 API (see <A HREF="#HDRAPISS2">6.2.5, "STAFSubmit2"</A> for more information).
<LI>STAFSync.!ReqQueueRetain - This operates identically to the
kSTAFReqQueueRetain value of the C STAFSubmit2 API (see <A HREF="#HDRAPISS2">6.2.5, "STAFSubmit2"</A>
for more information).
</UL>
<LI>STAFWrapData - Generates the colon-delimited version of a string
<LI>MakeSTAFResult - Creates a STAF Service result string (only used by
service providers)
</UL>
<P><H4><A NAME="Header_171">Syntax</A></H4>
<PRE>
call STAFErrorText
call STAFSyncValues
wrappedData = STAFWrapData(&lt;Data&gt;)
serviceResult = MakeSTAFResult(&lt;Return code&gt;[, &lt;Result string&gt;])
</PRE>
<P><TT>&lt;Data&gt;</TT> is the data for which to generate the colon delimited
version.
<P><TT>&lt;Return code&gt;</TT> is the service request's return code.
<P><TT>&lt;Result string&gt;</TT> is the service request's result string.
<A NAME="IDX226"></A>
<P><H4><A NAME="Header_172">Examples</A></H4>
<PRE>
/* STAFHandle was set by a previous call to STAFRegister */
call STAFErrorText
 
someData = "..."
wrappedData = STAFWrapData(someData)
 
/* The following would only be used by a service provider */
returnCode = 0
resultString = "..."
serviceResult = MakeSTAFResult(returnCode, resultString)
 
/* The following sets the STAFSyncOption variable to one of the STAFSync constants */
STAFSyncOption = STAFSync.!ReqRetain
</PRE>
<HR><H2><A NAME="HDRJAVAAPI" HREF="#ToC_173">6.5 Java</A></H2>
<P>
For information on STAF's V3 support for the Java language, see the
<A HREF="http://staf.sourceforge.net/current/STAFJava.htm">STAF Java User's Guide</A>.
<P>
<HR><H2><A NAME="HDRPERLAPI" HREF="#ToC_174">6.6 Perl</A></H2>
<P>
For information on STAF's V3 support for the Perl language, see the
<A HREF="http://staf.sourceforge.net/current/STAFPerl.htm">STAF Perl User's Guide</A>.
<P>
<HR><H2><A NAME="HDRPYTHONAPI" HREF="#ToC_175">6.7 Python</A></H2>
<P>
For information on STAF's V3 support for the Python language, see the
<A HREF="http://staf.sourceforge.net/current/STAFPython.htm">STAF Python User's Guide</A>.
<P>
<HR><H2><A NAME="HDRTCLAPI" HREF="#ToC_176">6.8 Tcl</A></H2>
<P>
For information on STAF's V3 support for the Tcl language, see the
<A HREF="http://staf.sourceforge.net/current/STAFTcl.htm">STAF Tcl User's Guide</A>.
<P>
<P>
<A NAME="IDX228"></A>
<A NAME="IDX229"></A>
<HR><H1><A NAME="HDRSERVICE" HREF="#ToC_177">7.0 Services overview</A></H1>
<P>Services are what provide all the capabilities of STAF.
<A NAME="IDX230"></A>
<HR><H2><A NAME="HDRSYNTAXSRV" HREF="#ToC_178">7.1 General Service Syntax</A></H2>
<P>When examining the syntax statements for each service, keep the following
rules in mind.
<UL COMPACT>
<LI>Unadorned options are required
<LI>Options or values surrounded by angle brackets, e.g. &lt; and &gt;, are required.
<LI>Options or values surrounded by square brackets, e.g. &#91; and &#93; , are not
required.
<LI>Options in a group are separated by a vertical bar.  Only one of the
options in a group may be specified.
</UL>
<P>For example,
<PRE>
LOG &lt;GLOBAL | MACHINE | HANDLE&gt; MESSAGE &lt;Message&gt;
</PRE>
<P>indicates that option LOG is required and requires no value, option
MESSAGE is required and requires a value, and exactly one of options GLOBAL,
MACHINE, and HANDLE must be specified (and none of these options requires a
value).
<PRE>
START COMMAND &lt;Command&gt; &#91;WORKLOAD &lt;Name&gt;&#93;  &#91;WAIT | ASYNC&#93;
</PRE>
indicates that option START is required and requires no value, option COMMAND
is required and requires a value, option WORKLOAD is not required, but, if
specified, requires a value, and one of the options WAIT and ASYNC may be
specified, and neither requires a value.
<A NAME="IDX231"></A>
<HR><H2><A NAME="HDROVFORM" HREF="#ToC_179">7.2 Option Value Formats</A></H2>
<P>Values for options may be specified in one of three ways.
<OL COMPACT TYPE=1>
<LI>If the value contains no spaces or quotes, you may simply specify the
value.  For example,
<PRE>
MESSAGE Hello
</PRE>
<LI>You may enclose the value in quotes.  When doing so, the backslash
character is the escape character.  Any character after the backslash is
treated as a literal character.  To specify a backslash, use two backslashes.
For example,
<PRE>
MESSAGE "Hello World"
</PRE>
<P>specifies the message <TT>Hello World</TT>
<PRE>
MESSAGE "He said, \"What is that\""
</PRE>
<P>specifies the message <TT>He said, "What is that"</TT>
<PRE>
MESSAGE "c:\\MyApp\\Some directory with spaces"
</PRE>
<P>specifies the message <TT>c:\MyApp\Some directory with spaces</TT>
<P>
<LI>You may use a length delimited format that is of the form
<TT>:&lt;Length&gt;:&lt;String&gt;</TT>.  Note that the length is specified in
characters, not bytes.  For example,
<PRE>
MESSAGE :11&#58;Hello World
</PRE>
<P>specifies the message <TT>Hello World</TT>
<PRE>
MESSAGE :23&#58;He said, "What is that"
</PRE>
<P>specifies the message <TT>He said, "What is that"</TT>
<PRE>
MESSAGE :35&#58;c:\MyApp\Some directory with spaces
</PRE>
<P>specifies the message <TT>c:\MyApp\Some directory with spaces</TT>
</OL>
<P>The first two formats are most appropriate when using the STAF command line.
The third is most appropriate and easiest from within programs using one
of the supplied "wrapData" functions.
<P>
Note that when the value of an option is the same as the name of the option
(or another supported option), the value must be distinguished as 
such either by quoting the value or by using the length delimited format.
For example, if NAME is the name of an option and you also want to specify
NAME as the value of the option, you should specify either NAME "NAME" or
NAME :4&#58;NAME.
<P>
Also, note that when you want to specify an empty string for the value of an
option, you must use the third format (the length delimited format)
because if you specify no value or "", then the STAF command parser thinks
that no value was specified for the option and this will cause an
"Invalid Request String" error (RC 7) if the option requires a value.
For example,
<PRE>
MESSAGE :0:
</PRE>
<A NAME="IDX232"></A>
<HR><H2><A NAME="HDRPRIVATEDATA" HREF="#ToC_180">7.3 Private Data</A></H2>
<P>Some command options allow their values to contain private data which
will be handled by the service.  This will be noted in the command
options that allow it.
<P>
Private data is denoted by surrounding the private data, e.g. a password,
between an opening privacy delimiter (!!@) and a closing privacy delimiter
(@!!).  For example, !!@password@!!.  Because of this special significance
of "!!@" and "@!!", if you do not want them to denote private data, use a
caret (^), as an escape character for "!!@" and "@!!".
Nested private data is allowed.
<P>
Using privacy delimiters indicates that the data enclosed between opening
and closing privacy delimiters should be protected so that if the private 
data is displayed (e.g. in a <TT>LIST</TT> or <TT>QUERY</TT> request),
any private data will be masked (replaced with asterisks).
<P>
<P><H4><A NAME="Header_181">Examples</A></H4>
<P>
The Process service's <TT>START</TT> request handles
private data in the <TT>COMMAND</TT>, <TT>PARMS</TT>, and/or
<TT>PASSWORD</TT> options.  If the command contains
a password (e.g. secret) that you want to keep private, enclose the
password between privacy delimiters as follows:
<PRE>
START SHELL COMMAND "C:/tests/myTest.exe -password !!@secret@!!"
</PRE>
The above command would be displayed as "myTest.exe -password ************"
in a <TT>LIST</TT> or <TT>QUERY</TT> request.
<P>If you want to start command "TestA.exe" as another user (e.g.
userid testuser and password secret), you can indicate that the
password is private as follows:
<PRE>
START COMMAND C:/tests/TestA.exe USER testuser PASSWORD !!@secret@!!
</PRE>
<P>If the password in the above example actually contained !!@ or @!!
(e.g. pass@!!rd), then you need to escape the privacy delimiter.
For example:
<PRE>
START COMMAND C:/tests/TestA.exe USER testuser PASSWORD !!@pass^@!!rd@!!
</PRE>
<P>
You can nest private data.  For example the following string contains
two levels of nested private data:
<PRE>
!!@Top secret info: password=^!!@secret^@!!.@!!
</PRE>
Note that a caret (^) is added to escape any !!@ and @!! characters
that are nested within another set of privacy delimiters.
<P>
When specifying private data for a command option in a program, use the
method provided by STAF to add privacy delimiters.
STAF also provides methods to escape privacy delimiters, to
mask privacy delimiters, and to remove privacy delimiters.  See the
STAF API documentation for more information.
<A NAME="IDX233"></A>
<HR><H2><A NAME="HDRVARRES" HREF="#ToC_182">7.4 Variable Resolution</A></H2>
<P>Most command options allow their values to contain variable references which
will be resolved by the service.  This will be noted in the command options
that allow it.  In addition, the machine and service specified when submitting
a STAF request may contain variable references.
<P>The following potential variable pools are available for use in variable 
resolution in a service request:
<UL COMPACT>
<LI>OSYSTEM - Originator's system variable pool
<LI>RSYSTEM - Remote system variable pool
<LI>OSHARED - Originator's shared variable pool
<LI>RSHARED - Remote shared variable pool
<LI>HANDLE  - Originating handle's variable pool
<LI>PROCUPV - PROCESS USERPROCESSVARS variable pool. This is only involved when
the USEPROCESSVARS option is specified on a PROCESS START request
</UL>
<P>Unless otherwise specified, variable resolution is handled in
one of two ways, based on whether the request is performed locally (i.e., on
the originating system) or on another system.
<UL COMPACT>
<LI>If the request is performed locally, the order of variable resolution will be 
(in order of precedence) &#91;PROCUPV, HANDLE, OSHARED, OSYSTEM&#93;, where 
PROCUPV is only used in a PROCESS START request when the USEPROCESSVARS option is
used.
<LI>If the request is performed on another system, the order of variable resolution
will be (in order of precedence) &#91;PROCUPV, HANDLE, OSHARED, RSHARED, RSYSTEM&#93;,
where PROCUPV is only used in a PROCESS START request when the USEPROCESSVARS option
is used.
</UL>
<P><B>Note: </B>Since, by definition, a delegated service request will not be handled
locally, the variable pool associated with the requesting process will never be
used for variable resolution in a delegated service request.
<A NAME="IDX234"></A>
<HR><H2><A NAME="HDRSRESDEF" HREF="#ToC_183">7.5 Service Result Definition</A></H2>
<P>While all services technically return strings in the result buffer, many
times this string will actually be the marshalled form of a data structure.
This section describes how a service's result is defined in this documentation.
See <A HREF="#HDRMARSHALL">6.1, "Marshalling Structured Data"</A> for more information on marshalled data structures
(and how they are mapped to the various languages that STAF supports).
<P>In the simplest case, a service will return no value or a simple string (i.e.,
a string which is not the marshalled form of a data structure).  In this case,
the service result will simple describe what the simple string contains.  For
example, the HANDLE service documentation (see <A HREF="#HDRHANDCRT">8.6.2, "CREATE"</A>) indicates that when creating
a static handle the result buffer will simply contain the handle number that
was created.
<P>If the service result contains the marshalled form of a data structure (which
will now be referred to as "structured data"), the service documentation will
describe it in terms of various structured content.  The following are the
types of structured data you will encounter.
<UL>
<P><LI><TT>&lt;None&gt;</TT> - This is a special "object" that represents no value.
It is used to expressly indicate the lack of a particular value.  For example,
if an optional parameter was not specified on an earlier request, the result
of a later request may use <TT>&lt;None&gt;</TT> to indicate that the optional parameter was
not specified on the earlier request.
<P><LI><TT>&lt;String&gt;</TT> - This represents a string object.
<P><LI><TT>&lt;List&gt;</TT> - This represents an ordered list of other objects.  This
will always be expressed as <TT>&lt;List&gt; of &lt;some other type&gt;</TT>, where
<TT>&lt;some other type&gt;</TT> is one of the types defined here.
<P><LI><TT>&lt;Map&gt;</TT> - This represents a set of key/value pairs.  Typically, if
a service is using a <TT>&lt;Map&gt;</TT>, then the keys are not static from request
to request.  If the keys are static from request to request, the following data
type is used.
<P><LI><TT>&lt;Map:&lt;Class&gt;&gt;</TT> - This represents a "map class instance".  A map
class instance is similar to a <TT>&lt;Map&gt;</TT>.  However, a map class instance
(technically, the map class of which it is an instance) carries along additional
metadata, which defines the <TT>&lt;Class&gt;</TT> of the map class instance.
This metadata explicitly defines which keys are present in instances of the
map class , as well as information on how to display the keys.  See below
for more information on map classes.
<P><LI><TT>&lt;Any&gt;</TT> - This is a placeholder that represents any of the above data
types, and is not a true type itself.  It is used to document data for which a
type cannot be determined until runtime.
</UL>
<P>
<P>In some cases, the structured data that is returned will be one of a number
of possible values.  In that case, you will see the "or" symbol, '|', used to
list the possible choices.  Two common cases are
<PRE>
&lt;String&gt; | &lt;None&gt;
</PRE>
and
<PRE>
&lt;Map:&lt;Class&gt;&gt; | &lt;None&gt;
</PRE>
<P>In the first case, this means that you will either get a string object
or the special <TT>&lt;None&gt;</TT> object.  In the second case, it means you will
either get an instance of the specified map class or the special <TT>&lt;None&gt;</TT>
object.
<P>
<P>To further document map classes, each map class will have an associated
table defining the metadata associated with the map class.  The general format
of this table is as follows.
<P>
<BR>
<P><B><A NAME="Table_4">Table 4. Definition of map class &lt;Map Class Name&gt;</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This contains a description of the map class
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">key1
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key 1 display name
<BR>
(Key 1 short display name) if one is provided
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">key1 type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">key1 format/value information
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">...
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">...
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">...
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">...
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">keyX
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key X display name
<BR>
(Key 1 short display name) if one is provided
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">keyX type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">keyX format/value information
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
Any notes about the definition of the map class.
</TD></TR></TABLE>
<P>
The "Display Name" field shows the display name for each key, and,
optionally, a "short" display name may be specified (in parenthesis) for a key.
Short display names may be used as column headings by the STAF executable
when displaying the result in a tabular form if the total width of the
display names exceeds 80 characters.
<P>
The "Format / Value" field is used predominantly to document the data
present in <TT>&lt;String&gt;</TT> objects.  When, the string will contain one of a limited
set of possible values, then the set of possible values will be listed in
this column.  This might look like the following
<PRE>
'Default' | 'Enabled' | 'Disabled'
</PRE>
<P>When the string will be in a particular format, the format will be
documented in this column.  For example, a common string value is a timestamp,
which is documented in the "Format / Value" column as follows
<PRE>
<TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</PRE>
<P>
<A NAME="IDX235"></A>
<HR><H2><A NAME="HDRSERVICEHELP" HREF="#ToC_184">7.6 Service Help</A></H2>
<P>All STAF services provide a HELP command that list basic service syntax
information.
<P>It is recommended that external service writers also provide a HELP
facility.
<HR><H2><A NAME="HDRSERVICELIST" HREF="#ToC_185">7.7 Service list</A></H2>
<P>The following table contains a brief description of the services provided
with STAF.  The chapter that follows provides a detailed explanation of each
service.
<BR>
<P><B><A NAME="Table_5">Table 5. Service Descriptions</A></B><BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Service name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Description String Representation
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">CONFIG
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides a way to save the current STAF configuration
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">DELAY
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides a means to sleep a specified amount of time
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">DIAG
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides diagnostics services
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">ECHO
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Echos back a supplied message
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">FS
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides file transfer between systems
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">HANDLE
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides information about existing STAF handles
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">HELP
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides help on STAF error codes
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">LIFECYCLE
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Runs STAF service requests when STAFProc starts up or shuts down
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">LOG
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides robust logging services
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">MISC
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Handles miscellaneous commands such as displaying the version of STAF that is currently running
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">MONITOR
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides a means to monitor the status of running programs
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">PING
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides a simple is-alive message
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">PROCESS
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Handles starting, stopping, and querying processes
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">QUEUE
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Interacts with STAF queues
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">RESPOOL
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Manages pools of named elements
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">SEM
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides named event and mutex semaphores
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">SERVICE
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides information on available STAF services
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">SHUTDOWN
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides a means to shutdown STAF and register for shutdown notifications
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">TRACE
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides tracing information for STAF services
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">TRUST
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Interfaces with STAF's security
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">VAR
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Allows inspection and manipulation of STAF variable pools
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">ZIP
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Provides a means to zip/unzip/list/delete PKZip/WinZip compatible archives
</TD></TR></TABLE>
<HR><H1><A NAME="HDRSERVICEREF" HREF="#ToC_186">8.0 Service reference</A></H1>
<P>The foundation services that STAF provides are described in this chapter.
For each service the following sections are listed.
<UL COMPACT>
<LI>Description - an overview of what the service provides
<LI>Registration - documentation on how to register the service.  This section
will only be present for external services.
<LI>Variables - describes what variables affect the operation of the service.
This section is not present if the service does not use or depend on any
variables.
<LI>Commands - there will be one section for each of the major commands the
service supports.  This section will contain the following subsections.
<UL COMPACT>
<LI>Syntax - a description of the command syntax
<LI>Security - a statement as to the trust level required to perform this
command
<LI>Return Codes - a listing of the return codes this command may return
<LI>Results - the format of the result string this command may return.  Note,
information provided in this section pertains to the results from a successful
service request (i.e., a service request with a zero return code).  The results
buffer for a service request with a non-zero return code is generally dependent
on the return code from the request as opposed to the request itself.
Therefore, if you receive a non-zero return code from a service request, you
should generally look at the documentation for the return codes to determine the
contents of the result buffer.
<LI>Examples - examples of how to use this command
</UL>
</UL>
<P>
<A NAME="IDX236"></A>
<A NAME="IDX238"></A>
<HR><H2><A NAME="HDRCONFIGSRV" HREF="#ToC_187">8.1 Config Service</A></H2>
<P><H3><A NAME="Header_188">8.1.1 Description</A></H3>
<P>The CONFIG service is one of the internal STAF services.  It provides
a way to save the current STAF configuration to a file, reflecting any
changes made since STAFProc was started.
<UL COMPACT>
<LI>SAVE - Saves the current STAF configuration
<LI>HELP &#45; Returns syntax information
</UL>
<A NAME="IDX241"></A>
<P><H3><A NAME="Header_189">8.1.2 SAVE</A></H3>
<P>SAVE will display the current STAF configuration data or save it to a file,
reflecting any changes made since STAFProc was started.  This includes any
dynamic changes made by:
<UL COMPACT>
<LI>Adding/removing services dynamically via a <TT>SERVICE ADD</TT> request
<LI>Changing any operational settings via a <TT>MISC SET</TT>,
<TT>PROCESS SET</TT>, <TT>FS SET</TT>, or <TT>DIAG ENABLE/DISABLE</TT>
request.
<LI>Changing any trust settings via a <TT>TRUST SET</TT> request.
<LI>Changing any trace settings via the <TT>TRACE</TT> service.
<LI>Changing any shutdown notifications via the <TT>SHUTDOWN</TT> service's
<TT>NOTIFY REGISTER/UNREGISTER</TT> requests.
<LI>Setting any system or shared variables via the <TT>VAR</TT> service.
Note that you can choose instead to save the same system/shared variables that
were set in the STAF configuration file used when starting STAFProc.
</UL>
<P><H4><A NAME="Header_190">Syntax</A></H4>
<PRE>
SAVE [FILE &lt;Name&gt;] [VARS &lt;Current | Startup&gt;]
</PRE>
<P><TT>FILE</TT> specifies that name of a file where you want to save
the current STAF configuration data.  This file cannot already exist.
This option will resolve variables.
<P><TT>VARS</TT> specifies which STAF system and shared variables to save.
This option will resolve variables.  Recognized values are the following: 
<UL COMPACT>
<LI>Current: This indicates to use the current STAF variables that exist in
the system and shared variable pools
<LI>Startup: This indicates to use the STAF system and shared variables
that were set via SET VAR staetments in the STAF configuration file used
when starting STAFProc.
</UL>
<P>
<P><H4><A NAME="Header_191">Security</A></H4>
<P>This command requires trust level 3.
<P>However, if the <TT>DEFAULTAUTHPASSWORD</TT> has been set for the
<TT>PROCESS</TT> service, this command requires trust level 5.
<P><H4><A NAME="Header_192">Return Codes</A></H4>
<P>All return codes from SAVE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_193">Results</A></H4>
<P>On successful return, if the <TT>FILE</TT> option is not specified,
the result buffer will contain the current STAF configuration data.
<P>On successful return, if the <TT>FILE</TT> option is specified,
the result buffer will contain no data and the current STAF configuration data
will be saved to the specified file name.
<P><H4><A NAME="Header_194">Examples</A></H4>
<P>
<UL COMPACT>
<LI><B>Goal:</B> Save the current STAF configuration data to file
/tmp/mySTAF.cfg.
<P><B>Syntax:</B>
<P><TT>SAVE FILE /tmp/mySTAF.cfg</TT>
<P><B>Results:</B>
<PRE>
</PRE>
<P>
<LI><B>Goal:</B> Save the current STAF configuration data to file
/tmp/mySTAF.cfg using the STAF system/shared variables that were set
at startup in the original STAF configuration file.
<P><B>Syntax:</B>
<P><TT>SAVE FILE /tmp/mySTAF.cfg VARS Startup</TT>
<P><B>Results:</B>
<PRE>
</PRE>
<P>
<LI><B>Goal:</B> Display the current STAF configuration data.
<P><B>Syntax:</B>
<P><TT>SAVE</TT>
<P><B>Results:</B>
<PRE>
# ---------------------------------------------------------------------
# STAF Configuration File
# ---------------------------------------------------------------------
 
# ---------------------------------------------------------------------
# Tracing
# ---------------------------------------------------------------------
 
TRACE ENABLE ALL SERVICES
 
TRACE ENABLE TRACEPOINTS "ERROR WARNING DEPRECATED DEBUG"
 
# ---------------------------------------------------------------------
# Variables
# ---------------------------------------------------------------------
 
SET SYSTEM VAR STAFDemo/JavaAppClassPath=C:\STAF\lib\JSTAF.zip;C:\STAF\samples\demo\STAFDemo.jar;
SET SYSTEM VAR STAFDemo/JavaAppCommand=javaw.exe
 
# ---------------------------------------------------------------------
# Operational Parameters
# ---------------------------------------------------------------------
 
SET MAXQUEUESIZE 1000
SET MAXRETURNFILESIZE 5120
 
# ---------------------------------------------------------------------
# Interfaces (Connection Providers)
# ---------------------------------------------------------------------
 
INTERFACE ssl LIBRARY STAFTCP OPTION ConnectTimeout=5000 OPTION Port=6550 \
    OPTION Protocol=IPv4 OPTION Secure=Yes
 
INTERFACE tcp LIBRARY STAFTCP OPTION ConnectTimeout=5000 OPTION Port=6500 \
    OPTION Protocol=IPv4 OPTION Secure=No
 
# ---------------------------------------------------------------------
# Trust Levels
# ---------------------------------------------------------------------
 
TRUST LEVEL 5 MACHINE *://client1.mycompany.com
TRUST LEVEL 5 MACHINE *://client2.mycompany.com
TRUST LEVEL 5 MACHINE *://server1.mycompany.com
TRUST LEVEL 5 MACHINE local://local
 
# ---------------------------------------------------------------------
# Service Loader Service Registrations
# ---------------------------------------------------------------------
 
SERVICELOADER LIBRARY STAFDSLS
 
# ---------------------------------------------------------------------
# Service Registrations
# ---------------------------------------------------------------------
 
SERVICE STAX LIBRARY JSTAF EXECUTE C:\STAF\services\STAX.jar \
    OPTION JVMName=STAX OPTION J2=-Xmx512m \
    PARMS "CLEARLOGS Enabled FILECACHEALGORITHM LFU"
 
SERVICE EVENT LIBRARY JSTAF EXECUTE C:\STAF\services\STAFEvent.jar \
    OPTION JVMName=STAX
</PRE>
</UL>
<P>
<A NAME="IDX242"></A>
<A NAME="IDX244"></A>
<HR><H2><A NAME="HDRDELAYSRV" HREF="#ToC_195">8.2 Delay Service</A></H2>
<P><H3><A NAME="Header_196">8.2.1 Description</A></H3>
<P>The DELAY service is an internal STAF service. A DELAY request simply
sleeps for a specified amount of time before returning to the calling program.
<A NAME="IDX247"></A>
<P><H3><A NAME="Header_197">8.2.2 DELAY</A></H3>
<P><H4><A NAME="Header_198">Syntax</A></H4>
<PRE>
DELAY &lt;Number&gt;&#91;s|m|h|d|w&#93;
</PRE>
<P>
<TT>DELAY</TT> specifies an amount of time to sleep.  The time duration
may be expressed in milliseconds, seconds, minutes, hours, days, weeks, or years.
Its format is &lt;Number&gt;[s|m|h|d|w], where &lt;Number&gt; is an integer &gt;= 0 and
indicates milliseconds unless one of the following case-insensitive suffixes
is specified:
<UL COMPACT>
<LI>s (for seconds)
<LI>m (for minutes)
<LI>h (for hours)
<LI>d (for days)
<LI>w (for weeks).
</UL>
Note that the calculated amount of time to sleep cannot exceed 4294967294
milliseconds.  So, the maximum values in each time category that can be
specified are:
<UL COMPACT>
<LI>4294967294 (4294967294 milliseconds)
<LI>4294967s (4294967 seconds)
<LI>71582m (71582 minutes)
<LI>1193h (1193 hours)
<LI>49d (49 days)
<LI>7w (7 weeks)
</UL>
<P>
<P><H4><A NAME="Header_199">Security</A></H4>
<P>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_200">Return Codes</A></H4>
<P>
<P>All return codes from DELAY are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_201">Examples</A></H4>
<P>
<OL TYPE=1>
<P><LI><B>Goal&#58;</B> Delay 100 milliseconds.
<PRE>  
DELAY 100
</PRE>
<P>
<P><LI><B>Goal&#58;</B> Delay 5 seconds. 
<PRE>
DELAY 5s
</PRE>
<P>Note that this is equivalent to:
<PRE>
DELAY 5000
</PRE>
<P>
<P><LI><B>Goal&#58;</B> Delay 1 minute.
<PRE>
DELAY 1m
</PRE>
<P>Note that this is equivalent to:
<PRE>  
DELAY 60000
</PRE>
<P>
<P><LI><B>Goal&#58;</B> Delay 2 hours.
<PRE>
DELAY 2h
</PRE>
</OL>
<P>
<A NAME="IDX248"></A>
<A NAME="IDX250"></A>
<HR><H2><A NAME="HDRDIAGSRV" HREF="#ToC_202">8.3 Diagnostics (DIAG) Service</A></H2>
<P><H3><A NAME="Header_203">8.3.1 Description</A></H3>
<P>The Diagnostics service, called DIAG, is an internal STAF service
which lets you record and list diagnostics data.  It provides the
following commands:
<UL COMPACT>
<LI>RECORD - Records diagnostics data in the diagnostics map and keeps
a count of the number of times each unique trigger/source combination
is recorded
<LI>LIST - Displays diagnostics data that has been recorded or
displays the operational settings (e.g. enabled or disabled) for the
service
<LI>RESET - Clears all data from the diagnostics map
<LI>ENABLE - Enables recording diagnostics data
<LI>DISABLE - Disables recording diagnostics data
<LI>HELP - Returns syntax information
</UL>
<P>The purpose of the DIAG service is to allow you to record
diagnostics data consisting of a trigger and its source.  The number
of times each trigger/source combination occurs is accumulated by
the DIAG service.  You may list the trigger(s)/source(s) and their
counts, as well as clear all data from the diagnostics map.
<P><B>Note: </B>The commands for the DIAG service and their result formats are
subject to change.
<A NAME="IDX253"></A>
<P><H3><A NAME="Header_204">8.3.2 RECORD</A></H3>
<P>RECORD writes diagnostics data (a trigger and its source) to a
diagnostics map where a count is kept of the number of times each
unique trigger/source combination occurs.
<P><B>Note: </B>You must enable diagnostics before you can record diagnostics
data.
<P><H4><A NAME="Header_205">Syntax</A></H4>
<PRE>
RECORD TRIGGER &lt;Trigger&gt; SOURCE &lt;Source&gt;
</PRE>
<P><TT>TRIGGER</TT> specifies the trigger (event) that you want
to record in the diagnostics map.  You can specify anything for
the trigger, but we recommend that you don't specify a semi-colon (;)
in the trigger to make it easier to parse the list output which uses
a semi-colon to separate fields.  This option will resolve variables.
<P><TT>SOURCE</TT> specifies information about the originator of
the trigger.  It is also recorded in the diagnostics map.  For example,
you may want to include the originating machine's name, handle, and
handle name.  This option will resolve variables.
<P><H4><A NAME="Header_206">Security</A></H4>
<P>This command requires trust level 3.
<P><B>Note: </B>This command is only valid if submitted to the local machine,
not to remote machines.
<P>
<P><H4><A NAME="Header_207">Return Codes</A></H4>
<P>All return codes from RECORD are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_208">Results</A></H4>
<P>The result buffer will contain no data on a successful return from a
RECORD command.
<P><H4><A NAME="Header_209">Examples</A></H4>
<DL COMPACT>
<DD><B>Goal:</B>&nbsp; Record trigger "PROCESS QUERY" and "myApp;machinea.ibm.com"
as the source of the trigger in the diagnostics map.
<DD><B>Syntax:</B>&nbsp; <TT>RECORD TRIGGER "PROCESS QUERY" SOURCE "myApp;machinea.ibm.com"</TT>
</DL>
<P>
<P><H3><A NAME="HDRDIAGLIST">8.3.3 LIST</A></H3>
<A NAME="IDX256"></A>
<P>LIST allows you to list all the information in the diagnostics map,
or just the triggers or sources, or a particular trigger or source.
It also allows you to list current operational settings.
<P><H4><A NAME="Header_211">Syntax</A></H4>
<PRE>
LIST   &lt;[TRIGGER &lt;Trigger&gt; | SOURCE &lt;Source&gt; | TRIGGERS | SOURCES]
        [SORTBYCOUNT | SORTBYTRIGGER | SORTBYSOURCE]&gt; |
       SETTINGS
</PRE>
<P>If no options are specified (other than a <TT>SORTBY</TT> option),
it will list all the trigger/source combinations that were recorded
and the number of times each was recorded.
<P><TT>TRIGGER</TT> indicates you want to list all the sources for
the specified trigger and the number of times each source was recorded
for this trigger.  This option will resolve variables.
<P><TT>SOURCE</TT> indicates you want to list all the triggers for
the specified source and the number of times each trigger was recorded
for this source.  This option will resolve variables.
<P><TT>TRIGGERS</TT> indicates you want to list all the triggers that
have been recorded and the number of times they were recorded.
<P><TT>SOURCES</TT> indicates you want to list all the sources that
have been recorded and the number of times they were recorded.
<P><TT>SORTBYCOUNT</TT> specifies to sort the listing by count in
descending order.  This is the default.
<P><TT>SORTBYTRIGGER</TT> specifies to sort the listing by trigger in
ascending order.
<P><TT>SORTBYSOURCE</TT> specifies to sort the listing by source in
ascending order.
<P><TT>SETTINGS</TT> indicate you want to list the current operational
settings for the service.
<P>
<P><H4><A NAME="Header_212">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_213">Return Codes</A></H4>
<P>All return codes from LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_214">Results</A></H4>
<P>If successful, the result buffer will contain information
about the <TT>LIST</TT> request based on the options specified: 
<P>
<UL>
<P><LI><TT>LIST</TT>
<P>
The result buffer for a <TT>LIST</TT> request (without specifying options
<TT>TRIGGER, SOURCE, TRIGGERS, SOURCES, or SETTINGS</TT>) will contain a
marshalled <TT>&lt;Map&#58;STAF/Service/Diag/AllDiagInfo&gt;</TT>
representing the diagnostics information for all of the unique
trigger/source combinations.
The maps are defined as follows:
<BR>
<P><B><A NAME="Table_6">Table 6. Definition of map class STAF/Service/Diag/AllDiagInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the diagnostics
information for all of the unique trigger/source combinations.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">fromTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">From Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">toTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">To Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">elapsedTime
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Elapsed Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;[H]HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">numberOfTriggers
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Number of Triggers
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">numberOfSources
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Number of Sources
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">comboList
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Trigger/Source Combinations
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Diag/ComboCount&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>"From Date-Time" specifies the date/time that diagnostics
were first enabled or last reset, or <TT>&lt;None&gt;</TT> if diagnostics have never
been enabled.
<LI>"To Date-Time" specifies the date/time that diagnostics
were disabled or, if still enabled, the current time.
<LI>"Elapsed Time" specifies the difference between the
"From Date-Time" and the "To Date-Time" in hours,
minutes, and seconds, or <TT>&lt;None&gt;</TT> if diagnostics have never been enabled.
<LI>"Number of Triggers" specifies the number of unique
triggers that have been recorded.
<LI>"Number of Sources" specifies the number of unique sources
that have been recorded.
<LI>See table <A HREF="#TBLDIAGCOMBOCOUNTTABLE">Table 7</A> for the map class definition of
<TT>&lt;Map&#58;STAF/Service/Diag/ComboCount&gt;</TT>.
</OL>
</TD></TR></TABLE>
<BR>
<P><B><A NAME="TBLDIAGCOMBOCOUNTTABLE">Table 7. Definition of map class STAF/Service/Diag/ComboCount</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a unique trigger/source
combination and a count of how many times it was recorded.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">trigger
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Trigger
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">source
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Source
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">count
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Count
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
"Count" specifies the number of times each trigger/source
combination has been recorded.
</TD></TR></TABLE>
<P>
<P><LI><TT>LIST TRIGGERS</TT>
<P>
The result buffer for a <TT>LIST TRIGGERS</TT> request will contain a
marshalled <TT>&lt;Map&#58;STAF/Service/Diag/TriggersInfo&gt;</TT>
representing the diagnostics information for all of the unique triggers
that have been recorded.
The maps are defined as follows:
<BR>
<P><B><A NAME="Table_8">Table 8. Definition of map class STAF/Service/Diag/TriggersInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the diagnostics
information for all of the unique triggers that have been recorded.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">fromTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">From Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">toTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">To Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">elapsedTime
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Elapsed Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;[H]HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">numberOfTriggers
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Number of Triggers
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">triggerList
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Triggers
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Diag/TriggerCount&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>"From Date-Time" specifies the date/time that diagnostics
were first enabled or last reset, or <TT>&lt;None&gt;</TT> if diagnostics have never
been enabled.
<LI>"To Date-Time" specifies the date/time that diagnostics
were disabled or, if still enabled, the current time.
<LI>"Elapsed Time" specifies the difference between the
"From Date-Time" and the "To Date-Time" in hours,
minutes, and seconds, or <TT>&lt;None&gt;</TT> if diagnostics have never been enabled.
<LI>"Number of Triggers" specifies the number of unique
triggers that have been recorded.
<LI>See table <A HREF="#TBLDIAGTRIGGERCOUNTTABLE">Table 9</A> for the map class definition of
<TT>&lt;Map&#58;STAF/Service/Diag/TriggerCount&gt;</TT>.
</OL>
</TD></TR></TABLE>
<BR>
<P><B><A NAME="TBLDIAGTRIGGERCOUNTTABLE">Table 9. Definition of map class STAF/Service/Diag/TriggerCount</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a trigger
and a count of how many times it was recorded.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">trigger
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Trigger
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">count
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Count
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
"Count" specifies the number of times a trigger has been recorded.
</TD></TR></TABLE>
<P>
<P><LI><TT>LIST SOURCES</TT>
<P>
The result buffer for a <TT>LIST SOURCES</TT> request will contain a
marshalled <TT>&lt;Map&#58;STAF/Service/Diag/SourcesInfo&gt;</TT>
representing the diagnostics information for all of the unique sources
that have been recorded.
The maps are defined as follows:
<BR>
<P><B><A NAME="Table_10">Table 10. Definition of map class STAF/Service/Diag/SourcesInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the diagnostics
information for all of the unique sources that have been recorded.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">fromTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">From Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">toTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">To Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">elapsedTime
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Elapsed Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;[H]HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">numberOfSources
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Number of Sources
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">sourceList
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Sources
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Diag/SourceCount&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>"From Date-Time" specifies the date/time that diagnostics
were first enabled or last reset, or <TT>&lt;None&gt;</TT> if diagnostics have never
been enabled.
<LI>"To Date-Time" specifies the date/time that diagnostics
were disabled or, if still enabled, the current time.
<LI>"Elapsed Time" specifies the difference between the
"From Date-Time" and the "To Date-Time" in hours,
minutes, and seconds, or <TT>&lt;None&gt;</TT> if diagnostics have never been enabled.
<LI>"Number of Sources" specifies the number of unique
sources that have been recorded.
<LI>See table <A HREF="#TBLDIAGSOURCECOUNTTABLE">Table 11</A> for the map class definition of
<TT>&lt;Map&#58;STAF/Service/Diag/SourceCount&gt;</TT>.
</OL>
</TD></TR></TABLE>
<BR>
<P><B><A NAME="TBLDIAGSOURCECOUNTTABLE">Table 11. Definition of map class STAF/Service/Diag/SourceCount</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a source
and a count of how many times it was recorded.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">source
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Source
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">count
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Count
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
"Count" specifies the number of times a source has been recorded.
</TD></TR></TABLE>
<P>
<P><LI><TT>LIST TRIGGER &lt;Trigger&gt;</TT>
<P>
The result buffer for a <TT>"LIST TRIGGER &lt;Trigger&gt;"</TT> request
will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Diag/TriggerInfo&gt;</TT>
representing the diagnostics information for the unique sources
that have been recorded for the specified trigger.
The maps are defined as follows:
<BR>
<P><B><A NAME="Table_12">Table 12. Definition of map class STAF/Service/Diag/TriggerInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the diagnostics
information for the specified trigger.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">fromTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">From Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">toTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">To Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">elapsedTime
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Elapsed Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;[H]HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">trigger
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Trigger
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">numberOfSources
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Number of Sources
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">sourceList
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Sources
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Diag/SourceCount&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>"From Date-Time" specifies the date/time that diagnostics
were first enabled or last reset, or <TT>&lt;None&gt;</TT> if diagnostics have never
been enabled.
<LI>"To Date-Time" specifies the date/time that diagnostics
were disabled or, if still enabled, the current time.
<LI>"Elapsed Time" specifies the difference between the
"From Date-Time" and the "To Date-Time" in hours,
minutes, and seconds, or <TT>&lt;None&gt;</TT> if diagnostics have never been enabled.
<LI>"Number of Sources" specifies the number of unique
sources that have recorded diagnostics for the specified trigger.
<LI>See table <A HREF="#TBLDIAGSOURCECOUNTTABLE">Table 11</A> for the map class definition of
<TT>&lt;Map&#58;STAF/Service/Diag/SourceCount&gt;</TT>.
</OL>
</TD></TR></TABLE>
<P>
<P><LI><TT>LIST SOURCE &lt;Source&gt;</TT>
<P>
The result buffer for a <TT>"LIST SOURCE &lt;Source&gt;"</TT> request
will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Diag/SourceInfo&gt;</TT>
representing the diagnostics information for all of the unique triggers
that have been recorded for the specified source.
The maps are defined as follows:
<BR>
<P><B><A NAME="Table_13">Table 13. Definition of map class STAF/Service/Diag/SourceInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the diagnostics
information for the specified source.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">fromTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">From Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">toTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">To Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">elapsedTime
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Elapsed Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;[H]HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">source
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Source
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">numberOfTriggers
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Number of Triggers
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">triggerList
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Triggers
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Diag/TriggerCount&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>"From Date-Time" specifies the date/time that diagnostics
were first enabled or last reset, or <TT>&lt;None&gt;</TT> if diagnostics have never
been enabled.
<LI>"To Date-Time" specifies the date/time that diagnostics
were disabled or, if still enabled, the current time.
<LI>"Elapsed Time" specifies the difference between the
"From Date-Time" and the "To Date-Time" in hours,
minutes, and seconds, or <TT>&lt;None&gt;</TT> if diagnostics have never been enabled.
<LI>"Number of Triggers" specifies the number of unique
triggers that have been recorded for the specified source.
<LI>See table <A HREF="#TBLDIAGTRIGGERCOUNTTABLE">Table 9</A> for the map class definition of
<TT>&lt;Map&#58;STAF/Service/Diag/TriggerCount&gt;</TT>.
</OL>
</TD></TR></TABLE>
<P>
<P><LI><TT>LIST SETTINGS</TT>
<P>
The result buffer for a <TT>"LIST SETTINGS"</TT> request
will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Diag/Settings&gt;</TT>
representing the current operational settings for the DIAG service.
The maps are defined as follows:
<BR>
<P><B><A NAME="Table_14">Table 14. Definition of map class STAF/Service/Diag/Settings</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the current
operational settings for the DIAG service.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">diagnostics
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Diagnostics
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'.</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">lastResetTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Last Reset / First Enabled
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">lastDisabledTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Last Disabled
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>"Diagnostics" specifies if recording diagnostics is 
currently enabled or disabled.
<LI>"Last Reset / First Enabled" specifies the timestamp when diagnostics
were last reset or first enabled or <TT>&lt;None&gt;</TT> if diagnostics have never
been reset since STAF was started.
<LI>"Last Disabled" specifies the timestamp when diagnostics
were last disabled or last cleared via the RESET command.
It is initially set to the date/time when STAF was started.
</OL>
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_215">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B>&nbsp; Show me all the trigger/source combinations that
have been recorded (sorted in descending order by count, the
default).
<P><B>Syntax:</B>&nbsp; <TT>LIST</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in verbose format, could look like:
<PRE>
{
  From Date-Time             : 20040926-12:15:04
  To Date-Time               : 20040926-12:20:05
  Elapsed Time               : 00:05:01
  Number of Triggers         : 3
  Number of Sources          : 2
  Trigger/Source Combinations: [
    {
      Trigger: MYSERVICE QUERY
      Source : MyApp;machine1.austin.ibm.com;77
      Count  : 10
    }
    { 
      Trigger: MYSERVICE QUERY
      Source : myApp2;machine1.austin.ibm.com;97
      Count  : 7
    }
    {
      Trigger: SAMPLE1 QUERY
      Source : myApp2;machine1.austin.ibm.com;97
      Count  : 4
    }
    {
      Trigger: MYSERVICE LIST
      Source : myApp2;machine1.austin.ibm.com;97
      Count  : 1
    }
  ]
}
</PRE>
<P>
<P><LI><B>Goal&#58;</B>&nbsp; Show me all the triggers and sources that have been
recorded sorted in ascending order by trigger.
<P><B>Syntax&#58;</B>&nbsp; <TT>LIST SORTBYTRIGGER</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in verbose format, could look like:
<PRE>
{
  From Date-Time             : 20040926-12:15:04
  To Date-Time               : 20040926-12:21:09
  Elapsed Time               : 00:06:05
  Number of Triggers         : 3
  Number of Sources          : 2
  Trigger/Source Combinations: [
    {
      Trigger: MYSERVICE LIST
      Source : myApp2;machine1.austin.ibm.com;97
      Count  : 1
    }
    {
      Trigger: MYSERVICE QUERY
      Source : MyApp;machine1.austin.ibm.com;77
      Count  : 10
    }
    {
      Trigger: MYSERVICE QUERY
      Source : myApp2;machine1.austin.ibm.com;97
      Count  : 7
    }
    {
      Trigger: SAMPLE1 QUERY
      Source : myApp2;machine1.austin.ibm.com;97
      Count  : 4
    }
  ]
}
</PRE>
<P>
<P><LI><B>Goal&#58;</B>&nbsp;  Show me all the triggers that have been recorded,
sorted by trigger in ascending order.
<P><B>Syntax&#58;</B>&nbsp; <TT>LIST TRIGGERS SORTBYTRIGGER</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in verbose format, could look like:
<PRE>
{
  From Date-Time    : 20040926-12:15:04
  To Timestamp      : 20040926-12:28:20
  Elapsed Time      : 00:13:16
  Number of Triggers: 3
  Triggers          : [
    {
      Trigger: MYSERVICE LIST
      Count  : 1
    }
    {
      Trigger: MYSERVICE QUERY
      Count  : 17
    }
    {
      Trigger: SAMPLE1 QUERY
      Count  : 4
    }
  ]
}
</PRE>
<P>
<P><LI><B>Goal&#58;</B>&nbsp;  Show me all the sources that have been recorded
(sorted by count in descending order, the default).
<P><B>Syntax&#58;</B>&nbsp; <TT>LIST SOURCES</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in verbose format, could look like:
<PRE>
{
  From Date-Time   : 20040926-12:15:04
  To Date-Time     : 20040926-12:32:53
  Elapsed Time     : 00:17:49
  Number of Sources: 2
  Sources          : [
    {
      Source: MyApp;machine1.austin.ibm.com;77
      Count : 10
    }
    {
      Source: MyApp2;machine1.austin.ibm.com;97
      Count : 12
    }
  ]
}
</PRE>
<P>
<P><LI><B>Goal&#58;</B>&nbsp; Show me all of the sources for trigger
<TT>"MYSERVICE QUERY"</TT>, sorted by source in ascending order.
<P><B>Syntax&#58;</B>&nbsp; <TT>LIST TRIGGER "MYSERVICE QUERY" SORTBYSOURCE</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in verbose format, could look like:
<PRE>
{
  From Date-Time   : 20040926-12:15:04
  To Date-Time     : 20040926-12:36:18
  Elapsed Time     : 00:21:14
  Trigger          : MYSERVICE QUERY
  Number of Sources: 2
  Sources          : [
    {
      Source: MyApp;machine1.austin.ibm.com;77
      Count : 10
    }
    {
      Source: MyApp2;machine1.austin.ibm.com;97
      Count : 7
    }
  ]
}      
</PRE>
<P>
<P><LI><B>Goal&#58;</B>&nbsp; Show me all of the triggers for source
<TT>"MyApp2;machine1.austin.ibm.com;97"</TT> (sorted by count in 
descending order, the default).
<P><B>Syntax&#58;</B>&nbsp; <TT>LIST SOURCE "MyApp2;machine1.austin.ibm.com;97"</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in verbose format, could look like:
<PRE> 
{
  From Date-Time    : 20040926-12:15:04
  To Date-Time      : 20040926-12:40:08
  Elapsed Time      : 00:25:04
  Source            : MyApp2;machine1.austin.ibm.com;97
  Number of Triggers: 3
  Triggers          : [
    {
      Trigger: MYSERVICE QUERY
      Count  : 7
    }
    {
      Trigger: SAMPLE1 QUERY
      Count  : 4
    }
    {
      Trigger: MYSERVICE LIST
      Count  : 1
    }
  ]
}
</PRE>
<P> 
<P><LI><B>Goal&#58;</B>&nbsp; Show me the current operational settings.
<P><B>Syntax&#58;</B>&nbsp; <TT>LIST SETTINGS</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in default format, could look like:
<PRE>
Diagnostics               : Enabled
Last Reset / First Enabled: 20040926-12:15:04
Last Disabled             : 20040926-12:14:53
</PRE>
</UL>
<A NAME="IDX259"></A>
<P><H3><A NAME="HDRDIAGRESET">8.3.4 RESET</A></H3>
<P>RESET allows you to clear all data from the diagnostics map.
<P><H4><A NAME="Header_217">Syntax</A></H4>
<PRE>
RESET FORCE
</PRE>
<P><TT>FORCE</TT> is a confirmation that you want to clear all data.
<P><H4><A NAME="Header_218">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_219">Return Codes</A></H4>
<P>All return codes from RESET are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_220">Results</A></H4>
<P>The result buffer will contain no data on a successful return from a
RESET command.
<P><H4><A NAME="Header_221">Examples</A></H4>
<DL COMPACT>
<DD><B>Goal&#58;</B>&nbsp; Remove all information in the diagnostics map.
<DD><B>Syntax&#58;</B>&nbsp; <TT>RESET FORCE</TT>
</DL>
<A NAME="IDX262"></A>
<P><H3><A NAME="HDRDIAGENABLE">8.3.5 ENABLE</A></H3>
<P>ENABLE allows you to enable recording diagnostics.
<P><B>Note: </B>You may also enable diagnostics when STAF starts by setting
operational parameter <TT>ENABLEDIAGS</TT> in the STAF configuration
file.
<P><H4><A NAME="Header_223">Syntax</A></H4>
<PRE>
ENABLE
</PRE>
<P><H4><A NAME="Header_224">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_225">Return Codes</A></H4>
<P>All return codes from ENABLE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_226">Results</A></H4>
<P>The result buffer will contain no data on a successful return from a
ENABLE command.
<P><H4><A NAME="Header_227">Examples</A></H4>
<DL COMPACT>
<DD><B>Goal&#58;</B>&nbsp; Enable recording diagnostics.
<DD><B>Syntax&#58;</B>&nbsp; <TT>ENABLE</TT>
</DL>
<A NAME="IDX265"></A>
<P><H3><A NAME="HDRDIAGDISABLE">8.3.6 DISABLE</A></H3>
<P>DISABLE allows you to disable recording diagnostics.
<P><H4><A NAME="Header_229">Syntax</A></H4>
<PRE>
DISABLE
</PRE>
<P><H4><A NAME="Header_230">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_231">Return Codes</A></H4>
<P>All return codes from DISABLE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_232">Results</A></H4>
<P>The result buffer will contain no data on a successful return from a
DISABLE command.
<P><H4><A NAME="Header_233">Examples</A></H4>
<DL COMPACT>
<DD><B>Goal&#58;</B>&nbsp; Disable recording diagnostics.
<DD><B>Syntax&#58;</B>&nbsp; <TT>DISABLE</TT>
</DL>
<P>
<A NAME="IDX266"></A>
<A NAME="IDX268"></A>
<HR><H2><A NAME="HDRECHOSRV" HREF="#ToC_234">8.4 Echo Service</A></H2>
<P><H3><A NAME="Header_235">8.4.1 Description</A></H3>
<P>The ECHO service is an internal STAF service. ECHO provides a
similar service as PING.  The difference is that ECHO allows you
to specify the return string that STAFProc will return.
ECHO can also be used to determine if STAFProc is up and running
and accessible.
<A NAME="IDX271"></A>
<P><H3><A NAME="Header_236">8.4.2 ECHO</A></H3>
<P><H4><A NAME="Header_237">Syntax</A></H4>
<PRE>
ECHO &lt;Message&gt;
</PRE>
<P><B>Note: </B>ECHO does not follow the request parsing rules described earlier.
Any text after the ECHO command will be returned verbatim.
<P><H4><A NAME="Header_238">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_239">Return Codes</A></H4>
<P>All return codes from ECHO are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_240">Results</A></H4>
<P>The result buffer will contain <TT>&lt;Message&gt;</TT> on a successful
return from an ECHO command.
<P><H4><A NAME="Header_241">Examples</A></H4>
<P>Goal&#58; Have STAFProc return the string Hello World to you.
<PRE>
ECHO Hello World
</PRE>
<P>
<A NAME="IDX272"></A>
<A NAME="IDX274"></A>
<HR><H2><A NAME="HDRFSSRV" HREF="#ToC_242">8.5 File System (FS) Service</A></H2>
<P><H3><A NAME="Header_243">8.5.1 Description</A></H3>
<P>The File System service, called FS, allows you to interface with the file
system on STAF Clients.  It provides the following commands.
<UL COMPACT>
<LI>COPY FILE - Allows you to copy a file between machines, or to
another location on the same machine
<LI>COPY DIRECTORY - Allows you to copy selected files from a directory or
entire directories (including subdirectories if needed) between machines,
or to another directory on the same machine
<LI>MOVE FILE - Allows you to rename a file or move files from one directory
to another directory on a machine.
<LI>MOVE DIRECTORY - Allows you to rename a directory on a machine.
<LI>GET FILE - Retrieves the contents of a file from a machine
<LI>GET ENTRY - Retrieves an attribute of a file system entry, such as its
type, size, last modification time, link target, or checksum.
<LI>QUERY - Retrieves the various attributes of file system entry
<LI>LIST DIRECTORY - Lists the selected contents of a directory, or provides
summary information for the selected contents of a directory (e.g. total
size, number of files and subdirectories)
<LI>LIST COPYREQUESTS - Lists the copy requests in progress
<LI>LIST SETTINGS - Lists the operational settings for the File System
service
<LI>CREATE - Creates a directory
<LI>DELETE - Deletes selected file system entries
<LI>SET - Changes operational settings for the File System service
<LI>HELP &#45; Returns syntax information
</UL>
<P>In the descriptions of these commands, three different options are used to
refer to objects in the file system.  <TT>FILE</TT> is used when the object in
question must be a file.  <TT>DIRECTORY</TT> is used when the object in
question must be a directory.  <TT>ENTRY</TT> is used when the object in
question may be any object in the file system.
<P>Some of these commands (e.g. COPY DIRECTORY, LIST DIRECTORY, DELETE)
allow match patterns to be specified.  These patterns recognize two special
characters, '*' and '?', as wildcards:
<UL COMPACT>
<LI>'*' matches a string of characters (including an empty string)
<LI>'?' matches any single character (the empty string does not match)
</UL>
<A NAME="IDX277"></A>
<P><H3><A NAME="Header_244">8.5.2 COPY FILE</A></H3>
<P>COPY FILE allows you to copy one file between machines, or to another
location on the same machine.
<P>
<P><H4><A NAME="Header_245">Notes:</A></H4>
<OL COMPACT TYPE=1>
<LI>A file copied via the FS service does not retain its system or extended attributes.
<LI>If a file copied via the FS service is a symbolic link, the entry referenced
by the link will be copied (not the symbolic link itself).
<LI>The FS service supports copying a file whose size is less than 4 GB on most
platforms, assuming the operating system supports the creation of large files, that is,
files larger than 2 GB.
</OL>
<P>
<P><H4><A NAME="Header_246">Syntax</A></H4>
<PRE>
COPY FILE &lt;FileName&gt; &#91;TOFILE &lt;Name&gt; | TODIRECTORY &lt;Name&gt;&#93; &#91;TOMACHINE &lt;Machine&gt;&#93;
     &#91;TEXT &#91;FORMAT &lt;Format&gt;&#93;&#93; &#91;FAILIFEXISTS | FAILIFNEW&#93;
</PRE>
<P><TT>FILE</TT> specifies the name of the file to copy. This option will resolve variables.
<P><TT>TOFILE</TT> specifies the name of the file to create.  The directory path
specified must already exist on the machine where the file is being copied to, or
else the copy request will fail with RC 17 (File open error).
If neither <TT>TOFILE</TT> nor <TT>TODIRECTORY</TT> is specified, this
defaults to the same, unresolved, name as specified in <TT>FILE</TT>.
This option will resolve variables. These variables will be resolved on the target machine.
<P><TT>TODIRECTORY</TT> specifies the name of the directory to copy the file to.
The name of the "to file" will be the same as specified in <TT>FILE</TT>.
This directory must already exist on the target machine.
This option will resolve variables. These variables will be resolved on the target machine.
<P><TT>TOMACHINE</TT> specifies the machine to copy the file to.  This
defaults to the machine which originated the request.
Specifying<TT> local </TT>indicates to copy the file to the same
machine that the file is being copied from.
Note that specifying<TT> local </TT>instead of the from machine's host name can
significantly improve performance, especially if your TCP network performance
is slow.  This is because<TT> local </TT>(or<TT> local://local</TT>) indicates
to use the local network interface versus specifying a TCP host name or IP address
which indicates to use the TCP network interface.  This option will resolve variables.
<P><TT>TEXT</TT> specifies to convert line-ending characters in the file being
copied as specified via the <TT>FORMAT</TT> option and to perform codepage conversion.
This option should only be specified for a text file, not a binary file.
<P><TT>FORMAT</TT> specifies the end-of-line character(s) to use.  This option will resolve variables.
See <A HREF="#HDRFSGETFILE">8.5.6, "GET FILE"</A> for more information on available formats.
<P><TT>FAILIFEXISTS</TT> specifies that the copy should fail if
<TT>TOFILE</TT> already exists.  The default is to replace the file if it
exists.
<P><TT>FAILIFNEW</TT> specifies that the copy should fail if <TT>TOFILE</TT>
does not already exist.  The default is to create the file if it does not
exist.
<P><H4><A NAME="Header_247">Security</A></H4>
There can be up to three machines involved in a COPY FILE request
(and any of these machines can be the same machine):
<OL COMPACT TYPE=1>
<LI><TT>orgMachine</TT> - The machine that submitted (i.e. originated) the
COPY FILE request
<LI><TT>sourceMachine</TT> - The machine where the file to be copied resides
(this is the machine to which you submitted the COPY FILE request)
<LI><TT>toMachine</TT> - The machine where the file will be copied to
</OL>
<P>This command requires trust level 4 as follows:
<UL COMPACT>
<LI>The<TT> sourceMachine </TT>must give at least trust level 4 to the<TT> orgMachine</TT>.
<LI>The<TT> toMachine </TT>must give at least trust level 4 to the<TT> sourceMachine</TT>.
<LI>The<TT> toMachine </TT>must give at least trust level 4 to the<TT> orgMachine</TT>.
</UL>
<P>
An exception to these trust requirements is if the<TT> orgMachine </TT>is the same
as the<TT> toMachine </TT>and the<TT> STRICTFSCOPYTRUST </TT>operational setting
is disabled (which it is by default), then the<TT> toMachine </TT>does not have to
give trust level 4 to the<TT> sourceMachine</TT>.  See <A HREF="#HDROPPARMS">4.7, "Operational parameters"</A> for
more information on the<TT> STRICTFSCOPYTRUST </TT>operational parameter.
<P>
<P><H4><A NAME="Header_248">Return Codes</A></H4>
<P>All return codes from COPY FILE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_249">Results</A></H4>
<P>The result buffer will contain no data on return from a COPY FILE command.
<P><H4><A NAME="Header_250">Examples</A></H4>
<P>In the following examples, assume the command is being submitted locally from
machine TestSrv1.
<P>
<UL>
<P><LI><B>Goal:</B> Copy file c:\testcase\tc1.cmd from machine TestSrv1 to file
c:\testcase\tc1.cmd on machine Client1
<P>
<B>Syntax:</B>&nbsp; <TT>COPY FILE c:\testcase\tc1.cmd TOMACHINE Client1</TT>
<P>
<P><LI><B>Goal:</B> Copy file c:\testcase\tc1.cmd from machine TestSrv1 to file
d:\WebTests\webtc1.cmd on machine Client1.  Don't overwrite the file if it
exists.
<BR>
<B>Syntax:</B>&nbsp; <TT>COPY FILE c:\testcase\tc1.cmd TOFILE d:\WebTests\webtc1.cmd TOMACHINE Client1 FAILIFEXISTS</TT>
<P>
<P><LI><B>Goal:</B> Copy text file test1.txt (in the directory specified by STAF
variable TestcaseDir) from machine TestSrv1 to file test1.txt (in the
directory specified by STAF variable TestcaseDir) on machine Client1.
Convert any line-ending characters in the file to those appropriate for
machine Client1, if machine Client1 has a different platform (e.g. Unix)
than machine TestSrv1 (e.g. Windows).
<P>
<B>Syntax:</B>&nbsp; Note that both of these <TT>COPY FILE</TT> examples are equivalent.
<PRE>
COPY FILE {TestcaseDir}/test1.txt TOMACHINE Client1 TEXT
COPY FILE {TestcaseDir}/test1.txt TOMACHINE Client1 TEXT FORMAT Native
</PRE>
<P>
<P><LI><B>Goal:</B> Copy text file c:\tc\test1.txt from machine TestSrv1
to file c:\tc\test1.txt on machine Client1.  Convert any line-ending
characters in the file to a space.
<P>
<B>Syntax:</B>&nbsp; <TT>COPY FILE c:\tc\test1.txt TOMACHINE Client1 TEXT FORMAT " "</TT>
</UL>
<P>
In the following examples, assume the command is being submitted to machine
Client1 from machine TestSrv1.
<P>
<UL>
<P><LI><B>Goal:</B> Retrieve file d:\WebTests\Logs\WebTC1.log from Client1 and store
it in directory f:\Logs on machine TestSrv1.
<P>
<B>Syntax:</B>&nbsp; <TT>COPY FILE d:\WebTests\Logs\WebTC1.log TOFILE f:\Logs\WebTC1.log </TT>
<P>
<P><LI><B>Goal:</B> Copy file d:\WebTests\Logs\WebTC1.log from Client1 to server
LogSrv in directory h:\Logs.
<P>
<B>Syntax:</B>&nbsp; <TT>COPY FILE d:\WebTests\Logs\WebTC1.log TODIRECTORY h:\Logs TOMACHINE LogSrv</TT>
<P>
<P><LI><B>Goal:</B> Copy file d:\WebTests\Logs\WebTC1.log from Client1 to file c:\temp\tc1.log
on machine Client1.
<P>
<B>Syntax:</B>&nbsp; <TT>COPY FILE d:\WebTests\Logs\WebTC1.log TOFILE c:\temp\tc1.log TOMACHINE local</TT>
<P>
<P><LI><B>Goal:</B> Copy the startup.cmd on the boot drive of Client1 to the boot
drive of TestSrv1.  Convert any line-ending characters of the text file as
needed.
<P>
<B>Syntax:</B>&nbsp; <TT>COPY FILE {STAF/Config/BootDrive}\startup.cmd TEXT</TT>
</UL>
<A NAME="IDX280"></A>
<P><H3><A NAME="Header_251">8.5.3 COPY DIRECTORY</A></H3>
<P>COPY DIRECTORY allows you to copy selected files from a directory or entire
directories (including subdirectories if needed) between machines, or to another
directory on the same machine.  It allows you to specify wildcards (e.g. *, ?)
in the <TT>NAME</TT> and/or <TT>EXT</TT> options to match patterns in file
names to be copied from the specified directory and its subdirectories too if
the <TT>RECURSE</TT> option is specified.
<P>
<P><H4><A NAME="Header_252">Notes:</A></H4>
<OL COMPACT TYPE=1>
<LI>A file system entry copied via the FS service does not retain its system or
extended attributes.
<LI>The types of entries supported by a COPY DIRECTORY request are files and directories.
<LI>If a file system entry copied via the FS service is a symbolic link, the entry
referenced by the link will be copied (not the symbolic link itself).
<LI>The FS service supports copying a file whose size is less than 4 GB on most
platforms, assuming the operating system supports the creation of large files, that is,
files larger than 2 GB.
</OL>
<P>
<P><H4><A NAME="Header_253">Syntax</A></H4>
<PRE>
COPY DIRECTORY &lt;Name&gt; &#91;TODIRECTORY &lt;Name&gt;&#93; &#91;TOMACHINE &lt;Machine&gt;&#93;
     &#91;NAME &lt;Pattern&gt;&#93; &#91;EXT &lt;Pattern&gt;&#93; &#91;CASESENSITIVE | CASEINSENSITIVE&#93;
     &#91;TEXTEXT &lt;Pattern&gt;... &#91;FORMAT &lt;Format&gt;&#93;&#93;
     &#91;RECURSE &#91;KEEPEMPTYDIRECTORIES | ONLYDIRECTORIES&#93;&#93;
     &#91;IGNOREERRORS&#93; &#91;FAILIFEXISTS | FAILIFNEW&#93;
</PRE>
<P><TT>DIRECTORY</TT> specifies the name of the source directory to copy. This option will resolve variables.
<P><TT>TODIRECTORY</TT> specifies the name of the destination directory.  This defaults
to the same, unresolved, name as specified in <TT>DIRECTORY</TT>. This option will resolve variables.  These
variables will be resolved on the target machine.
<P><TT>TOMACHINE</TT> specifies the machine to copy the directory and its contents to.
This defaults to the machine which originated the request.
Specifying <TT>local</TT> indicates to copy the directory and its contents to the same
machine that the directory is being copied from.
Note that specifying<TT> local </TT>instead of the from machine's host name can
significantly improve performance, especially if your TCP network performance
is slow.  This is because<TT> local </TT>(or<TT> local://local</TT>) indicates
to use the local network interface versus specifying a TCP host name or IP address
indicates to use the TCP network interface.  This option will resolve variables.
<P><TT>NAME</TT> specifies a pattern used to match the name of files in the specified
directory (and files in its subdirectories, if <TT>RECURSE</TT> is specified).
Only the files whose names match this pattern will be copied.
Match patterns may be specified using special characters '*' and/or '?' as wildcards.
The default pattern is "*".  This option will resolve variables.
<P><TT>EXT</TT> specifies a pattern used to match the extension of files in the specified
directory (and files in its subdirectories, if <TT>RECURSE</TT> is specified).
Only the files whose extensions match this pattern will be copied.
Match patterns may be specified using special characters '*' and/or '?' as wildcards.
The default pattern is "*".  This option will resolve variables.
<P><B>Note: </B>The COPY DIRECTORY command recognize the "name" (<TT>NAME</TT>)
portion of a filename as the character(s) that precede a period (or the entire
filename if it does not include a period) and the "extension" (<TT>EXT</TT>)
portion of a filename are character(s) that follow a period.
For example, for filename myfile.txt the "name" portion is "myfile" and
the "extension" portion is "txt".  To match filenames whose name begins
with "my" and whose extension is "txt", you could specify options
<TT>NAME my* EXT txt</TT>.
<P><TT>CASESENSITIVE</TT> specifies that the patterns specified by <TT>NAME</TT>,
<TT>EXT</TT>, and <TT>TEXTEXT</TT> are to be matched in a case sensitive manner.
<P><TT>CASEINSENSITIVE</TT> specifies that the patterns specified by <TT>NAME</TT>,
<TT>EXT</TT>, and <TT>TEXTEXT</TT> are to be matched in a case insensitive manner.
<P><B>Note: </B>If neither <TT>CASESENSITIVE</TT> nor <TT>CASEINSENSITIVE</TT> is
specified, the default is determined by the operating system -- unix systems
default to <TT>CASESENSITIVE</TT>, all others default to <TT>CASEINSENSITIVE</TT>.
Options <TT>CASESENSITIVE</TT> and <TT>CASEINSENSITIVE</TT> only have an effect if
you also specify a pattern to match using at least one of the following options:
<TT>NAME</TT>, <TT>EXT</TT>, or <TT>TEXTEXT</TT>.
<P><TT>TEXTEXT</TT> specifies a pattern used to match the extension of text files being 
copied.  The files whose extensions match this pattern should contain text, not binary
data.  The line-ending characters in the files being copied whose extensions match
this pattern will be converted as specified via the <TT>FORMAT</TT> option and
codepage conversion will be performed.
Multiple <TT>TEXTEXT</TT> patterns are handled as an "or" condition.
Match patterns may be specified using special characters '*' and/or '?' as wildcards.
This option will resolve variables.
<P><TT>FORMAT</TT> specifies the end-of-line character(s) to use.  This option will resolve variables.
See <A HREF="#HDRFSGETFILE">8.5.6, "GET FILE"</A> for more information on available formats.
<P><TT>RECURSE</TT> specifies that the subdirectories in <TT>DIRECTORY</TT> will be
recursively copied.
<P><TT>KEEPEMPTYDIRECTORIES</TT> specifies that the empty directories are also to be
created in the <TT>TODIRECTORY</TT> on the target.  The default behavior is to prune
the empty directories while copying files.
<P><TT>ONLYDIRECTORIES</TT> specifies that the directory (empty directories and no files
copied) structure is to be created in the <TT>TODIRECTORY</TT> on the target machine.
Using the <TT>NAME</TT>, <TT>EXT</TT>, <TT>CASESENSITIVE</TT> and
<TT>CASEINSENSITIVE</TT> options with the <TT>ONLYDIRECTORIES</TT> option will be
ignored as no files will be copied.
<P><TT>IGNOREERRORS</TT> specifies that errors encountered copying entries should not
be returned.  By default, all errors encountered while copying entries will be returned
in the result buffer.
<P><TT>FAILIFEXISTS</TT> specifies that the copy should fail if
<TT>TODIRECTORY</TT> already exists.  The default is to copy over the directory contents
if it exists.
<P><TT>FAILIFNEW</TT> specifies that the copy should fail if <TT>TODIRECTORY</TT>
does not already exist.  The default is to create the directory if it does not exist if
at least one file is copied.
<P>
<P><H4><A NAME="Header_254">Security</A></H4>
There can be up to three machines involved in a COPY DIRECTORY request
(and any of these machines can be the same machine):
<OL COMPACT TYPE=1>
<LI><TT>orgMachine</TT> - The machine that submitted (i.e. originated) the
COPY DIRECTORY request
<LI><TT>sourceMachine</TT> - The machine where the directory to be copied resides
(this is the machine to which you submitted the COPY DIRECTORY request)
<LI><TT>toMachine</TT> - The machine where the directory will be copied to
</OL>
<P>This command requires trust level 4 as follows:
<UL COMPACT>
<LI>The<TT> sourceMachine </TT>must give at least trust level 4 to the<TT> orgMachine</TT>.
<LI>The<TT> toMachine </TT>must give at least trust level 4 to the<TT> sourceMachine</TT>.
<LI>The<TT> toMachine </TT>must give at least trust level 4 to the<TT> orgMachine</TT>.
</UL>
<P>
An exception to these trust requirements is if the<TT> orgMachine </TT>is the same
as the<TT> toMachine </TT>and the<TT> STRICTFSCOPYTRUST </TT>operational setting
is disabled (which it is by default), then the<TT> toMachine </TT>does not have to
give trust level 4 to the<TT> sourceMachine</TT>.  See <A HREF="#HDROPPARMS">4.7, "Operational parameters"</A> for
more information on the<TT> STRICTFSCOPYTRUST </TT>operational parameter.
<P>
<P><H4><A NAME="Header_255">Return Codes</A></H4>
<P>All return codes from COPY DIRECTORY are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_256">Results</A></H4>
<P>
<UL>
<P><LI>On successful return, the result buffer will be empty.
<P>
<P><LI>If errors were encountered copying entries and <TT>IGNOREERRORS</TT>
was not specified, the result buffer will contain a
marshalled <TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/FS/ErrorInfo&gt;</TT> representing
a list of error information about the entries that were not successfully copied.
The map is defined as follows: 
<BR>
<P><B><A NAME="TBLFSERRORINFOTABLE">Table 15. Definition of map class STAF/Service/FS/ErrorInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents error information for an entry
in a directory.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">RC
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">osRC
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">OS RC
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The "Name" value will be the full path name of the entry that was not
copied successfully.
<LI>The "RC" value will be the STAF return code for the copy request error.
<LI>The "OS RC" value will be the operating system return code, if the STAF
return code indicated a base operating system error occurred (i.e. if RC == 10),
otherwise it will be <TT>&lt;None&gt;</TT>.
</OL>
</TD></TR></TABLE>
<P>
For example, if a copy directory request is submitted from the command line,
and two errors occurred during the copy, the result, in table format, could look like:
<PRE>
Name                RC OS RC
------------------- -- ------
c:\tmp\project.htm  17 &lt;None&gt;
c:\tmp\project5.xml 10 32
</PRE>
</UL>
<P>
<P><H4><A NAME="Header_257">Examples</A></H4>
<P>In the following examples, assume the command is being issued locally from
machine TestSrv1.
<P>
<UL>
<P><LI><B>Goal:</B> Copy directory c:/testcase from machine TestSrv1 to directory
c:/testcase on machine Client1
<BR>
<B>Syntax:</B>&nbsp; <TT>COPY DIRECTORY c:/testcase TOMACHINE Client1</TT>
<P>
<P><LI><B>Goal:</B> Copy directory c:/testcase and its subdirectories from machine TestSrv1
to directory c:/testcase on machine Client1.
<BR>
<B>Syntax:</B>&nbsp; <TT>COPY DIRECTORY c:/testcase TOMACHINE Client1 RECURSE</TT>
<P>
<P><LI><B>Goal:</B> Copy directory c:/testcase from machine TestSrv1 to directory d:/WebTests
on machine Client1.  Don't overwrite the directory if it exists.
<BR>
<B>Syntax:</B>&nbsp;
<TT>COPY DIRECTORY c:/testcase TODIRECTORY d:/WebTests TOMACHINE Client1 FAILIFEXISTS</TT>
<P>
<P><LI><B>Goal:</B> Copy all files with an extension of "tmp" in directory c:/testcase to
directory c:/testcase on machine Client1.  Match the extension in a case insensitive
manner.  Do not recurse down subdirectories.
<BR>
<B>Syntax:</B>&nbsp;
<TT>COPY DIRECTORY c:/testcase TOMACHINE Client1 EXT tmp CASEINSENSITIVE</TT>
<P>
<P><LI><B>Goal:</B> Copy all files that have no extension (e.g. like "file1") that
reside in directory c:/testcase to directory c:/testcase on machine Client1.
Do not recurse down subdirectories.  Note that you must use the length delimited format, 
<TT>:0&#58;</TT>, to indicate an empty string for the EXT option because if you specify
no value or "", then the STAF command parser thinks that no value was specified for the
EXT option and this will cause an "Invalid Request String" error (RC 7) since the EXT
option requires a value.
<BR>
<B>Syntax:</B>&nbsp;
<TT>COPY DIRECTORY c:/testcase TOMACHINE Client1 EXT :0: </TT>
<P>
<P><LI><B>Goal:</B> Recursively copy all files under {MyTempDirectory} with a base name beginning
with "test" to directory {MyTempDirectory} on machine Client1.  Match the file names in a
case sensitive manner.  Do not report any errors during the copying.
<BR>
<B>Syntax:</B>&nbsp;
<TT>COPY DIRECTORY {MyTempDirectory} TOMACHINE Client1 NAME "test*" CASESENSITIVE RECURSE IGNOREERRORS</TT>
</UL>
<P>
In the following examples, assume the command is being issued locally from
machine TestSrv1 and the following directory structures exist under the c:/testcase directory:
<PRE>
  c:\testcase
  c:\testcase\error.txt
  c:\testcase\web.exe
  c:\testcase\web.txt
  c:\testcase\web.xml
  c:\testcase\subdir
  c:\testcase\subdir\subdir_1
  c:\testcase\subdir\subdir_2
  c:\testcase\subdir\subdir_2\readme.txt
</PRE>
<P>
<UL>
<P><LI><B>Goal:</B> Copy directory c:/testcase and its subdirectories, including empty subdirectories,
from machine TestSrv1 to directory c:/testcase on machine Client1.
<BR>
<B>Syntax:</B>&nbsp; <TT>COPY DIRECTORY c:/testcase TOMACHINE Client1 RECURSE KEEPEMPTYDIRECTORIES</TT>
<P>The expected result is that the following entries exist on machine Client1:
<PRE>
  c:\testcase
  c:\testcase\error.txt
  c:\testcase\web.exe
  c:\testcase\web.txt
  c:\testcase\web.xml
  c:\testcase\subdir
  c:\testcase\subdir\subdir_1
  c:\testcase\subdir\subdir_2
  c:\testcase\subdir\subdir_2\readme.txt
</PRE>
<P>
<P><LI><B>Goal:</B> Copy directory c:/testcase and its subdirectories from machine TestSrv1 to
directory c:\testcase on machine Client1.  However, do not copy any files.
<BR>
<B>Syntax:</B>&nbsp; <TT>COPY DIRECTORY c:/testcase TOMACHINE Client1 RECURSE ONLYDIRECTORIES</TT>
<P>The expected result is that the following entries were created on machine Client1:
<PRE>
  c:\testcase
  c:\testcase\subdir
  c:\testcase\subdir\subdir_1
  c:\testcase\subdir\subdir_2
</PRE>
<P>
<P><LI><B>Goal:</B> Copy all files from machine TestSrv1 in directory c:/testcase
whose name is 'web' to directory /testcase on machine Client1.
Convert the line-ending characters in the files whose extensions are
'txt' or 'xml' (as they are considered to be text files) to the
line-ending characters for machine Client1's platform. 
<P>
<B>Syntax:</B>&nbsp;
Note that both of these <TT>COPY DIRECTORY</TT> examples are equivalent.
<PRE>
COPY DIRECTORY c:/testcase TODIRECTORY /testcase TOMACHINE Client1
     NAME web TEXTEXT txt TEXTEXT xml
     
COPY DIRECTORY c:/testcase TODIRECTORY /testcase TOMACHINE Client1
     NAME web TEXTEXT txt TEXTEXT xml FORMAT Native
</PRE>
<P>The expected result is that the following entries were created on machine Client1.
Note that error.txt was not copied since its name is not 'web'.
<PRE>
  /testcase
  /testcase/web.exe
  /testcase/web.txt
  /testcase/web.xml
</PRE>
<P>
<P><LI><B>Goal:</B> Copy all .txt files from machine TestSrv1 in directory c:/testcase,
and it's subdirectories, to directory /testcase on
machine Client1.  Convert the line-ending characters in all the files being copied
(as they are considered to be text files) to the line-ending characters for machine
Client1's platform.
<P>
<B>Syntax:</B>&nbsp;
Note that both of these <TT>COPY DIRECTORY</TT> examples are equivalent.
<PRE>
COPY DIRECTORY c:/testcase TODIRECTORY /testcase TOMACHINE Client1
     EXT txt TEXTEXT "*" RECURSE
     
COPY DIRECTORY c:/testcase TODIRECTORY /testcase TOMACHINE Client1
     EXT txt TEXTEXT txt FORMAT Native RECURSE
</PRE>
<P>The expected result is that the following entries were created on machine Client1.
<PRE>
  /testcase
  /testcase/error.txt
  /testcase/subdir
  /testcase/subdir/subdir_2
  /testcase/subdir/subdir_2/readme.txt
</PRE>
</UL>
<P>
In the following examples, assume the command is being issued to machine
Client1 from machine TestSrv1.
<P>
<UL>
<P><LI><B>Goal:</B> Retrieve all files in directory d:\WebTests\Logs from Client1 and store
them in directory f:\Logs on machine TestSrv1.  Do not copy its subdirectories.
<BR>
<B>Syntax:</B>&nbsp; <TT>COPY DIRECTORY d:/WebTests/Logs TODIRECTORY f:/Logs</TT>
<P>
<P><LI><B>Goal:</B> Copy directory d:\WebTests\Logs and its non-empty subdirectories from 
Client1 to directory h:\Logs on server LogSrv.
<BR>
<B>Syntax:</B>&nbsp; <TT>COPY DIRECTORY d:/WebTests/Logs TODIRECTORY h:/Logs TOMACHINE LogSrv RECURSE</TT>
<P>
<P><LI><B>Goal:</B> Copy directory d:\WebTests\Logs and its non-empty subdirectories from
Client1 to directory h:\Logs on Client1.
<BR>
<B>Syntax:</B>&nbsp; <TT>COPY DIRECTORY d:/WebTests/Logs TODIRECTORY h:/Logs TOMACHINE local RECURSE</TT>
<P>
<P><LI><B>Goal:</B> Copy all *.cmd files in the root of the boot drive from Client1 to the
root of the boot drive of machine TestSrv1.
<BR>
<B>Syntax:</B>&nbsp; <TT>COPY DIRECTORY {STAF/Config/BootDrive}\ EXT cmd</TT>
<P>
<P><LI><B>Goal:</B> Copy all *.log files in directory C:\mytests from Client1 to the
directory D:\tests on Client1.
<BR>
<B>Syntax:</B>&nbsp; <TT>COPY DIRECTORY C:/mytests EXT log TODIRECTORY D:/tests TOMACHINE local</TT>
</UL>
<A NAME="IDX283"></A>
<P><H3><A NAME="Header_258">8.5.4 MOVE FILE</A></H3>
<P>MOVE FILE allows you to rename a file or move files from one directory
to another directory on a machine.
<P>
<P><H4><A NAME="Header_259">Notes:</A></H4>
<OL COMPACT TYPE=1>
<LI>A file moved via the FS service retains its system or extended attributes.
<LI>The FS service uses the operating system's move command to move files.
If moving a file on Windows, the 'move' command is used.
If moving a file on Unix, the 'mv' command is used.
</OL>
<P>
<P><H4><A NAME="Header_260">Syntax</A></H4>
<PRE>
MOVE FILE &lt;Name&gt; &lt;TOFILE &lt;Name&gt; | TODIRECTORY &lt;Name&gt;&gt;
</PRE>
<P><TT>FILE</TT> specifies the name of the file to move/rename.
You may specify wildcards using '*' to move multiple files from one directory
to another directory. This option will resolve variables.
<P><TT>TOFILE</TT> specifies the new name of the file.
The directory path specified must already exist, or else the move request
will fail (e.g. if specify C:\Tests\Test1\test1.exe, directory C:\Tests\Test1
must already exist).  Existing destination files will be overwritten. This option will resolve variables.,
<P><TT>TODIRECTORY</TT> specifies the name of the directory to move the
file(s) to.  This directory must already exist.
Existing destination files will be overwritten. This option will resolve variables.
<P>
<P><H4><A NAME="Header_261">Security</A></H4>
<P>This command requires trust level 4
<P>
<P><H4><A NAME="Header_262">Return Codes</A></H4>
<P>All return codes from MOVE FILE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_263">Results</A></H4>
<P>If successful, the result buffer will contain no data or may contain
information about the files moved (e.g. if a wildcard is specified in
the <TT>FILE</TT> value).
If the request failed, the result buffer may contain information about
the error.
<P>
<P><H4><A NAME="Header_264">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Rename file C:\testcase\test1.exe to file C:\testcase\test2.exe,
overwriting the file if it exists.
<P>
<B>Syntax:</B>&nbsp; <TT>MOVE FILE C:\testcase\test1.exe TOFILE C:\testcase\test2.exe</TT>
<P>
<P><LI><B>Goal:</B> Move file test1.exe from directory C:\testcase to 
directory C:\testcase\TestDir, overwriting the file if it exists.
<P>
<B>Syntax:</B>&nbsp; <TT>MOVE FILE C:\testcase\test1.exe TODIRECTORY C:\testcase\TestDir</TT>
<P>
<P><LI><B>Goal:</B> Move all files that begin with "test" and have extension txt
from directory C:\testcase to directory D:\Saved_Tests.
<P>
<B>Syntax:</B>&nbsp; <TT>MOVE FILE C:\testcase\test*.txt TODIRECTORY D:\Saved_Tests</TT>
<P>
<P><LI><B>Goal:</B> Move file startup.cmd on the boot drive to drive E:.
<P>
<B>Syntax:</B>&nbsp; <TT>MOVE FILE {STAF/Config/BootDrive}\startup.cmd TODIRECTORY E:\</TT>
<P>
<P><LI><B>Goal</B> Rename file /tmp/testcase/test1.sh to file /opt/MyTests/test1.sh,
overwriting the file if it exists.
<P>
<B>Syntax:</B>&nbsp; <TT>MOVE FILE /tmp/testcase/test1.sh TOFILE /opt/MyTests/test1.sh</TT>
</UL>
<A NAME="IDX286"></A>
<P><H3><A NAME="Header_265">8.5.5 MOVE DIRECTORY</A></H3>
<P>MOVE DIRECTORY allows you to rename a directory on a machine.
<P>
<P><H4><A NAME="Header_266">Notes:</A></H4>
<OL COMPACT TYPE=1>
<LI>A file moved via the FS service retains its system or extended attributes.
<LI>The FS service uses the operating system's move command to move files.
If moving a file on Windows, the 'move' command is used.
If moving a file on Unix, the 'mv' command is used.
</OL>
<P>
<P><H4><A NAME="Header_267">Syntax</A></H4>
<PRE>
MOVE DIRECTORY &lt;Name&gt; TODIRECTORY &lt;Name&gt;
</PRE>
<P><TT>DIRECTORY</TT> specifies the name of the directory to move. This option will resolve variables.
<P><TT>TODIRECTORY</TT> specifies the name of the directory to move the
directory to.  If this directory does not already exist, the directory will
be renamed to it.  If this directory already exists, the directory will be moved
to a new subdirectory within it.
The path to the directory must already exist, or else the move request will
fail (e.g. if specify C:\Tests\Test1, directory C:\Tests must already exist). 
This option will resolve variables.
<P>
<P><H4><A NAME="Header_268">Security</A></H4>
<P>This command requires trust level 4
<P>
<P><H4><A NAME="Header_269">Return Codes</A></H4>
<P>All return codes from MOVE DIRECTORY are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_270">Results</A></H4>
<P>If successful, the result buffer will contain no data or may contain
information about the files moved.
If the request failed, the result buffer may contain information about
the error.
<P>
<P><H4><A NAME="Header_271">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Rename directory C:\testcase to a new directory named
C:\MyTestcases.
<P>
<B>Syntax:</B>&nbsp; <TT>MOVE DIRECTORY C:\testcase TODIRECTORY C:\MyTestcases</TT>
<P>
<P><LI><B>Goal:</B> Move directory Test1 from directory C:\testcase to 
directory "D:\My Testcases".
<P>
<B>Syntax:</B>&nbsp; <TT>MOVE DIRECTORY C:\testcase\Test1 TODIRECTORY "D:\My Testcases"</TT>
<P>
If directory "D:\My Testcases" exists, the directory will be renamed
to "D:\My Testcases\Test1" (assuming a directory named Test1 does not
already exist in "D:\My Testcases").  If directory "C:\My Testcases" does not
exist, the directory will be renamed to "D:\My Testcases".
<P>
<P><LI><B>Goal:</B> Move directory mydir on the boot drive to drive E:.
<P>
<B>Syntax:</B>&nbsp; <TT>MOVE DIRECTORY {STAF/Config/BootDrive}/mydir TODIRECTORY E:\</TT>
</UL>
<A NAME="IDX289"></A>
<P><H3><A NAME="HDRFSGETFILE">8.5.6 GET FILE</A></H3>
<P>GET FILE retrieves the contents of a text file.
<P>Notes:
<OL TYPE=1>
<P><LI>If the file specified is a symbolic link, the contents of the entry
referenced by the link will be retrieved.
<P>
<P><LI>Since the entire content of a returned file is stored in the result
string, if you attempt to get the contents of a very large file, you may
run out of memory so using the GET FILE request is not recommended for
large files.  To help prevent this problem, you can specify a maximum size
for a file returned by this request by setting the MAXRETURNFILESIZE
operational parameter in the STAF configuration file on the machine where
the file resides, or by setting the STAF/MaxReturnFileSize variable in the
request variable pool of the handle that submitted the request.
The lowest of these two values is used as the maximum return file size
(not including 0 which indicates no limit).
</OL>
<P>
<P><H4><A NAME="Header_273">Syntax</A></H4>
<PRE>
GET FILE &lt;FileName&gt; &#91;&#91;TEXT | BINARY&#93; &#91;FORMAT &lt;Format&gt;&#93;&#93;
</PRE>
<P><TT>FILE</TT> specifies the name of the text file to get. This option will resolve variables.
<P><TT>TEXT</TT> specifies to convert line-ending characters in the file being
retrieved as specified via the <TT>FORMAT</TT> option and to perform codepage conversion.
This option should only be specified for a text file, not a binary file.
This is the default.
<P><TT>BINARY</TT> specifies to retrieve the contents of the file in binary.
<P><TT>FORMAT</TT> specifies the format of the file's contents.  This option will resolve variables.
<UL>
<P><LI>If the <TT>TEXT</TT> option is specified, the following formats are supported&#58;
<P>
<UL COMPACT>
<LI><TT>NATIVE</TT> specifies to convert line-ending characters in the file(s)
to those of the target machine so that the line-ending characters are appropriate
to the target platform.  This is the default.
<LI><TT>UNIX</TT> specifies to converts line-ending characters in the file(s)
to the line-ending characters for Unix.
<LI><TT>WINDOWS</TT> specifies to convert line-ending characters in the file(s)
to the line-ending characters for Windows.
<LI><TT>ASIS</TT> specifies that no conversion of line-ending characters in the file
be done.  This value is only supported for a <TT>GET FILE</TT> request.
Note that prior to STAF V2.5, this was the default (as the <TT>TEXT</TT> option was not
yet implemented).
<LI><TT>&lt;String&gt;</TT> specifies to convert line-ending characters in the file(s)
to the specified string.
</UL>
<P><LI>If the <TT>BINARY</TT> option is specified, the following formats are supported&#58;
<P>
<UL COMPACT>
<LI><TT>Hex</TT> - Converts the contents of the file to a Hex representation.
</UL>
</UL>
<P>
<P><H4><A NAME="Header_274">Security</A></H4>
<P>This command requires trust level 4.
<P>
<P><H4><A NAME="Header_275">Return Codes</A></H4>
<P>All return codes from GET FILE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P>Notes:
<P>
<OL TYPE=1>
<P><LI>If return code 58 (Maximum Size Exceeded) is returned, that indicates that
the file size exceeded the maximum return file size specified.
<P>
<P><LI>If return code 39 (Converter Error) is returned,
see section <A HREF="#HDRFSGETFILECONVERTERERROR">2.7.2, "Codepage Converter Error on a FS GET FILE Request"</A> for more information on this error.
</OL>
<P>
<P><H4><A NAME="Header_276">Results</A></H4>
<P>On successful return, the result buffer will contain the contents of the
specified file.
<P>
<P><H4><A NAME="Header_277">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Retrieve the contents of the CONFIG.SYS file as text.
Convert any line-ending characters to those of the platform of the machine
making the request.
<BR>
<B>Syntax:</B>&nbsp;  Note that all of these <TT>GET FILE</TT> examples are equivalent.
<PRE>
GET FILE {STAF/Config/BootDrive}/CONFIG.SYS
GET FILE {STAF/Config/BootDrive}/CONFIG.SYS TEXT
GET FILE {STAF/Config/BootDrive}/CONFIG.SYS TEXT FORMAT Native
</PRE>
<P>
<P><LI><B>Goal:</B> Retrieve the contents of the STAF configuration file as text.
Convert any line-ending characters in the file being retrieved to the
line-ending characters for Unix.
<BR>
<B>Syntax:</B>&nbsp;
<TT>GET FILE {STAF/Config/STAFRoot}/bin/STAF.cfg TEXT FORMAT Unix</TT>
<P>
<P><LI><B>Goal:</B> In this example, assume the command is being issued to
a Unix machine from a Windows machine.  Retrieve the contents of file
/testcases/test1.txt as text and convert the line-ending characters to the 
line-ending characters for Windows.
<BR>
<B>Syntax:</B>&nbsp;
<TT>GET FILE /testcases/test1.txt TEXT FORMAT Windows</TT>
<P>
<P><LI><B>Goal:</B> Retrieve the contents of file /testcases/test1.txt as text and
convert the line-ending characters to a space.
<BR>
<B>Syntax:</B>&nbsp;
<TT>GET FILE /testcases/test1.txt TEXT FORMAT " "</TT>
<P>
<P><LI><B>Goal:</B> Retrieve the contents of file c:/testcases/test1.cmp in binary
and display its contents in hex.
<BR>
<B>Syntax:</B>&nbsp;
Note that both of these <TT>GET FILE</TT> examples are equivalent.
<PRE>
GET FILE c:/testcases/test1.cmp BINARY
GET FILE c:/testcases1/test1.cmp BINARY FORMAT HEX
</PRE>
</UL>
<A NAME="IDX292"></A>
<P><H3><A NAME="HDRFSGETE">8.5.7 GET ENTRY</A></H3>
<P>GET ENTRY retrieves an attribute of a file system entry, such as its type,
size, last modification time, link target, or checksum.
<P>
<P><H4><A NAME="Header_279">Syntax</A></H4>
<PRE>
GET ENTRY &lt;Name&gt; &lt;TYPE | SIZE | MODTIME | LINKTARGET | CHECKSUM [&lt;Algorithm&gt;]&gt;
</PRE>
<P><TT>ENTRY</TT> specifies the name of the file system entry for which to
retrieve an attribute. This option will resolve variables.
<P><TT>TYPE</TT> specifies the type of the file system entry should be
retrieved.
<P><TT>SIZE</TT> specifies the size of the file system entry should be
retrieved.  Note that if the file system entry is a directory, it retrieves
the size of only the directory entry, not the total size of all the entries
within the directory.  To get the total size of a directory, use the FS
service's LIST DIRECTORY request with the SUMMARY option.
<P><TT>MODTIME</TT> specifies the last modification time of the file
system entry should be retrieved.
<P><TT>LINKTARGET</TT> specifies the link target for the file system
entry should be retrieved.  If the file system entry is not a symbolic link,
<TT>&lt;None&gt;</TT> will be returned.
<P><TT>CHECKSUM</TT> specifies to calculate a fixed-size checksum of the
file system entry and return its value in a hexadecimal form.
Getting a file's checksum is a simple way to check to see that a file has
not been tampered with or to verify that a file has been downloaded or
copied correctly.  You may optionally specify the cryptographic hashing
algorithm used to produce a unique checksum for any file.  The following
algorithms are supported: MD2, MD4, MD5, RIPEMD160, SHA, SHA1
(case-insensitive).  The default is MD5.
Note that SHA1 (160 bits) and RIPEMD160 (160 bits) are considered more
current and more secure than MD5 (128 bits), but MD5 is still widely used.
You cannot retrieve the checksum for a directory.  This option will resolve variables.
<P>If the file system entry is a symbolic link, information about the entry
referenced by the link (e.g. the link target) will be provided.  This includes
the type, size, last modification time, or checksum of the link target.
<P>
<P><H4><A NAME="Header_280">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_281">Return Codes</A></H4>
<P>All return codes from GET ENTRY are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_282">Results</A></H4>
<P>On successful return, the contents of the result buffer will depend on the
attribute type requested.
<P>
<UL>
<P><LI>If the <TT>TYPE</TT> option is specified, the result buffer
will contain one of the following letters:
<BR>
<P><B><A NAME="Table_16">Table 16. File System Entry Types Reference</A></B><BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">Type identifier
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Description
</TH></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">F
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">File
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">D
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Directory
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">P
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Pipe
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">S
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Socket
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">B
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Block device
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">C
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Character device
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">O
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Other undefined type
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="33%">?
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="67%">Unknown type
</TD></TR></TABLE>
<P>
<P><LI>If the <TT>SIZE</TT> option is specified, the result buffer will contain
a marshalled <TT>&lt;Map&#58;STAF/Service/FS/SizeInfo&gt;</TT> representing
the 64-bit size of the file system entry.
The map is defined as follows: 
<BR>
<P><B><A NAME="Table_17">Table 17. Definition of map class STAF/Service/FS/SizeInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the 64-bit size of
the file system entry.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">upperSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Upper 32-bit Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">lowerSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Lower 32-bit Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
The "Size" value is the 64-bit size of the file system entry in bytes.
The "Upper 32-bit Size" and "Lower 32-bit Size" values are provided for
historical reasons as the "Size" value wasn't added until STAF V3.3.5.
They represent the upper 32-bits of the size and the lower 32-bits of
the size in bytes.  Note that if the size &lt; 4,294,967,296 bytes (aka 4G),
the upper 32-bit size will be 0 and the lower 32-bit size will be the
same as the size field.
</TD></TR></TABLE>
<P>
<P><LI>If the <TT>MODTIME</TT> option is specified, the result buffer will
contain the last modification time of the file system entry in a string with
format <TT>YYYYMMDD-HH&#58;MM&#58;SS</TT>
<P>
<P><LI>If the <TT>LINKTARGET</TT> option is specified, the result buffer will
contain the link target for the file system entry.  If the file system entry
is not a symbolic link, string <TT>&lt;None&gt;</TT> will be returned.
<P>
<P><LI>If the <TT>CHECKSUM</TT> option is specified, the result buffer will
contain the checksum for the file in hexadecimal form.
</UL>
<P>
<P><H4><A NAME="Header_283">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Retrieve the type of the file system entry
C&#58;\Stuff\WhatIsIt.d
<BR>
<B>Syntax:</B>&nbsp; <TT>GET ENTRY C&#58;\Stuff\WhatIsIt.d TYPE</TT>
<BR>
<B>Results:</B>
<PRE>
F
</PRE>
<P>
<P><LI><B>Goal:</B> Retrieve the last modification time of the file system entry
{STAF/Config/BootDrive}\CONFIG.SYS
<BR>
<B>Syntax:</B>&nbsp; <TT>GET ENTRY {STAF/Config/BootDrive}\CONFIG.SYS MODTIME</TT>
<BR>
<B>Results:</B>
<PRE>
20040512-18:07:52
</PRE>
<P>
<P><LI><B>Goal:</B> Retrieve the size of the file system entry /test1/projectX.tar
<BR>
<B>Syntax:</B>&nbsp; <TT>GET ENTRY /test1/projectX.tar SIZE</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
Size             : 340488704
Upper 32-bit Size: 0
Lower 32-bit Size: 340488704
</PRE>
<P>
<P><LI><B>Goal:</B> Retrieve the size of the file system entry /test/myproject.zip
which is &gt; 4G in size
<BR>
<B>Syntax:</B>&nbsp; <TT>GET ENTRY /test/myproject.zip SIZE</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
Size             : 4800000000
Upper 32-bit Size: 1
Lower 32-bit Size: 505032704
</PRE>
<P>
<P><LI><B>Goal:</B> Retrieve the link target of the file system entry
/usr/local/staf/bin/staf which is a symbolic link
<BR>
<B>Syntax:</B>&nbsp; <TT>GET ENTRY /usr/local/staf/bin/staf LINKTARGET</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
/usr/local/staf/bin/STAF
</PRE>
<P>
<P><LI><B>Goal:</B> Retrieve the MD5 checksum of file C:/STAF/bin/STAF.cfg
<BR>
<B>Syntax:</B>&nbsp; <TT>GET ENTRY C:/STAF/bin/STAF.cfg CHECKSUM MD5</TT>
<BR>
<B>Results:</B>
<PRE>
3F6C5A05CA3E7422C57851CAFA223FA2
</PRE>
<P>
<P><LI><B>Goal:</B> Retrieve the SHA-1 checksum of file C:/STAF/bin/STAF.cfg
<BR>
<B>Syntax:</B>&nbsp; <TT>GET ENTRY C:/STAF/bin/STAF.cfg CHECKSUM SHA1</TT>
<BR>
<B>Results:</B>
<PRE>
83B4F130E213D61AE6BB393FA9AEE711CC9FF91B
</PRE>
</UL>
<A NAME="IDX295"></A>
<P><H3><A NAME="Header_284">8.5.8 QUERY</A></H3>
<P>QUERY retrieves all associated attributes of a file system entry.
<P>
Note that if the file system entry queried is a symbolic link, information
about the entry referenced by the link will be retrieved.
<P>
<P><H4><A NAME="Header_285">Syntax</A></H4>
<PRE>
QUERY ENTRY &lt;Name&gt;
</PRE>
<P><TT>ENTRY</TT> specifies the name of the file system entry to query.
This option will resolve variables.
<P>
<P><H4><A NAME="Header_286">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_287">Return Codes</A></H4>
<P>All return codes from QUERY are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_288">Results</A></H4>
<P>
On successful return, the result buffer for a <TT>QUERY</TT> request
will contain a marshalled <TT>&lt;Map&#58;STAF/Service/FS/QueryInfo&gt;</TT>
representing information about the file system entry attributes.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_18">Table 18. Definition of map class STAF/Service/FS/QueryInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information about
a file system entry attributes.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">linkTarget
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Link Target
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">upperSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Upper 32-bit Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">lowerSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Lower 32-bit Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">lastModifiedTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Modified Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
The values for "Link Target", "Type", "Size", "Upper 32-bit Size", "Lower 32-bit Size", 
and "Last Modification Time" are formatted as specified
in section <A HREF="#HDRFSGETE">8.5.7, "GET ENTRY"</A>.
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_289">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Retrieve the attributes for the file system entry
/tests/project.tar.gz
<BR>
<B>Syntax:</B>&nbsp; <TT>QUERY ENTRY /tests/project.tar.gz</TT>
<BR>
<B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
Name              : /tests/project.tar.gz
Link Target       : &lt;None&gt;
Type              : F
Size              : 340488704
Upper 32-bit Size : 0
Lower 32-bit Size : 340488704
Modified Date-Time: 20080512-18:07:52
</PRE>
<P>
<P><LI><B>Goal:</B> Retrieve the attributes for the file system entry
C:\tests\myproject.zip whose size is &gt; 4G
<BR>
<B>Syntax:</B>&nbsp; <TT>QUERY ENTRY C:/tests/myproject.zip</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
Name              : C:/tests/myproject.zip
Link Target       : &lt;None&gt;
Type              : F
Size              : 4800000000
Upper 32-bit Size : 1
Lower 32-bit Size : 505032704
Modified Date-Time: 20090712-08:30:01
</PRE>
<P>
<P><LI><B>Goal:</B> Retrieve the attributes for the file system entry
/usr/local/staf/bin/staf which is a symbolic link
<BR>
<B>Syntax:</B>&nbsp; <TT>QUERY ENTRY /usr/local/staf/bin/staf</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
Name              : /usr/local/staf/bin/staf
Link Target       : /usr/local/staf/bin/STAF
Type              : F
Size              : 91098
Upper 32-bit Size : 0
Lower 32-bit Size : 91098
Modified Date-Time: 20090708-21:43:11
</PRE>
</UL>
<A NAME="IDX298"></A>
<P><H3><A NAME="Header_290">8.5.9 LIST DIRECTORY</A></H3>
<P>LIST DIRECTORY lists the selected contents of a directory, or provides
summary information for the selected contents of a directory (e.g. total
size, number of files and subdirectories).
<P><H4><A NAME="Header_291">Syntax</A></H4>
<PRE>
LIST DIRECTORY &lt;Name&gt; &#91;RECURSE&#93; &#91;LONG &#91;DETAILS&#93; | SUMMARY&#93; &#91;TYPE &lt;Types&gt;&#93;
     &#91;NAME &lt;Pattern&gt;&#93; &#91;EXT &lt;Pattern&gt;&#93; &#91;CASESENSITIVE | CASEINSENSITIVE&#93;
     &#91;SORTBYNAME | SORTBYSIZE | SORTBYMODTIME&#93;     
</PRE>
<P><TT>DIRECTORY</TT> specifies the name of the directory to list. This option will resolve variables.
<P><TT>RECURSE</TT> specifies that any subdirectories will be recursively listed.
<P><TT>LONG</TT> specifies to list the selected contents of the directory
in a long format.  That is, the list of child entries should include their
name, type, size, last modification time, and link target.  By default, it
returns a list that only includes the name of the entry if neither the
<TT>LONG</TT> nor <TT>SUMMARY</TT> option is specified.
<P><TT>DETAILS</TT> specifies to provide more details about the child entries
in the list.  Specifically, the upper 32-bit size and lower 32-bit size will be
shown in separate fields and the size will be shown in bytes instead of rounding
the size in kilobytes or megabytes.
<P><TT>SUMMARY</TT> specifies to provide only a summary of the selected contents
of the directory including its total size in bytes, number of files, and number of
subdirectories.
<P><TT>TYPE</TT> specifies the types of child entries to return.  These types
are the same types described in section <A HREF="#HDRFSGETE">8.5.7, "GET ENTRY"</A>, with the addition
of '!', which, when specified along with 'D', includes the special directories
'.' and '..'.  You may also specify the string "ALL" to include all entry types.
By default, only files and non-special directories are included.  This option will resolve variables.
<P><TT>NAME</TT> specifies a pattern used to match the name of child entries
in the specified directory (and child entries in its subdirectories, if the
<TT>RECURSE</TT> option is specified).  Only child entries whose name match
this pattern will be listed.  Match patterns may be specified using special
characters '*' and/or '?' as wildcards.  The default pattern is "*".  This option will resolve variables.
<P><TT>EXT</TT> specifies a pattern used to match the extension of child entries
in the speciifed directory (and child entries in its subdirectories if the
<TT>RECURSE</TT> option is specified).  Only child entries whose extension match
this pattern will be listed.  Match patterns may be specified using special
characters '*' and/or '?' as wildcards.  The default pattern is "*". This option will resolve variables.
<P><B>Note: </B>The LIST DIRECTORY command recognizes the "name" (<TT>NAME</TT>)
portion of a filename as the character(s) that precede a period (or the entire
filename if it does not include a period) and the "extension" (<TT>EXT</TT>)
portion of a filename are character(s) that follow a period.
For example, for filename myfile.txt the "name" portion is "myfile" and
the "extension" portion is "txt".  To match filenames whose name begins
with "my" and whose extension is "txt", you could specify options
<TT>NAME my* EXT txt</TT>.
<P><TT>CASESENSITIVE</TT> specifies that the patterns specified by
<TT>NAME</TT> and <TT>EXT</TT> are to be matched in a case sensitive manner.
It also affects the sorting performed by <TT>SORTBYNAME</TT>.
<P><TT>CASEINSENSITIVE</TT> specifies that the patterns specified by
<TT>NAME</TT> and <TT>EXT</TT> are to be matched in a case insensitive
manner.  It also affects the sorting performed by <TT>SORTBYNAME</TT>.
<P><B>Note: </B>If neither <TT>CASESENSITIVE</TT> nor <TT>CASEINSENSITIVE</TT> is
specified, the default is determined by the operating system -- unix systems
default to <TT>CASESENSITIVE</TT>, all others default to
<TT>CASEINSENSITIVE</TT>.
<P><TT>SORTBYNAME</TT> specifies that the list of child entries should be
sorted by their name.
<P><TT>SORTBYSIZE</TT> specifies that the list of child entries should be
sorted by their size.
<P><TT>SORTBYMODTIME</TT> specifies that the list of child entries should be
sorted by their last modification time.
<P><B>Note: </B>If none of the sorting options is used, the default is not to sort the
list.  It will be in the same order as returned by the operating system, which
is not guaranteed to perform any sorting of its own.
<P>
<P><H4><A NAME="Header_292">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_293">Return Codes</A></H4>
<P>All return codes from LIST DIRECTORY are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_294">Results</A></H4>
<P>On successful return, the result buffer will contain the contents of the
specified directory as follows:
<UL>
<P><LI>If neither the <TT>LONG</TT> nor the <TT>SUMMARY</TT> option is specified,
the result buffer will contain a marshalled <TT>&lt;List&gt; of &lt;String&gt;</TT>
representing the names of the matching entries in the specified directory.
<P>
<P><LI>If the <TT>LONG</TT> option is specified without the <TT>DETAILS</TT>
option, the result buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/FS/ListLongInfo&gt;</TT> representing
information about each entry in the file, including name, type, size,
date-time last modified, and link target.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_19">Table 19. Definition of map class STAF/Service/FS/ListLongInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information about an entry
in a specified directory.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">lastModifiedTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Modified Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">linkTarget
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Link Target
<BR>
(Link)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The "Size" value contains the 64-bit size in human-readable form where
the size will be shown in bytes, or in kilobytes using the extension
'K', or in megabytes using the extension 'M'.
<LI>The "Link Target" value specifies the link target for an entry.
If the entry is not a symbolic link, it will be set to <TT>&lt;None&gt;</TT>.
<LI>If the entry is a symbolic link, information about the entry referenced
by the link (e.g. the link target) will be provided.  This includes the type,
size, and last modification time of the link target.
</OL>
</TD></TR></TABLE>
<P>
<P><LI>If the <TT>LONG</TT> and <TT>DETAILS</TT> options are specified,
the result buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/FS/ListDetailsInfo&gt;</TT> representing
detailed information about each entry in the file, including name, type, size,
date-time last modified, and link target.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_20">Table 20. Definition of map class STAF/Service/FS/ListDetailsInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents detailed information about
an entry in a specified directory.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">linkTarget
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Link Target
<BR>
(Link)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">upperSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">U-Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">lowerSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">L-Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">lastModifiedTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Modified Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The "Link Target" value specifies the link target for an entry.
If the entry is not a symbolic link, it will be set to <TT>&lt;None&gt;</TT>.
<LI>If the entry is a symbolic link, information about the entry referenced
by the link (e.g. the link target) will be provided.  This includes the type,
size, and last modification time of the link target.
<LI>The "Size" value is the 64-bit size of the file system entry in bytes.
The "U-Size" and "L-Size" values are provided for historical reasons as
the "Size" value wasn't added until STAF V3.3.5.  They represent the
upper 32-bits of the size and the lower 32-bits of the size in bytes.
Note that if the size &lt; 4,294,967,296 bytes (aka 4G), the upper 32-bit size
will be 0 and the lower 32-bit size will be the same as the size field.
</OL>
</TD></TR></TABLE>
<P>
<P><LI>If the <TT>SUMMARY</TT> option is specified, the result buffer will
contain a marshalled <TT>&lt;Map&#58;STAF/Service/FS/ListSummaryInfo&gt;</TT>
representing summarized information about the matching entries in the
directory including total size, number of files, and number of subdirectories.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_21">Table 21. Definition of map class STAF/Service/FS/ListSummaryInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents summary information about
the matching entries in a specified directory.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">numFiles
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Files
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">numDirectories
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Directories
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The "Name" value is the resolved name of the directory being listed.
<LI>The "Size" value is the total size in bytes of all the entries
in the directory that match the specified criteria.
<LI>The "Files" value is the total number of files in the directory that match
the specified criteria.
<LI>The "Directories" value is the total number of subdirectories in the
specified directory that match the specified criteria.
</OL>
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_295">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> List the contents of the /tmp directory in the default format
(without specifying the LONG option).
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST DIRECTORY /tmp</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in default format, could look like the following:
<PRE>
win2003.exe
2-ltp-logfile
test1
project.tar
ACME_NEW2.xml
project.htm
AutoFVT.bsh
</PRE>
<P>
<P><LI><B>Goal:</B> List the contents of the /tmp directory specifying to get
more information on the entries in the directory.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST DIRECTORY /tmp LONG</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in table format, could look like the following:
<PRE>
Type Size  Modified Date-Time Name          Link Target
---- ----- ------------------ ------------- ------------------
F    324M  20080512-18:07:52  win2003.exe   &lt;None&gt;
F    323   20080706-16:13:10  2-ltp-logfile &lt;None&gt;
D    0     20080728-11:21:44  test1         &lt;None&gt;
F    1210K 20080517-11:57:10  project.tar   &lt;None&gt;
F    258K  20080412-11:49:06  ACME_NEW2.xml &lt;None&gt;
F    12505 20070506-19:14:40  project.htm   &lt;None&gt;
F    44    20080928-16:24:40  AutoFVT.bsh   /tests/AutoFVT.bsh
</PRE>
<P>
<P><LI><B>Goal:</B> List the contents of the /tmp directory specifying to get
more detailed information on the entries in the directory, sorted by size.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST DIRECTORY /tmp LONG DETAILS SORTBYSIZE</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in table format, could look like the following:
<PRE>
Name           Link Target Type Size      U-Size L-Size    Modified Date-Time
-------------- ----------- ---- --------- ------ --------- ------------------
test1          &lt;None&gt;      D    0         0      0         20080728-11:21:44
AutoFVT.bsh    /tests/Auto F    44        0      44        20080928-16:24:40
               FVT.bsh
2-ltp-logfile  &lt;None&gt;      F    323       0      323       20080706-16:13:10
project.htm    &lt;None&gt;      F    12505     0      12505     20070506-19:14:40
ACME_NEW2.xml  &lt;None&gt;      F    264691    0      264691    20080412-11:49:06
project.tar    &lt;None&gt;      F    1239040   0      1239040   20080517-11:57:10
win2003.exe    &lt;None&gt;      F    340488704 0      340488704 20080512-18:07:52
</PRE>
<P>
<P><LI><B>Goal:</B> List only the files in the /tmp directory.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST DIRECTORY /tmp LONG TYPE F SORTBYNAME</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in table format, could look like the following:
<PRE>
Type Size  Modified Date-Time Name          Link Target
---- ----- ------------------ ------------- ------------------
F    323   20080706-16:13:10  2-ltp-logfile &lt;None&gt;
F    258K  20080412-11:49:06  ACME_NEW2.xml &lt;None&gt;
F    44    20080928-16:24:40  AutoFVT.bsh   /tests/AutoFVT.bsh
F    324M  20080512-18:07:52  win2003.exe   &lt;None&gt;
F    1210K 20080517-11:57:10  project.tar   &lt;None&gt;
F    12505 20070506-19:14:40  project.htm   &lt;None&gt;
</PRE>
<P>
<P><LI><B>Goal:</B> List all the entries in C&#58;\Projects with an 
extension of "txt".  Match this extension in a case sensitive manner.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST DIRECTORY C&#58;\Projects EXT txt CASESENSITIVE</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in default format, could look like the following:
<PRE>
javacore.20080420.041412.7713.txt
windoc.txt
mytest.txt
svt-spa02dynos390.txt
</PRE>
<P>
<P><LI><B>Goal:</B> Recursively list all the entries in the /tmp/test1 directory
with a name of "hello" and an extension of "txt" and sort the matching entries
by name.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST DIRECTORY /tmp/test1 NAME hello EXT txt RECURSE SORTBYNAME</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in default format, could look like the following:
<PRE>
backup/docs/hello.txt
docs/hello.txt
hello.txt
</PRE>
<P>
<P><LI><B>Goal:</B> List the files directly in the /tmp directory that have
no extension.  Note that you must use the length delimited format, 
<TT>:0&#58;</TT>, to indicate an empty string for the EXT option because if you specify
no value or "", then the STAF command parser thinks that no value was specified for the
EXT option and this will cause an "Invalid Request String" error (RC 7) since the EXT
option requires a value.
<BR>
<B>Syntax:</B>&nbsp;
<TT>LIST DIRECTORY /tmp EXT :0: TYPE F</TT>
<BR>
<B>Results:</B>  If the request is submitted from the command line, the result,
in default format, could look like the following:
<PRE>
dumpData
output
</PRE>
<P>
<P><LI><B>Goal:</B> Recursively list all the entries in the C&#58;/temp
directory with a name of "test1", sorted by name with details about each
matching entry.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST DIRECTORY C&#58;/temp NAME test1 RECURSE SORTBYNAME LONG DETAILS</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in default format, could look like the following:
<PRE>
Name                 Link   Type Size U-Size L-Size Modified Date-Time
-------------------- ------ ---- ---- ------ ------ ------------------
icu\source\test1.ucm &lt;None&gt; F    871  0      871    20081028-19:18:22
test1                &lt;None&gt; D    0    0      0      20080707-11:47:40
test1.bak            &lt;None&gt; F    83   0      83     20080919-11:10:22
test4\test1.txt      &lt;None&gt; F    32   0      34     20090331-13:03:04
</PRE>
<P>
<P><LI><B>Goal:</B> Get a summary of all the entries in directory C:\tests,
including its subdirectories.  The result provides the total size of all the
entries in the directory and the total number of files and subdirectories
contained in the directory.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST DIRECTORY C:/tests SUMMARY RECURSE TYPE ALL</TT>
<BR>
<B>Results:</B> If the request is submitted from the command line,
the result, in default format, could look like the following:
<PRE>
Name       : C:\tests
Size       : 239152838
Files      : 1976
Directories: 182
</PRE>
<P>
<P><LI><B>Goal:</B> Get a summary of the files in directory /tests/stax
whose extension is "xml".  The result provides the total size of all the
*.xml files that reside in this directory and the total number of files
whose extension is "xml" that are in the directory.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST DIRECTORY /tests/stax SUMMARY TYPE F EXT xml</TT>
<BR>
<B>Results:</B> If the request is submitted from the command line,
the result, in default format, could look like the following:
<PRE>
Name       : C:\tests\stax
Size       : 4250936
Files      : 888
Directories: 0
</PRE>
</UL>
<A NAME="IDX301"></A>
<P><H3><A NAME="Header_296">8.5.10 LIST COPYREQUESTS</A></H3>
<P>LIST COPYREQUESTS displays the File System copy requests currently in
progress.
<P><H4><A NAME="Header_297">Syntax</A></H4>
<PRE>
LIST   COPYREQUESTS &#91;LONG&#93; &#91;INBOUND&#93; &#91;OUTBOUND&#93;
       &#91;FILE &#91;&#91;BINARY&#93; &#91;TEXT&#93;&#93;&#93; &#91;DIRECTORY&#91;
</PRE>
<P><TT>COPYREQUESTS</TT> specifies to list the <TT>COPY</TT> requests currently
in progress.
<P><TT>LONG</TT> specifies to list more detailed information about the
copy requests, such as the copy mode and current state of the copy request.
<P><TT>INBOUND</TT> specifies to list <TT>COPY</TT> requests that are copying
to the machine.
<P><TT>OUTBOUND</TT> specifies to list <TT>COPY</TT> requests that are copying
from the machine.
<P><TT>FILE</TT> specifies to list <TT>COPY FILE</TT> requests.
<P><TT>BINARY</TT> specifies to list <TT>COPY FILE</TT> requests that are 
copying a file in binary format.
<P><TT>TEXT</TT> specifies to list <TT>COPY FILE</TT> requests that are copying
a file in text format.
<P><TT>DIRECTORY</TT> specifies to list <TT>COPY DIRECTORY</TT> requests.
<P>
If none of the optional options are specified (other than a <TT>LONG</TT>
option), all of the copy requests currently in progress will be shown.
<P><H4><A NAME="Header_298">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_299">Return Codes</A></H4>
<P>All return codes from LIST COPYREQUESTS are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_300">Results</A></H4>
<P>On successful return, the result buffer will contain a list of the
copy requests currently in progress as follows:
<UL>
<P><LI>If the <TT>LONG</TT> option is not specified, the result buffer will contain
a marshalled <TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/FS/CopyRequest&gt;</TT>
representing the copy requests in progress.
The map is defined as follows:
<BR>
<P><B><A NAME="TBLFSCOPYREQUESTTABLE">Table 22. Definition of map class STAF/Service/FS/CopyRequest</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a copy request in progress.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">startTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Start Date-Time
<BR>
(Date-Time)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">io
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">In/Out
<BR>
(I/O)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'In' | 'Out'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'D' | 'F'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B> 
<OL COMPACT TYPE=1>
<LI>The "Start Date-Time" value will contain the date and time that the
copy request started.
<LI>The "In/Out" value will contain <TT>'In'</TT> if the <TT>COPY</TT>
request is copying a file/directory to this machine or <TT>'Out'</TT>
if the <TT>COPY</TT> request is copying a file/directory from this machine.
<LI>If "In/Out" contains <TT>'In'</TT>, the "Machine" value will contain
the endpoint of the machine the file/directory is being copied from and the
"Name" value will contain the name of the file/directory being copied to.
If "In/Out" contains <TT>'Out'</TT>, the "Machine" value will contain
the endpoint of the machine the file/directory is being copied to and the
"Name" value will contain the name of the file/directory being copied from.
<LI>The "Type" value will contain <TT>'D'</TT> to represent a
<TT>COPY DIRECTORY</TT> request or <TT>'F'</TT> to represent a
<TT>COPY FILE</TT> request. 
</OL>
</TD></TR></TABLE>
<P>
<P><LI>If the <TT>LONG</TT> option is specified, the result buffer will
contain a marshalled <TT>&lt;List&gt;</TT> of any of the following map classes
representing detailed information about the copy requests in progress:
<UL COMPACT>
<LI><TT>&lt;Map&#58;STAF/Service/FS/CopyFile&gt;</TT> represents detailed
information about a file being copied (shown in table <A HREF="#TBLFSCOPYFILETABLE">Table 23</A>).
<LI><TT>&lt;Map&#58;STAF/Service/FS/CopyDirectory&gt;</TT> represents detailed
information about a directory being copied (shown in table
<A HREF="#TBLFSCOPYDIRECTORYTABLE">Table 25</A>).
</UL>
<P>
The maps used in representing detailed information about copy requests
are defined as follows: 
<BR>
<P><B><A NAME="TBLFSCOPYFILETABLE">Table 23. Definition of map class STAF/Service/FS/CopyFile</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents detailed information
about a file being copied.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">startTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Start Date-Time
<BR>
(Date-Time)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">io
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">In/Out
<BR>
(I/O)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'In' | 'Out'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">File Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'F'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">mode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Mode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'Binary'</TT> | <TT>'Text'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">state
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Transfer State
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;Map&#58;STAF/Service/FS/FileCopyState&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B> 
<OL COMPACT TYPE=1>
<LI>The "Mode" value will be set to <TT>'Binary'</TT> indicating
that the file copy is being performed in binary mode or 
<TT>'Text'</TT> indicating that the file copy is being performed
in text mode.
<LI>See table <A HREF="#TBLFSFILECOPYSTATETABLE">Table 24</A> for the definitions
of other fields.
</OL>
</TD></TR></TABLE>
<BR>
<P><B><A NAME="TBLFSFILECOPYSTATETABLE">Table 24. Definition of map class STAF/Service/FS/FileCopyState</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents detailed information
about the state of a file being copied.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">fileSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">File Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">bytesCopied
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Bytes Copied
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B> 
<OL COMPACT TYPE=1>
<LI>The "File Size" value will contain the size of the file being
copied in bytes or <TT>&lt;None&gt;</TT> if that information is not available
(like for inbound text file copies). 
<LI>The "Bytes Copied" value will contain the number of bytes in the
file that have been copied.
</OL>
</TD></TR></TABLE>
<BR>
<P><B><A NAME="TBLFSCOPYDIRECTORYTABLE">Table 25. Definition of map class STAF/Service/FS/CopyDirectory</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents detailed information
about a directory being copied.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">startTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Start Date-Time
<BR>
(Date-Time)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">io
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">In/Out
<BR>
(I/O)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'In' | 'Out'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">File Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'D'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">state
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Transfer State
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;Map&#58;STAF/Service/FS/DirectoryCopyState&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B> 
<OL COMPACT TYPE=1>
<LI>For the "Transfer State", see table <A HREF="#TBLFSDIRECTORYCOPYSTATETABLE">Table 26</A>
for the map class definition.
<LI>See table <A HREF="#TBLFSCOPYREQUESTTABLE">Table 22</A> for the definitions
of other fields.
</OL>
</TD></TR></TABLE>
<BR>
<P><B><A NAME="TBLFSDIRECTORYCOPYSTATETABLE">Table 26. Definition of map class STAF/Service/FS/DirectoryCopyState</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents detailed information
about the state of the directory being copied.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">mode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Mode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'Binary'</TT> | <TT>'Text'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">fileSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">File Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">bytesCopied
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Bytes Copied
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B> 
<OL COMPACT TYPE=1>
<LI>The "Name" value will be set to the name of the file within
the directory that is currently being copied.
<LI>The "Mode" value will be set to <TT>'Binary'</TT> indicating
that the file copy is being performed in binary mode or
<TT>'Text'</TT> indicating that the file copy is being performed
in text mode.
<LI>The "File Size" value will contain the size of the file being
copied in bytes or <TT>&lt;None&gt;</TT> if that information is not available
(like for inbound text file copies). 
<LI>The "Bytes Copied" value will contain the number of bytes in the
file that have been copied.
</OL>
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_301">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Show all the copy requests that are currently
in progress.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST COPYREQUESTS</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in table format, could look like the following:
<PRE>
Start Date-Time   I/O Machine                Name                      Type
----------------- --- ---------------------- ------------------------- ----
20050725-18:31:32 Out tcp://client2.company. c:/temp/TestA             D
                      com
20050725-18:31:38 Out tcp://client1.company. c:/tests/Instructions.txt F
                      com@6500
20050725-18:31:38 In  client1.company.com    c:/temp/Instructions.txt  F
20050725-18:31:41 Out tcp://client3.company. c:/tests/TestB/TestB.zip  F
                      com
20050725-18:32:05 In  client2.company.com    c:/tests/TestC            D
</PRE>
<P>
<P><LI><B>Goal:</B> Show detailed information on all the copy requests
that are currently in progress.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST COPYREQUESTS LONG</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in the verbose format, could look like the following:
<PRE>
[
  {
    Start Date-Time: 20050725-18:31:32
    In/Out         : Out
    Machine        : tcp://client2.company.com
    Directory Name : c:/temp/TestA
    Type           : D
    Transfer State : {
      Name        : c:/temp/TestA/TestA.zip
      Mode        : Binary
      File Size   : 9873006
      Bytes Copied: 1288000
    }
  }
  {
    Start Date-Time: 20050725-18:31:38
    In/Out         : Out
    Machine        : tcp://client1.company.com@6500
    File Name      : c:/tests/Instructions.txt
    Type           : F
    Mode           : Text
    Transfer State : {
      File Size   : 26019
      Bytes Copied: 12000
    }
  }
  {
    Start Date-Time: 20050725-18:31:38
    In/Out         : In
    Machine        : client1.company.com
    File Name      : c:/temp/Instructions.txt
    Type           : F
    Mode           : Text
    Transfer State : {
      File Size   : &lt;None&gt;
      Bytes Copied: 12000
    }
  }
  {
    Start Date-Time: 20050725-18:31:41
    In/Out         : Out
    Machine        : tcp://client3.company.com
    File Name      : c:/temp/TestB/TestB.zip
    Type           : F
    Mode           : Binary
    Transfer State : {
      File Size   : 70483006
      Bytes Copied: 63614000
    }
  }
  {
    Start Date-Time: 20050725-18:32:05
    In/Out         : In
    Machine        : client2.company.com
    Directory Name : c:/temp/TestC
    Type           : D
    Transfer State : {
      Name        : c:/temp/TestC/TestC.txt
      Mode        : Text
      File Size   : &lt;None&gt;
      Bytes Copied: 8000
    }
  }
]
</PRE>
<P>
<P><LI><B>Goal:</B> Show the file copy requests that are copying files to
this machine.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST COPYREQUESTS INBOUND FILE</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in table format, could look like the following:
<PRE>
Start Date-Time   In/Out Machine             Name                     Type
----------------- ------ ------------------- ------------------------ ----
20050725-18:31:38 In     client1.company.com c:/temp/Instructions.txt F
</PRE>
<P>
<P><LI><B>Goal:</B> Show detailed information about the file copy
requests that are copying files from this machine.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST COPYREQUESTS OUTBOUND FILE LONG</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in verbose format, could look like the following:
<PRE>
[
  {
    Start Date-Time: 20050725-18:31:38
    In/Out         : Out
    Machine        : tcp://client1.company.com@6500
    File Name      : c:/tests/Instructions.txt
    Type           : F
    Mode           : Text
    Transfer State : {
      File Size   : 26019
      Bytes Copied: 12000
    }
  }
  {
    Start Date-Time: 20050725-18:31:41
    In/Out         : Out
    Machine        : tcp://client3.company.com
    File Name      : c:/temp/TestB/TestB.zip
    Type           : F
    Mode           : Binary
    Transfer State : {
      File Size   : 70483006
      Bytes Copied: 63614000
    }
  }
]
</PRE>
<P>
<P><LI><B>Goal:</B> Show detailed information about the file copy
requests that are copying files from this machine in binary mode.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST COPYREQUESTS OUTBOUND BINARY FILE LONG</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in table format, could look like the following:
<PRE>
[
  {
    Start Date-Time: 20050725-18:31:41
    In/Out         : Out
    Machine        : tcp://client3.company.com
    File Name      : c:/temp/TestB/TestB.zip
    Type           : F
    Mode           : Binary
    Transfer State : {
      File Size   : 70483006
      Bytes Copied: 63614000
    }
  }
]
</PRE>
</UL>
<A NAME="IDX304"></A>
<P><H3><A NAME="Header_302">8.5.11 LIST SETTINGS</A></H3>
<P>LIST SETTINGS shows the operational settings for the FS service.
<P><H4><A NAME="Header_303">Syntax</A></H4>
<PRE>
LIST SETTINGS     
</PRE>
<P><TT>SETTINGS</TT> specifies that you want to list the current operational
settings for the FS service.
<P><H4><A NAME="Header_304">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_305">Return Codes</A></H4>
<P>All return codes from LIST SETTINGS are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_306">Results</A></H4>
<P>On successful return, the result buffer will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/FS/Settings&gt;</TT> representing the current
settings for the File System service.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_27">Table 27. Definition of map class STAF/Service/FS/Settings</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the operational
settings for the File System service.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">strictFSCopyTrust
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Strict FS Copy Trust
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_307">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> List the current operational settings for the
File System service.
<BR>
<B>Syntax:</B>&nbsp; <TT>LIST SETTINGS</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in default format, could look like the following:
<PRE>
Strict FS Copy Trust: Disabled
</PRE>
</UL>
<A NAME="IDX307"></A>
<P><H3><A NAME="Header_308">8.5.12 CREATE</A></H3>
<P>CREATE creates a directory.
<P><H4><A NAME="Header_309">Syntax</A></H4>
<PRE>
CREATE DIRECTORY &lt;Name&gt; &#91;FULLPATH&#93; &#91;FAILIFEXISTS&#93;
</PRE>
<P><TT>DIRECTORY</TT> specifies the name of the directory to create. This option will resolve variables.
<P><TT>FULLPATH</TT> specifies that any intermediate parent directories should
be created if they don't exist.
<P><TT>FAILIFEXISTS</TT> specifies that the request should generate an error
if the specified directory already exists.  By default, the request will succeed
if the specified directory already exists.
<P><H4><A NAME="Header_310">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_311">Return Codes</A></H4>
<P>All return codes from CREATE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_312">Results</A></H4>
<P>On successful return, the result buffer will be empty.
<P><H4><A NAME="Header_313">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Create the directory /tmp/tests
<BR>
<B>Syntax:</B>&nbsp; <TT>CREATE DIRECTORY /tmp/tests</TT>
<P>
<P><LI><B>Goal:</B> Create the directory {Tests/Root} and ensure that any
intermediate parent directories are created as well.
<BR>
<B>Syntax:</B>&nbsp; <TT>CREATE DIRECTORY {Tests/Root} FULLPATH</TT>
<P>
<P><LI><B>Goal:</B> Create the directory D&#58;\TestData.  Generate an error if the
directory already exists.
<BR>
<B>Syntax:</B>&nbsp; <TT>CREATE DIRECTORY D&#58;\TestData FAILIFEXISTS</TT>
</UL>
<A NAME="IDX310"></A>
<P><H3><A NAME="Header_314">8.5.13 DELETE</A></H3>
<P>DELETE deletes selected file system entries.
<P>
Note that if a file system entry being deleted is a symbolic link, the
symbolic link will be deleted, not the entry referenced by the link.
<P>
<P><H4><A NAME="Header_315">Syntax</A></H4>
<PRE>
DELETE ENTRY &lt;Name&gt; CONFIRM &#91;RECURSE&#93; &#91;IGNOREERRORS&#93;
       &#91; CHILDREN &#91;TYPE &lt;Types&gt;&#93; &#91;NAME &lt;Pattern&gt;&#93; &#91;EXT &lt;Pattern&gt;&#93;
                  &#91;CASESENSITIVE | CASEINSENSITIVE&#93; &#93;
</PRE>
<P><TT>ENTRY</TT> specifies the name of the file system entry to delete.
This option will resolve variables.
<P><TT>CHILDREN</TT> specifies that only children matching <TT>NAME</TT>,
<TT>EXT</TT>, and <TT>TYPE</TT> should be deleted.  The entry itself will
not be deleted.
<P><TT>NAME</TT> specifies a pattern used to match the name of child entries.
Only child entries whose name match this pattern will be deleted.  Match
patterns may be specified using special characters '*' and/or '?' as wildcards.
The default pattern is "*". This option will resolve variables.
<P><TT>EXT</TT> specifies a pattern used to match the extension of child
entries.  Only child entries whose extension match this pattern will be
deleted.  Match patterns may be specified using special characters '*' and/or
'?' as wildcards.  The default pattern is "*".  This option will resolve variables.
<P><B>Note: </B>The DELETE command recognizes the "name" (<TT>NAME</TT>)
portion of a file system name as the character(s) that precede a period (or the
entire name if it does not include a period) and the "extension" (<TT>EXT</TT>)
portion of a file system name are character(s) that follow a period.
For example, for file system name myfile.txt, the "name" portion is "myfile" and
the "extension" portion is "txt".  To match file system names whose name begins
with "my" and whose extension is "txt", you could specify options
<TT>NAME my* EXT txt</TT>.
<P><TT>TYPE</TT> specifies the types of child entries to delete.  These types
are the same types described in section <A HREF="#HDRFSGETE">8.5.7, "GET ENTRY"</A>.  You may also
specify the string "ALL" to delete all entry types.  By default, all entry types
are deleted.  This option will resolve variables.
<P><TT>CASESENSITIVE</TT> specifies that the patterns specified by
<TT>NAME</TT> and <TT>EXT</TT> are to be matched in a case sensitive manner.
<P><TT>CASEINSENSITIVE</TT> specifies that the patterns specified by
<TT>NAME</TT> and <TT>EXT</TT> are to be matched in a case insensitive
manner.
<P><B>Note: </B>If neither <TT>CASESENSITIVE</TT> nor <TT>CASEINSENSITIVE</TT> is
specified, the default is determined by the operating system -- unix systems
default to <TT>CASESENSITIVE</TT>, all others default to
<TT>CASEINSENSITIVE</TT>.
<P><TT>RECURSE</TT> specifies that the entry's children will be recursively
deleted.
<P><B>Note: </B>If neither <TT>CHILDREN</TT> nor <TT>RECURSE</TT> is used, only
the entry itself will be deleted.  If <TT>RECURSE</TT> is specified without
<TT>CHILDREN</TT> then the entry and all of its children will be deleted.  If
<TT>RECURSE</TT> and <TT>CHILDREN</TT> are specified, then only the children
matching the specified <TT>NAME</TT>, <TT>EXT</TT>, and <TT>TYPE</TT> will
be deleted (i.e., the entry itself will not be deleted).
<P><TT>IGNOREERRORS</TT> specifies that errors encountered (recursively)
deleting children should not be returned.  By default, all errors encountered
while (recursively) deleting children will be returned in the result buffer.
<P><TT>CONFIRM</TT> indicates that you really want the deletion to occur.
<P><H4><A NAME="Header_316">Security</A></H4>
<P>This command requires trust level 4.  If you specify <TT>RECURSE</TT>, you must have trust level 5.
<P><H4><A NAME="Header_317">Return Codes</A></H4>
<P>All return codes from DELETE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_318">Results</A></H4>
<P>
<UL>
<P><LI>On successful return, the result buffer will be empty. 
<P>
<P><LI>If errors were encountered deleting entries and <TT>IGNOREERRORS</TT>
was not specified, the result buffer will contain a
marshalled <TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/FS/ErrorInfo&gt;</TT> representing
a list of error information about the entries that were not successfully deleted.
See table <A HREF="#TBLFSERRORINFOTABLE">Table 15</A> for the map class definition of
<TT>&lt;Map&#58;STAF/Service/FS/ErrorInfo&gt;</TT>.
</UL>
<P>
<P><H4><A NAME="Header_319">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Delete the entry /tmp/myfile.txt
<BR>
<B>Syntax:</B>&nbsp;
<TT>DELETE ENTRY /tmp/myfile.txt CONFIRM</TT>
<P>
<P><LI><B>Goal:</B> Delete the directory /tmp/myfiles and all of its children.
<BR>
<B>Syntax:</B>&nbsp; 
<TT>DELETE ENTRY /tmp/myfiles RECURSE CONFIRM</TT>
<P>
<P><LI><B>Goal:</B> Delete all entries in directory /tmp whose name begins
with "report" and whose extension is "txt" (e.g. delete entries like
/tmp/report1.txt, /tmp/report25.txt, and /tmp/reportForMe.txt).
<BR>
<B>Syntax:</B>&nbsp;
<TT>DELETE ENTRY /tmp CHILDREN NAME "report*" EXT txt CONFIRM</TT>
<P>
<P><LI><B>Goal:</B> Recursively delete all the children of C&#58;\TEMP, without
deleting the directory itself.
<BR>
<B>Syntax:</B>&nbsp;
<TT>DELETE ENTRY C&#58;\TEMP CHILDREN RECURSE CONFIRM</TT>
<P>
<P><LI><B>Goal:</B> Delete all entries with an extension of "tmp" in
C&#58;\MyFiles.  Match the extension in a case insensitive manner.  Do not
recurse down subdirectories.
<BR>
<B>Syntax:</B>&nbsp;
<TT>DELETE ENTRY C&#58;\TEMP CHILDREN EXT tmp CASEINSENSITIVE CONFIRM</TT>
<P>
<P><LI><B>Goal:</B> Delete all files in the /tmp directory that have
no extension.  Note that you must use the length delimited format, 
<TT>:0&#58;</TT>, to indicate an empty string for the EXT option because if you specify
no value or "", then the STAF command parser thinks that no value was specified for the
EXT option and this will cause an "Invalid Request String" error (RC 7) since the EXT
option requires a value.
<BR>
<B>Syntax:</B>&nbsp;
<TT>DELETE ENTRY /tmp CHILDREN EXT :0: TYPE F CONFIRM</TT>
<P>
<P><LI><B>Goal:</B> Recursively delete all files (and only files) under {MyTempFiles}
with a base name beginning with "test".  Match the name in a case sensitive
manner.  Do not report any errors during the deletion.
<BR>
<B>Syntax:</B>&nbsp;
<TT>DELETE ENTRY {MyTempFiles} CHILDREN NAME "test*" TYPE F RECURSE CASESENSITIVE IGNOREERRORS CONFIRM</TT>
<P>
</UL>
<A NAME="IDX313"></A>
<P><H3><A NAME="HDRFSSET">8.5.14 SET</A></H3>
The SET command allows you to change the operational parameters for the
File System service dynamically (without stopping/restarting STAF) which is
important for STAF machines that must be continuously available.
<P>
Note that to make these settings permanent (e.g. if you want these changes
to apply once STAF is stopped and restarted), you'll need to update the
STAF configuration file with these new settings.
<P>
<P><H4><A NAME="Header_321">Syntax</A></H4>
<PRE>
SET  STRICTFSCOPYTRUST &lt;Enabled | Disabled&gt;
</PRE>
<P>See section <A HREF="#HDROPPARMS">4.7, "Operational parameters"</A> for a description of this option.
Note that setting <TT>STRICTFSCOPYTRUST Enabled</TT> is equivalent
to setting the <TT>STRICTFSCOPYTRUST</TT> operational parameter in the
STAF configuration file.  Setting <TT>STRICTFSCOPYTRUST Disabled</TT> is
equivalent to not setting the <TT>STRICTFSCOPYTRUST</TT> operational
parameter in the STAF configuration file.
<P><H4><A NAME="Header_322">Security</A></H4>
<P>This command requires trust level 5.
<P><H4><A NAME="Header_323">Return Codes</A></H4>
<P>All return codes from <TT>SET</TT> are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_324">Results</A></H4>
<P>The result buffer will contain no data on return from a successful SET command.
<P><H4><A NAME="Header_325">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Enabled strict trust checking when copying a file or
directory.
<P><B>Syntax:</B>&nbsp; <TT>SET STRICTFSCOPYTRUST Enabled</TT>
</UL>
<P>
<A NAME="IDX314"></A>
<A NAME="IDX316"></A>
<HR><H2><A NAME="HDRHDLSRV" HREF="#ToC_326">8.6 Handle Service</A></H2>
<P><H3><A NAME="Header_327">8.6.1 Description</A></H3>
<P>The HANDLE service is one of the internal STAF services.  It provides the
following commands.
<UL COMPACT>
<LI>CREATE - Creates a static handle
<LI>DELETE - Deletes a static handle
<LI>LIST - Displays brief information on all handles, or those with a
given name and state, or summary information for handles
<LI>QUERY - Displays detailed information on a specific handle
<LI>AUTHENTICATE - Authenticates a handle
<LI>UNAUTHENTICATE - Un-authenticates a handle
<LI>HELP &#45; Returns syntax information
</UL>
<A NAME="IDX319"></A>
<P><H3><A NAME="HDRHANDCRT">8.6.2 CREATE</A></H3>
<P>CREATE creates a static handle.  A static handle is a handle which can be
shared by several processes on the same system.  This is most directly useful
for shell-scripts which rely on the STAF command, and need to ensure that the
same handle is used for every request.  See <A HREF="#HDRSTAFSHS">"Using the STAF command from shell-scripts"</A> for more
information on how to use static handles with the STAF command.
<P><B>Note: </B>Be sure to DELETE any static handles you create via the CREATE command.
<P><H4><A NAME="Header_329">Syntax</A></H4>
<PRE>
CREATE HANDLE NAME &lt;Handle Name&gt;
</PRE>
<P><TT>NAME</TT> specifies the registered name of the handle.
<P><H4><A NAME="Header_330">Security</A></H4>
<P>This command is only valid if submitted to the local machine,
not to remote machines.
<P>
<P><H4><A NAME="Header_331">Return Codes</A></H4>
<P>All return codes from CREATE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_332">Results</A></H4>
<P>On successful return, the result buffer will contain the new handle number.
<P><H4><A NAME="Header_333">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Create a static handle which will be registered with the name
"Script Test"
<BR>
<B>Syntax:</B>&nbsp;  <TT>CREATE HANDLE NAME "Script Test"</TT>
</UL>
<A NAME="IDX322"></A>
<P><H3><A NAME="Header_334">8.6.3 DELETE</A></H3>
<P>DELETE deletes a static handle.
<P><H4><A NAME="Header_335">Syntax</A></H4>
<PRE>
DELETE HANDLE &lt;Number&gt;
</PRE>
<P><TT>HANDLE</TT> specifies the handle number to delete.
<P>
<P><H4><A NAME="Header_336">Security</A></H4>
<P>This command requires trust level 5.
<P><B>Note: </B>This command is only valid if submitted to the local machine,
not to remote machines.
<P>
<P><H4><A NAME="Header_337">Return Codes</A></H4>
<P>All return codes from DELETE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_338">Results</A></H4>
<P>On successful return, the result buffer will be empty.
<P><H4><A NAME="Header_339">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Delete static handle number 42
<BR>
<B>Syntax:</B>&nbsp; <TT>DELETE HANDLE 42</TT>
</UL>
<A NAME="IDX325"></A>
<P><H3><A NAME="Header_340">8.6.4 LIST</A></H3>
<P>LIST allows you to display brief information about all handles, or about
groups of handles by name or state.  Note that if you do not specify a set of
states to display, it will show only those that are in REGISTERED, INPROCESS,
and STATIC states.  To see all processes, specify PENDING,
REGISTERED, INPROCESS, and STATIC.  You can also display summary information
about handles using the SUMMARY option.
<P><H4><A NAME="Header_341">Syntax</A></H4>
<PRE>
LIST &#91; HANDLES &lt;&#91;NAME &lt;Handle Name&gt;&#93; &#91;LONG&#93; &#91;PENDING&#93; &#91;REGISTERED&#93;
                &#91;INPROCESS&#93; &#91;STATIC&#93;&gt; | &#91;SUMMARY&#93; &#93;
</PRE>
<P><TT>HANDLES</TT> specifies that you want to list information about handles.
<P><TT>NAME</TT> specifies that you only want information on handles with
the name <TT>&lt;Handle Name&gt;</TT>.
<P><TT>LONG</TT> specifies to list more detailed information on the handles,
such as the process id (PID) used by each handle.
<P><TT>PENDING</TT> shows handles that are in a pending state.  A handle is
in pending state when a process has been started via the PROCESS service, but
that process has not yet registered with STAF.
<P><TT>REGISTERED</TT> shows handles that are registered with STAF.
<P><TT>INPROCESS</TT> shows handles for external services that are running
within the same process as STAFProc.
<P><TT>STATIC</TT> shows static handles. A static handle is a handle which was created
using the CREATE command of the HANDLE service or by using the STATICHANDLENAME option
when starting a process through the PROCESS service.
<P><TT>SUMMARY</TT> specifies that you want summary information about handles
such as the number of active handles, the total number of handles that have
been created/registered since STAFProc was started, the number of times the
handle number has been reset, the handle number range, and the maximum number
of active handles.
<P><H4><A NAME="Header_342">Security</A></H4>
<P>This command requires trust level 1.
<P><H4><A NAME="Header_343">Return Codes</A></H4>
<P>All return codes from LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_344">Results</A></H4>
<P>On successful return, the result buffer will contain a list of the handles
as follows: 
<P>
<UL>
<P><LI>If neither the <TT>LONG</TT> or <TT>SUMMARY</TT> option is specified,
the result buffer will contain a marshalled <TT>&lt;List&gt; of
&lt;Map&#58;STAF/Service/Handle/HandleInfo&gt;</TT> representing the handles,
their registered names, their state, and the date and time of their last use.
The map is defined as follows: 
<BR>
<P><B><A NAME="Table_28">Table 28. Definition of map class STAF/Service/Handle/HandleInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents status of a handle.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Handle
<BR>
(H#)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Handle Name
<BR>
(Name)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">state
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">State
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">lastUsedTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Last Used Date-Time
<BR>
(Last Used)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR></TABLE>
<P>
<P><LI>If the <TT>LONG</TT> option is specified, the result buffer will contain a
marshalled <TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Handle/HandleInfoLong&gt;</TT>
representing more detailed information about the handles, including the
operating system process id used by each handle.
The map is defined as follows: 
<BR>
<P><B><A NAME="Table_29">Table 29. Definition of map class STAF/Service/Handle/HandleInfoLong</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents detailed information about the status
of a handle.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Handle
<BR>
(H#)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Handle Name
<BR>
(Name)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">state
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">State
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">lastUsedTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Last Used Date-Time
<BR>
(Last Used)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">pid
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">PID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
The "PID" value will contain the process id assigned by the operating system.
The process id for a static handle that is not associated with a process will be 0.
</TD></TR></TABLE>
<P>
<P><LI>If the <TT>SUMMARY</TT> option is specified, the result buffer will contain a
marshalled <TT>&lt;Map&#58;STAF/Service/Handle/HandleSummary&gt;</TT>
representing summary information for handles.
The map is defined as follows: 
<BR>
<P><B><A NAME="Table_30">Table 30. Definition of map class STAF/Service/Handle/HandleSummary</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents summary information for handles.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">activeHandles
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Active Handles
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">totalHandles
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Total Handles
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">resetCount
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Reset Count
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">handleNumberRange
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Handle Number Range
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">&lt;Minimum - Maximum&gt;
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">maxActiveHandles
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Maximum Active Handles
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<UL COMPACT>
<LI>The value for "Active Handles" is the number of active (pending,
registered, inprocess, or static) handles.
<LI>The value for "Total Handles" is the total number of handles that
have been created/registered since STAFProc was started.
<LI>The value for "Reset Count" is the number of times the handle number
has been reset back to 2 (handle number 1 is reserved for STAFProc).
<LI>The value for "Handle Number Range" is the range of values for
the handle number.
<LI>The value for "Maximum Active Handles" is the maximum number of
active (pending, registered, inprocess, or static) handles.
</UL>
</TD></TR></TABLE>
<P>
</UL>
<P>
<P><H4><A NAME="Header_345">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> List all the REGISTERED, INPROCESS, and STATIC handles.
<BR>
<B>Syntax:</B> <TT>LIST</TT> (or <TT>LIST HANDLES</TT>)
<BR>
<B>Result:</B>  If the request is submitted from the command line,
the result, in table format, could look like:
<PRE>
Handle Handle Name                     State      Last Used Date-Time
------ ------------------------------- ---------- -------------------
1      STAF_Process                    InProcess  20051205-12:41:42
2      STAF/Authenticator/AuthSample   Registered 20051205-12:41:49
3      STAF/Service/STAFServiceLoader1 InProcess  20051205-12:41:51
4      STAF/Service/STAX               Registered 20051205-12:41:51
5      STAF/Service/LOG                InProcess  20051205-12:41:53
6      STAF/SERVICE/Event              Registered 20051205-12:41:51
14     MyTest                          Registered 20051205-13:08:53
16     STAF/Client                     Registered 20051205-13:08:40
20     WebTest                         Static     20051205-13:17:35
</PRE>
<P><LI><B>Goal:</B> List all the REGISTERED and INPROCESS handles in
the long (more detailed) format.
<BR>
<B>Syntax:</B> <TT>LIST HANDLES REGISTERED INPROCESS LONG</TT>
<BR>
<B>Result:</B>  If the request is submitted from the command line,
the result, in table format, could look like:
<PRE>
Handle Handle Name                     State      Last Used Date-Time PID
------ ------------------------------- ---------- ------------------- ----
1      STAF_Process                    InProcess  20051205-12:41:42   1636
2      STAF/Authenticator/AuthSample   Registered 20051205-12:41:49   2360
3      STAF/Service/STAFServiceLoader1 InProcess  20051205-12:41:51   1636
4      STAF/Service/STAX               Registered 20051205-12:41:51   2844
5      STAF/Service/LOG                InProcess  20051205-12:41:53   1636
6      STAF/SERVICE/Event              Registered 20051205-12:41:51   2844
14     MyTest                          Registered 20051205-13:08:53   2892
16     STAF/Client                     Registered 20051205-13:16:40   2900
</PRE>
<P>
<P><LI><B>Goal:</B> List only handles registered with the name MyTest.
<BR>
<B>Syntax:</B> <TT>LIST HANDLES NAME MyTest</TT>
<BR>
<B>Result:</B>  If the request is submitted from the command line,
the result, in table format, could look like:
<PRE>
Handle Handle Name State      Last Used Date-Time
------ ----------- ---------- -------------------
14     MyTest      Registered 20051205-13:08:53
</PRE>
<P>
<P><LI><B>Goal:</B> List all static handles.
<BR>
<B>Syntax:</B> <TT>LIST HANDLES STATIC</TT>
<BR>
<B>Result:</B>  If the request is submitted from the command line,
the result, in table format, could look like:
<PRE>
Handle Handle Name State  Last Used Date-Time
------ ----------- ------ -------------------
20     WebTest     Static 20051205-13:17:35
</PRE>
<P>
<P><LI><B>Goal:</B> List all pending handles.
<BR>
<B>Syntax:</B> <TT>LIST HANDLES PENDING</TT>
<BR>
<B>Result:</B>  If the request is submitted from the command line,
the result, in table format, could look like:
<PRE>
Handle Handle Name State   Last Used Date-Time
------ ----------- ------- -------------------
17     &lt;None&gt;      Pending 20051205-13:16:55
23     &lt;None&gt;      Pending 20051205-13:18:59
</PRE>
<P>
<P><LI><B>Goal:</B> List summary information about handles.
<BR>
<B>Syntax:</B> <TT>LIST HANDLES SUMMARY</TT>
<BR>
<B>Results:</B>  If the request is submitted from the command line,
the result, in default form, could look like:
<PRE>
Active Handles        : 19
Total Handles         : 129
Reset Count           : 0
Handle Number Range   : 1 - 2147483647
Maximum Active Handles: 2147483647
</PRE>
</UL>
<A NAME="IDX328"></A>
<P><H3><A NAME="Header_346">8.6.5 QUERY</A></H3>
<P>QUERY will allow you to display detailed information about a given handle number.
<P><H4><A NAME="Header_347">Syntax</A></H4>
<PRE>
QUERY HANDLE &lt;Handle&gt;
</PRE>
<P><TT>HANDLE</TT> specifies the handle number you want information on.
This option will resolve variables.
<P><H4><A NAME="Header_348">Security</A></H4>
<P>This command requires trust level 1.
<P><H4><A NAME="Header_349">Return Codes</A></H4>
<P>All return codes from QUERY are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_350">Results</A></H4>
<P>On successful return, the result buffer will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Handle/QueryHandle&gt;</TT> representing
the handles, handle name, state, last used date and time,
operating system process id, authenticator, and user identifier.
The map is defined as follows: 
<BR>
<P><B><A NAME="Table_31">Table 31. Definition of map class STAF/Service/Handle/QueryHandle</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents status of a handle.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">state
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">State
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">lastUsedTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Last Used Date-Time
<BR>
(Last Used)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">pid
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">PID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">user
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">User
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Authenticator&gt;://&lt;UserID&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">instanceUUID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Instance UUID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The "PID" value will contain the process id assigned by the operating system.
The process id for a static handle that is not associated with a process will be 0.
<LI>The "User" value for handles that are not authenticated will be <TT>'none://anonymous'</TT>.
<LI>The "Instance UUID" value contains the STAF Universally Unique ID that
uniquely identifies a STAF instance. 
</OL>
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_351">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Query handle number 1
<BR>
<B>Syntax:</B>&nbsp; <TT>QUERY HANDLE 1</TT>
<BR>
<B>Result:</B> If the request is submitted from the command line,
the result, in default format, could look like:
<PRE>
Handle             : 1
Handle Name        : STAF_Process
State              : InProcess
Last Used Date-Time: 20100126-15:45:40
PID                : 1636
User               : none://anonymous
Instance UUID      : 7D625F3CB40100000929369C75636194
</PRE>
</UL>
<A NAME="IDX331"></A>
<P><H3><A NAME="HDRHANDAUTH">8.6.6 AUTHENTICATE</A></H3>
<P>AUTHENTICATE authenticates the handle submitting the request.
An authenticated handle has the specified user identifier
and authenticator associated with it.
<P><H4><A NAME="Header_353">Syntax</A></H4>
<PRE>
AUTHENTICATE USER &lt;User Identifier&gt; CREDENTIALS &lt;Credentials&gt;
             &#91;AUTHENTICATOR &lt;Name&gt;&#93;
</PRE>
<P><TT>USER</TT> specifies the user identifier to authenticate.
<P><TT>CREDENTIALS</TT> specifies the credentials for the user identifier,
such as a password.  This option will handle private data.
<P><TT>AUTHENTICATOR</TT> specifies the name of the Authenticator to
use to authenticate the handle instead of the default Authenticator.
<P><H4><A NAME="Header_354">Security</A></H4>
<P>This command is only valid if submitted to the local machine,
not to remote machines.
<P>
<P><H4><A NAME="Header_355">Return Codes</A></H4>
<P>All return codes from AUTHENTICATE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_356">Results</A></H4>
<P>On successful return, the result buffer will be empty.
<P><H4><A NAME="Header_357">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Authenticate the handle submitting the request using the
default authenticator to authenticate the handle and specifying user
identifier "johnDoe@company.com" and credentials "secret" which is
enclosed in STAF privacy delimiters so that the credentials will be masked.
<BR>
<B>Syntax:</B>&nbsp; <TT>AUTHENTICATE USER johnDoe@company.com CREDENTIALS !!@secret@!!</TT>
<P>
<P><LI><B>Goal:</B> Authenticate the handle submitting the request using
the IBMIntraAuth authenticator to authenticate the handle and specifying
user identifier "mary" and credentials "topsecret" which is
enclosed in STAF privacy delimiters so that the credentials will be masked.
<BR>
<B>Syntax:</B>&nbsp; <TT>AUTHENTICATE USER mary CREDENTIALS !!@topsecret@!! AUTHENTICATOR IBMIntraAuth</TT>
</UL>
<A NAME="IDX334"></A>
<P><H3><A NAME="HDRHANDUAUTH">8.6.7 UNAUTHENTICATE</A></H3>
<P>UNAUTHENTICATE un-authenticates the handle submitting the request.
An unauthenticated handle has user 'none&#58;//anonymous' associated with it.
<P><H4><A NAME="Header_359">Syntax</A></H4>
<PRE>
UNAUTHENTICATE
</PRE>
<P><H4><A NAME="Header_360">Security</A></H4>
<P>This command requires trust level 5.
<P><B>Note: </B>This command is only valid if submitted to the local machine,
not to remote machines.
<P>
<P><H4><A NAME="Header_361">Return Codes</A></H4>
<P>All return codes from UNAUTHENTICATE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_362">Results</A></H4>
<P>On successful return, the result buffer will be empty.
<P><H4><A NAME="Header_363">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Un-Authenticate the handle submitting the request.
<BR>
<B>Syntax:</B>&nbsp; <TT>UNAUTHENTICATE</TT>
</UL>
<P>
<A NAME="IDX335"></A>
<A NAME="IDX337"></A>
<HR><H2><A NAME="HDRHELPSRV" HREF="#ToC_364">8.7 Help Service</A></H2>
<P><H3><A NAME="Header_365">8.7.1 Description</A></H3>
The Help service is one of the internal STAF services.  It allows you to
obtain information about the return codes generated by STAF services.
<P><B>Note: </B>Error codes of 4000 and beyond are service specific return codes, and not
all external services register their return codes with the Help service.
Therefore, if you don't find information on a 4000+ return code returned by a
service, be sure to check the documentation provided with the service.
<P>The Help service provides the following commands.
<UL COMPACT>
<LI>LIST - Displays general or service specific error codes
<LI>ERROR - Provides information on a specific error code
<LI>REGISTER - Allows a service to register error codes
<LI>UNREGISTER - Allows a service to unregister error codes
<LI>HELP &#45; Returns syntax information
</UL>
<A NAME="IDX340"></A>
<P><H3><A NAME="Header_366">8.7.2 LIST</A></H3>
Allows you to list the information managed by the Help service, including
<UL COMPACT>
<LI>Common STAF return codes
<LI>Service-specific return codes
<LI>Services registered with the Help service
</UL>
<P>
<P><H4><A NAME="Header_367">Syntax</A></H4>
<PRE>
LIST SERVICES | &#91;SERVICE &lt;Service name&gt;&#93; ERRORS
</PRE>
<P><TT>SERVICES</TT> will list all the services that have registered their
return codes with the Help service.
<P><TT>SERVICE</TT> specifies that return codes for the specified service
should be listed, as opposed to the common return codes.
<P><TT>ERRORS</TT> will list return codes and a short description of each.
<P>
<P><H4><A NAME="Header_368">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_369">Return Codes</A></H4>
<P>All return codes from LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_370">Results</A></H4>
<P>If successful, the result buffer will contain information
about the request based on the options specified: 
<UL>
<P><LI>The result buffer for a <TT>"LIST SERVICES"</TT> request will contain a
marshalled <TT>&lt;List&gt; of &lt;String&gt;</TT> representing the external services
that have registered their return codes with the Help service.
<P>
<P><LI>
<P>The result buffer for a <TT>"LIST ERRORS"</TT> or
<TT>"LIST ERRORS SERVICE &lt;Service Name&gt;"</TT> request will contain a
marshalled <TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Help/ErrorInfo&gt;</TT>
representing the errors that can be generated by STAF internal services or
for a specific external service.  The map is defined as follows:
<BR>
<P><B><A NAME="Table_32">Table 32. Definition of map class STAF/Service/Help/ErrorInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information about an error.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">returnCode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Return Code
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
The value for "Description" will be a short description of the error.
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_371">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Show me all the common STAF return codes
<P><B>Syntax:</B> <TT>LIST ERRORS</TT>
<P><B>Results:</B>
<PRE>
Return Code Description
----------- ------------------------------
0           No error
1           Invalid API
2           Unknown service
3           Invalid handle
4           Handle already exists
5           Handle does not exist
6           Unknown error
7           Invalid request string
8           Invalid service result
9           REXX Error
10          Base operating system error
11          Process already complete
12          Process not complete
13          Variable does not exist
14          Unresolvable string
15          Invalid resolve string
16          No path to endpoint
17          File open error
18          File read error
19          File write error
20          File delete error
21          STAF not running
22          Communication error
23          Trusteee does not exist
24          Invalid trust level
25          Insufficient trust leevl
26          Registration error
27          Service configuration error
28          Queue full
29          No queue element
30          Notifiee does not exist
31          Invalid API level
32          Service not unregisterable
33          Service not available
34          Semaphore does not exist
35          Not sempahore owner
36          Semaphore has pending requests
37          Timeout
38          Java error
39          Converter error
40          Not used
41          Invalid object
42          Invalid parm
43          Request number not found
44          Invalid asynchronous option
45          Request not complete
46          Process authentication denied
47          Invalid value
48          Does not exist
49          Already exists
50          Directory Not Empty
51          Directory Copy Error
52          Diagnostics Not Enabled
53          Handle Authentication Denied
54          Handle Already Authenticated
55          Invalid STAF Version
4000+       Service specific errors
</PRE>
<P>
<P><LI>
<B>Goal:</B> Show me return codes for the Log service
<P><B>Syntax:</B> <TT>LIST SERVICE Log ERRORS</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in table format, could look like:
<PRE>
Return Code Description
----------- -------------------------------
4004        Invalid level
4007        Invalid file format
4008        Unable to purge all log records
</PRE>
<P>
<P><LI>
<B>Goal:</B> Show me the services that have registered return codes
with the Help service
<P><B>Syntax:</B> <TT>LIST SERVICES</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
EVENT
LOG
RESPOOL
STAX
</PRE>
</UL>
<A NAME="IDX343"></A>
<P><H3><A NAME="Header_372">8.7.3 ERROR</A></H3>
Display help information for a particular return code.
<P>
<P><H4><A NAME="Header_373">Syntax</A></H4>
<PRE>
&#91;SERVICE &lt;Service name&gt;&#93; ERROR &lt;Return code&gt;
</PRE>
<P><TT>SERVICE</TT> indicates that only information specific to the given
service should be return.  Otherwise, information will be returned for all
services which have registered the indicated return code.
<P><TT>ERROR</TT> specifies the return code about which you want information
<P>
<P><H4><A NAME="Header_374">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_375">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_376">Results</A></H4>
<P>If successful, the result buffer will contain information
about the request based on the options specified: 
<UL>
<P><LI>
The result buffer for a <TT>"SERVICE &lt;Service Name&gt; Error &lt;Return Code&gt;"</TT>
request or for an <TT>"ERROR &lt;Return Code&gt;"</TT> request (if the
return code specified is less then 4000) will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Help/ErrorDetails&gt;</TT> representing
information about the specified error.  The map is defined as follows:
<BR>
<P><B><A NAME="Table_33">Table 33. Definition of map class STAF/Service/Help/ErrorDetails</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information about an error.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">details
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Details
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR></TABLE>
<P>
<P><LI>The result buffer for an <TT>"ERROR &lt;Return Code&gt;"</TT> request (if the
return code specified is 4000 or greater) will contain
a marshalled <TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Help/ServiceError&gt;</TT>
representing the errors registered by all external services with the
specified return code.  The map is defined as follows:
<BR>
<P><B><A NAME="Table_34">Table 34. Definition of map class STAF/Service/Help/ErrorDetails</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information about an error
registered by an external service.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">details
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Details
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_377">Examples</A></H4>
<P>
<UL>
<P><LI>
<B>Goal:</B> Show me information on STAF error 22
<P><B>Syntax:</B> <TT>ERROR 22</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in default format, could look like:
<PRE>
Description: Communication error
Details    :
This indicates an error transmitting data across the network, or to the local
STAF process.  For example, you would receive this error if STAFProc.exe was
terminated in the middle of a service request, or if a bridge went down in the
middle of a remote service request.
</PRE>
<P>
<P><LI><B>Goal:</B> Show me all the information on STAF error 4007
<P><B>Syntax:</B> <TT>ERROR 4007</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in verbose format, could look like:
<PRE>
[
  {
    Service    : LOG
    Description: Invalid file format
    Details    : An invalid/unknown record format was encountered while reading the log file
  }
  {
    Service    : RESPOOL
    Description: Resource pool has no entries available
    Details    : The resource pool has no entries
  }
]
</PRE>
<P><LI>
<B>Goal:</B> Show me only Log service information on STAF error 4007
<P><B>Syntax:</B> <TT>SERVICE Log ERROR 4007</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in default format, could look like:
<PRE>
Description: Invalid file format
Details    : An invalid/unknown record format was encountered while reading the log file
</PRE>
</UL>
<A NAME="IDX346"></A>
<P><H3><A NAME="Header_378">8.7.4 REGISTER</A></H3>
Allows a service to register return codes with the Help service.
<P>
<P><H4><A NAME="Header_379">Syntax</A></H4>
<PRE>
REGISTER SERVICE &lt;Service name&gt; ERROR &lt;Return code&gt;
         INFO &lt;String&gt; DESCRIPTION &lt;String&gt;
</PRE>
<P><TT>SERVICE</TT> indicates the service for which to register information
<P><TT>ERROR</TT> indicates the return code for which to register information
<P><TT>INFO</TT> specifies a short description string which is displayed
when using the Help service's LIST command.
<P><TT>DESCRIPTION</TT> specifies the full information about the return code.
This information is displayed when using the Help service's ERROR command.
<P>
<P><H4><A NAME="Header_380">Security</A></H4>
<P>This command requires trust level 3.
<P>This command is only valid when issued by local services.
<P>
<P><H4><A NAME="Header_381">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_382">Results</A></H4>
<P>If successful, the result buffer will be empty.
<P>
<P><H4><A NAME="Header_383">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Register the Log services 4008 return code
<P><B>Syntax:</B>
<P><TT>REGISTER SERVICE Log ERROR 4008 INFO "Unable to purge all log records" DESCRIPTION "Your PURGE criteria selected every record in the log file.  Use DELETE if you{STAF/Config/Sep/Line}really want to delete every record.  Or, modify your PURGE criteria."</TT>
</UL>
<A NAME="IDX349"></A>
<P><H3><A NAME="Header_384">8.7.5 UNREGISTER</A></H3>
Allows a service to unregister return codes with the Help service.
<P>
<P><H4><A NAME="Header_385">Syntax</A></H4>
<PRE>
UNREGISTER SERVICE &lt;Service name&gt; ERROR &lt;Return code&gt;
</PRE>
<P><TT>SERVICE</TT> indicates the service for which to unregister information
<P><TT>ERROR</TT> indicates the return code for which to unregister
information
<P>
<P><H4><A NAME="Header_386">Security</A></H4>
<P>This command is only valid when issued by local services.
<P>
<P><H4><A NAME="Header_387">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_388">Results</A></H4>
<P>If successful, the result buffer will be empty.
<P>
<P><H4><A NAME="Header_389">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Unregister the Log services 4008 return code
<P><B>Syntax:</B>
<P><TT>UNREGISTER SERVICE Log ERROR 4008</TT>
</UL>
<A NAME="IDX351"></A>
<P><H3><A NAME="Header_390">8.7.6 Help Error Code Reference</A></H3>
<P>All return codes from Help are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<A NAME="IDX352"></A>
<A NAME="IDX354"></A>
<HR><H2><A NAME="HDRLIFECYCLESRV" HREF="#ToC_391">8.8 LifeCycle Service</A></H2>
<P><H3><A NAME="Header_392">8.8.1 Description</A></H3>
The LifeCycle service is one of the internal STAF services.  It allows STAF
service requests to be run when STAFProc starts up or shuts down.
<P>The LifeCycle service provides the following commands.
<UL COMPACT>
<LI>REGISTER - Allows you to register a STAF service request to be run either
when STAFProc starts up or shuts down
<LI>UNREGISTER - Allows you to unregister a STAF service request
<LI>UPDATE - Allows you to update fields in a registration
<LI>LIST - Allows you to list information about the STAF service requests
that are registered
<LI>QUERY - Allows you to get information about a STAF service
request that is registered
<LI>TRIGGER - Allows you to submit a single registered STAF service request,
or to submit all STAF service requests registered to be run when STAFProc
starts up or shuts down.  It is useful for testing the registrations.
<LI>ENABLE - Allows you to enable a STAF service request that is registered
<LI>DISABLE - Allows you to disable a STAF service request that is registered
<LI>HELP &#45; Returns syntax information
</UL>
<P>
The registrations for the LifeCycle service are persistent.  This means
that if STAF is shutdown and restarted (or if the machine is rebooted),
the prior registration information for the LifeCycle service will still exist.
When STAFProc starts, it reads in the existing registration data and executes
the enabled registered STAF service requests with the "Startup" phase specified.
When STAFProc is shutdown, it reads in the existing registration data and
executes the enabled registered STAF service requests with the "Shutdown" phase
specified.  The LifeCycle service's registration data is stored in file
<TT>{STAF/DataDir}/service/lifecycle/lifecycle.reg</TT>.
<P>
The STAF LifeCycle service maintains a STAF machine log where it writes
information about the STAF service requests that have been registered with
the LifeCycle service and that it has submitted.  When debugging a problem
with a registration for the LifeCycle service, be sure to check the LifeCycle
service log to determine the results of STAF service requests submitted by
the LifeCycle service.  See <A HREF="#HDRLIFECYCLESERVICELOG">8.8.11, "LifeCycle Service Logging"</A> for more
information on the LifeCycle service log.
<A NAME="IDX357"></A>
<P><H3><A NAME="Header_393">8.8.2 REGISTER</A></H3>
Allows you to register STAF service requests to be run either when
STAFProc starts up or shuts down.
<P>
Each STAF service request that is registered will be submitted
synchronously when STAFProc starts up or shuts down, or is triggered
via a <TT>TRIGGER</TT> request.  This means that if you register
a STAF service request that never completes (e.g. a <TT>PROCESS START
WAIT</TT> request without a <TT>TIMEOUT</TT> option for a command
that never completes, or a <TT>SEM MUTEX REQUEST</TT> request with a
<TT>TIMEOUT</TT> option for a mutex semaphore that never becomes
available), then if registered for the <TT>Startup</TT> phase, STAFProc
will not complete starting up.  Or, if registered for the <TT>Shutdown</TT>
phase, STAFProc will not complete shutting down.
<P>
<P><H4><A NAME="Header_394">Syntax</A></H4>
<PRE>
REGISTER PHASE &lt;Startup | Shutdown&gt;
         MACHINE &lt;Machine&gt; SERVICE &lt;Service&gt; REQUEST &lt;Request&gt;
         [ONCE] [PRIORITY &lt;Priority&gt;] [DESCRIPTION &lt;Description&gt;]
</PRE>
<P><TT>PHASE</TT> specifies when the service request will be submitted.
Valid values are "Startup" and "Shutdown" (case-insensitive).
Specifying "Startup" indicates to submit the service request when
STAFProc starts up.  Specifying "Shutdown" indicates to submit the
service request when STAFProc shuts down.
This option will resolve variables.
<P><TT>MACHINE</TT> specifies the endpoint for a machine where the
service request will be submitted.
<P><TT>SERVICE</TT> specifies the name of the STAF service to which
a request will be submitted.
<P><TT>REQUEST</TT> specifies the request to be submitted to the
specified service.
<P><TT>ONCE</TT> specifies that the STAF service request should only be
executed once. After the STAF service request has been submitted at Startup or
Shutdown (depending on the specified phase), the ID for this request will
be unregistered.
<P><TT>PRIORITY</TT> specifies the priority of the registration which is
used in determining the order in which the registration will be submitted
(if there is more than one registration) when STAFProc starts up or shuts
down.  It must be a number from 1 to 99.  The default is 50.
Registrations with priority 1 will be submitted first, followed by
registrations with priority 2, and so on.
Registrations with the same priority will be submitted in order by
registration ID.
This option will resolve variables.
<P><TT>DESCRIPTION</TT> specifies a description of the registration.
It is for informational purposes only and is optional.
<P>
<P><H4><A NAME="Header_395">Security</A></H4>
<P>This command requires trust level 5.
<P>
<P><H4><A NAME="Header_396">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_397">Results</A></H4>
<P>If successful, the result buffer will contain the registration ID.
<P>
<P><H4><A NAME="Header_398">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Register to start a process that runs command
"C:/tests/TestA.exe" on machine client1.company.com whenever STAFProc
starts up and specify priority 25 for the registration.
<P><B>Syntax:</B>
<P><TT>REGISTER PHASE Startup MACHINE client1.company.com SERVICE Process
REQUEST "START SHELL COMMAND C:/tests/TestA.exe" DESCRIPTION "Start TestA"</TT>
<P>
<P><LI><B>Goal:</B> Register to run STAX job /test/TestA.xml on machine
server1 whenever STAFProc starts up.  Pass the STAX job's main function a
Python map of arguments as follows:  {'testMachine': 'client1', 'serverMach': 'server1'}
<P><B>Syntax:</B>
<P><TT>REGISTER PHASE Startup MACHINE server1 SERVICE STAX REQUEST 
"EXECUTE FILE /tests/TestA.xml ARGS \"{'testMach': 'client1',
'serverMach': 'server1'}\""</TT>
<P>
<P><LI><B>Goal:</B> Register to start a process that runs command
"C:/tests/TestB.exe" on the local machine whenever STAFProc is shut down and
give it description "Start TestB".
<P><B>Syntax:</B>
<P><TT>REGISTER PHASE Shutdown MACHINE local SERVICE Process REQUEST
"START SHELL COMMAND C:/tests/TestB.exe" DESCRIPTION "Start TestB"</TT>
<P>
<P><LI><B>Goal:</B> Register to send a "STAF Startup" type message to the
queue of a handle named MyTestHandle on machine server1 the next time
STAFProc starts up (and then unregister this ID so the message is only sent
once).
<P><B>Syntax:</B>
<P><TT>REGISTER PHASE Startup MACHINE server1 SERVICE QUEUE REQUEST 
"QUEUE NAME MyTestHandle TYPE &#58;12&#58;STAF Startup MESSAGE &#58;0&#58;" ONCE</TT>
</UL>
<A NAME="IDX360"></A>
<P><H3><A NAME="Header_399">8.8.3 UNREGISTER</A></H3>
Allows you to unregister STAF service requests with the LifeCycle service.
<P>
<P><H4><A NAME="Header_400">Syntax</A></H4>
<PRE>
UNREGISTER ID &lt;Registration ID&gt;
</PRE>
<P><TT>ID</TT> specifies the registration ID of the STAF service request
to be unregistered.
<P>
<P><H4><A NAME="Header_401">Security</A></H4>
<P>This command requires trust level 5.
<P>
<P><H4><A NAME="Header_402">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_403">Results</A></H4>
<P>If successful, the result buffer will be empty.
<P>
<P><H4><A NAME="Header_404">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Unregister the service request with registration ID 2.
<P><B>Syntax:</B>
<P><TT>UNREGISTER ID 2</TT>
</UL>
<A NAME="IDX363"></A>
<P><H3><A NAME="Header_405">8.8.4 UPDATE</A></H3>
Allows you to update one or more fields for a registration.
<P>
<P><H4><A NAME="Header_406">Syntax</A></H4>
<PRE>
UPDATE ID &lt;Registration ID&gt; [PRIORITY &lt;Priority&gt;] [ONCE &lt;True | False&gt;]
          [MACHINE &lt;Machine&gt;] [SERVICE &lt;Service&gt;] [REQUEST &lt;Request&gt;]
          [PHASE &lt;Startup | Shutdown&gt;] [DESCRIPTION &lt;Description&gt;]
</PRE>
<P><TT>ID</TT> specifies the registration ID of the STAF service request
to be updated.
<P><TT>PRIORITY</TT> specifies the priority of the registration which is
used in determining the order in which the registration will be submitted
(if there is more than one registration) when STAFProc starts up or shuts
down.  It must be a number from 1 to 99.
Registrations with priority 1 will be submitted first, followed by
registrations with priority 2, and so on.
Registrations with the same priority will be submitted in order by
registration ID.
This option will resolve variables.
<P><TT>ONCE</TT> specifies whether the STAF service request should only be
executed once. Valid values are "True" and "False" (case-insensitive).
Specifying "True" indicates to submit the STAF service request only once
which means after the STAF service request has been submitted at Startup or
Shutdown (depending on the specified phase), this registration will be
unregistered.  Specifying "False" indicates that the STAF service request
should be submitted each time STAFProc starts up or shuts down (depending
on the specified phase).
This option will resolve variables.
<P><TT>MACHINE</TT> specifies the endpoint for a machine where the
service request will be submitted.
<P><TT>SERVICE</TT> specifies the name of the STAF service to which
a request will be submitted.
<P><TT>REQUEST</TT> specifies the request to be submitted to the
specified service.
<P><TT>PHASE</TT> specifies when the service request will be submitted.
Valid values are "Startup" and "Shutdown" (case-insensitive).
Specifying "Startup" indicates to submit the service request when
STAFProc starts up.  Specifying "Shutdown" indicates to submit the
service request when STAFProc shuts down.
This option will resolve variables.
<P><TT>DESCRIPTION</TT> specifies a description of the registration.
It is for informational purposes only and is optional.
<P>
<P><H4><A NAME="Header_407">Security</A></H4>
<P>This command requires trust level 5.
<P>
<P><H4><A NAME="Header_408">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_409">Results</A></H4>
<P>If successful, the result buffer will be empty.
<P>
<P><H4><A NAME="Header_410">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Update the priority of registration ID 2 to have
priority 25 and description "Run TestA".
<P><B>Syntax:</B>
<P><TT>UPDATE ID 2 PRIORITY 25 DESCRIPTION "Run TestA"</TT>
</UL>
<A NAME="IDX366"></A>
<P><H3><A NAME="Header_411">8.8.5 LIST</A></H3>
Allows you to list the information about the STAF service requests
registered with the LifeCycle service.  The registrations will be
listed in the order in which they will be submitted, which is by
phase (Startup registrations first, followed by Shutdown registrations),
and then in ascending order by priority within the same phase, and then
in ascending order by registration ID within the same phase/priority.
<P>
<P><H4><A NAME="Header_412">Syntax</A></H4>
<PRE>
LIST &#91;PHASE &lt;Startup | Shutdown&gt;&#93; &#91;LONG&#93;
</PRE>
<P><TT>PHASE</TT> specifies to list only the registrations with a
matching phase.  Valid values for "Startup" and "Shutdown" (case-insensitive).
This option will resolve variables.
<P><TT>LONG</TT> specifies to include all of the registration information,
including the description for each registration.
<P>
<P><H4><A NAME="Header_413">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_414">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_415">Results</A></H4>
<P>If successful, the result buffer will contain information
about the request based on the options specified: 
<UL>
<P><LI>The result buffer for a <TT>LIST</TT> request without the
<TT>LONG</TT> option will contain a marshalled <TT>&lt;List&gt; of
&lt;Map&#58;STAF/Service/LifeCycle/Reg&gt;</TT> representing the matching
registrations for the LifeCycle service.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_35">Table 35. Definition of map class STAF/Service/LifeCycle/Reg</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information about
a registration.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">phase
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Phase
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">'Startup' | 'Shutdown'
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">priority
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Priority
<BR>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">'1' - '99'
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">id
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">ID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">state
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">State
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">'Enabled' | 'Disabled'
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Private data will be masked
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">once
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Once
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">'True' | 'False'
</TD></TR></TABLE>
<P>
<P><LI>
<P>The result buffer for a <TT>LIST</TT> with the <TT>LONG</TT>
option will contain a marshalled <TT>&lt;List&gt; of
&lt;Map&#58;STAF/Service/LifeCycle/RegDetails&gt;</TT> representing the
matching registrations for the LifeCycle service. 
The map is defined as follows:
<BR>
<P><B><A NAME="Table_36">Table 36. Definition of map class STAF/Service/LifeCycle/RegDetails</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents detailed 
information about a registration.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">phase
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Phase
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">'Startup' | 'Shutdown'
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">priority
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Priority
<BR>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">'1' - '99'
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">id
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">ID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">state
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">State
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">'Enabled' | 'Disabled'
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Private data will be masked
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">once
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Once
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">'True' | 'False'
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_416">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> List all the registrations for the LifeCycle service.
<P><B>Syntax:</B> <TT>LIST</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in table format, could look like:
<PRE>
Phase   P  ID State   Machine Service Request                              Once
------- -- -- ------- ------- ------- ------------------------------------ ----
Startup 25 1  Enabled local   PROCESS START SHELL COMMAND C:/tests/TestA.e Fals
                                      xe                                   e
Startup 25 4  Enabled client1 PROCESS START SHELL COMMAND C:/test/TestB.ex Fals
                                      e WAIT                               e
Startup 40 3  Disable local   PROCESS START SHELL COMMAND C:/test/TestC.ex Fals
              d                       e WAIT                               e
Startup 50 5  Enabled server1 STAX    EXECUTE FILE C:/stax/jobA.xml        Fals
                                                                           e
Shutdow 25 2  Enabled local   PROCESS START SHELL COMMAND C:/tests/TestTer True
n                                     m.exe                                
Shutdow 50 6  Enabled server1 STAX    EXECUTE FILE C:/stax/jobTerm.xml     Fals
n                                                                          e
</PRE>
<P>
<P><LI>
<B>Goal:</B> List the startup registrations for the LifeCycle service.
<P><B>Syntax:</B> <TT>LIST PHASE Startup</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in table format, could look like:
<PRE>
Phase   P  ID State   Machine Service Request                              Once
------- -- -- ------- ------- ------- ------------------------------------ ----
Startup 25 1  Enabled local   PROCESS START SHELL COMMAND C:/tests/TestA.e Fals
                                      xe                                   e
Startup 25 4  Enabled client1 PROCESS START SHELL COMMAND C:/test/TestB.ex Fals
                                      e WAIT                               e
Startup 40 3  Disable local   PROCESS START SHELL COMMAND C:/test/TestC.ex Fals
              d                       e WAIT                               e
Startup 50 5  Enabled server1 STAX    EXECUTE FILE C:/stax/jobA.xml        Fals
                                                                           e 
</PRE>
<P>
<P><LI>
<B>Goal:</B> List the shutdown registrations for the LifeCycle service.
<P><B>Syntax:</B> <TT>LIST PHASE Shutdown</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in table format, could look like:
<PRE>
Phase    P  ID State   Machine Service Request                             Once
-------- -- -- ------- ------- ------- ----------------------------------- ----
Shutdown 25 2  Enabled local   PROCESS START SHELL COMMAND C:/tests/TestTe True
                                       rm.exe
Shutdown 50 6  Enabled server1 STAX    EXECUTE FILE C:/stax/jobTerm.xml    Fals
                                                                           e
</PRE>
<P>
<P><LI>
<B>Goal:</B> List the startup registrations for the LifeCycle service
in the long format.
<P><B>Syntax:</B> <TT>LIST PHASE Startup LONG</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in table format, could look like:
<PRE>
Phase   P  ID State   Machine Service Request                 Description Once
------- -- -- ------- ------- ------- ----------------------- ----------- -----
Startup 25 1  Enabled local   PROCESS START SHELL COMMAND C:/ Run TestA   False
                                      tests/TestA.exe                                 
Startup 25 4  Enabled client1 PROCESS START SHELL COMMAND C:/ Run TestB   False
                                      test/TestB.exe WAIT
Startup 40 3  Disable local   PROCESS START SHELL COMMAND C:/ Run TestC   False
              d                       test/TestC.exe WAIT                             
Startup 50 5  Enabled server1 STAX    EXECUTE FILE C:/stax/jo Run STAX Jo False
                                      bA.xml                  bA          
</PRE>
</UL>
<A NAME="IDX369"></A>
<P><H3><A NAME="Header_417">8.8.6 QUERY</A></H3>
Allows you to get information about a STAF service request
registered with the LifeCycle service.
<P>
<P><H4><A NAME="Header_418">Syntax</A></H4>
<PRE>
QUERY ID &lt;Registration ID&gt;
</PRE>
<P><TT>ID</TT> specifies the registration ID of the STAF service request
to be queried.
This option will resolve variables.
<P>
<P><H4><A NAME="Header_419">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_420">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_421">Results</A></H4>
<P>If successful, the result buffer will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/LifeCycle/RegQuery&gt;</TT> representing
information about the registration.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_37">Table 37. Definition of map class STAF/Service/LifeCycle/RegQuery</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information about
a registration.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">phase
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Phase
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">'Startup' | 'Shutdown'
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">priority
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Priority
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">'1' - '99'
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">id
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">ID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">state
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">State
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">'Enabled' | 'Disabled'
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Private data will be masked
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">once
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Once
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">'True' | 'False'
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_422">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Query registration ID 5 for the LifeCycle service.
<P><B>Syntax:</B> <TT>QUERY 5</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
Phase      : Startup
Priority   : 50
ID         : 5
State      : Enabled
Machine    : server1
Service    : STAX
Request    : EXECUTE FILE C:/stax/jobA.xml
Description: Run STAX JobA
Once       : False
</PRE>
</UL>
<A NAME="IDX372"></A>
<P><H3><A NAME="Header_423">8.8.7 TRIGGER</A></H3>
Allows you to submit a single registered STAF service request, or to
submit all STAF service requests registered to be run at the Startup
or Shutdown phase.  It is useful for testing the registrations without
requiring that STAFProc be started or shutdown.
<P>
Only enabled STAF requests will be submitted by a <TT>TRIGGER PHASE</TT>
request.  A <TT>TRIGGER ID</TT> request will submit enabled and disabled
STAF requests.  Each STAF service request that is triggered will be
submitted synchronously (e.g. waits for the STAF service request to complete)
before returning or submitting the next STAF service request if the
<TT>PHASE</TT> option was specified and there are more STAF service
requests registered for the specified phase.  This means that if you register
a STAF service request that never completes (e.g. a <TT>PROCESS START</TT>
request using the <TT>WAIT</TT> option but not the <TT>TIMEOUT</TT> option,
or a <TT>SEM MUTEX REQUEST</TT> request without a <TT>TIMEOUT</TT> option
for a mutex semaphore that never becomes available), then the
<TT>TRIGGER</TT> request will never complete.
Note that if the submitted STAF service request was registered with the
ONCE option, triggering the STAF command will not cause the registration
to be unregistered.
<P>
<P><H4><A NAME="Header_424">Syntax</A></H4>
<PRE>
TRIGGER &lt;ID &lt;Registration ID&gt; { PHASE &lt;Startup | Shutdown&gt;&gt; CONFIRM
</PRE>
<P><TT>ID</TT> specifies the registration ID of the STAF service request
to be triggered.
This option will resolve variables.
<P><TT>PHASE</TT> specifies to trigger all the registrations with
a matching phase.  Valid values are "Startup" and "Shutdown"
(case-insensitive).
This option will resolve variables.
<P><TT>CONFIRM</TT> specifies you really want to trigger submitting
the STAF service requests specified by the matching registration(s).
<P>
<P><H4><A NAME="Header_425">Security</A></H4>
<P>This command requires trust level 5.
<P>
<P><H4><A NAME="Header_426">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_427">Results</A></H4>
<P>If successful, the result buffer will contain information
about the request based on the options specified: 
<UL>
<P><LI>The result buffer for a <TT>TRIGGER ID</TT> request will contain
a marshalled <TT>&lt;Map&#58;STAF/Service/LifeCycle/TriggerId&gt;</TT>
representing information about the submitted STAF service request.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_38">Table 38. Definition of map class STAF/Service/LifeCycle/TriggerId</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information about
the submitted STAF service request.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Private data will be masked
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">RC
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;Marshalling Context&gt;</TT>.
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>"RC" contains the return code from submitting the STAF service request.
<LI>"Result" contains the result from submitting the STAF service request.
If the service request returns marshalled data, the "Result" will contain
a marshalling context representing the result from submitting the STAF
service request.
</OL>
</TD></TR></TABLE>
<P>
<P><LI>The result buffer for a <TT>TRIGGER PHASE</TT> request will
contain a marshalled <TT>&lt;List&gt; of
&lt;Map&#58;STAF/Service/LifeCycle/TriggerIds&gt;</TT> representing
information about each submitted STAF service request.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_39">Table 39. Definition of map class STAF/Service/LifeCycle/TriggerIds</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information about
the submitted STAF service requests.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">id
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">ID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Private data will be masked
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">RC
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;Marshalling Context&gt;</TT>.
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>"RC" contains the return code from submitting the STAF service request.
<LI>"Result" contains the result from submitting the STAF service request.
If the service request returns marshalled data, the "Result" will contain
a marshalling context representing the result from submitting the STAF
service request.
</OL>
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_428">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Submit the STAF service request specified for
registration ID 5.
<P><B>Syntax:</B> <TT>TRIGGER ID 5 CONFIRM</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like the following if the
registration submitted a "EXECUTE FILE C:/stax/jobA.xml" request to the
STAX service on machine server1:
<PRE>
    Machine: server1
    Service: STAX
    Request: EXECUTE FILE C:/stax/jobA.xml
    RC     : 0
    Result : 4
</PRE>
<P>
<P><LI><B>Goal:</B> Submit the STAF service request(s) specified to run
when STAFProc starts up.
<P><B>Syntax:</B> <TT>TRIGGER PHASE Startup CONFIRM</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in verbose format, could look like the following:
<PRE>
    [
      {
        ID     : 1
        Machine: local
        Service: PROCESS
        Request: START SHELL COMMAND C:/tests/TestA.exe
        RC     : 0
        Result : 58
      }
      {
        ID     : 4
        Machine: client1
        Service: PROCESS
        Request: START SHELL COMMAND C:/test/TestB.exe WAIT
        RC     : 0
        Result : {
          Return code: 0
          Key        : &lt;None&gt; 
          Files      : [
            {
              Return code: 0
              Data       : TestB was successful
            }
          ]
        }
      }
      {
        ID     : 5
        Machine: server1
        Service: STAX
        Request: EXECUTE FILE C:/stax/jobA.xml
        RC     : 0
        Result : 4
      }
    ]
</PRE>
<P>
<P><LI><B>Goal:</B> Submit the STAF service request(s) specified to run
when STAFProc shuts down.
<P><B>Syntax:</B> <TT>TRIGGER PHASE Shutdown CONFIRM</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in tabular format, could look like the following:
<PRE>
    ID Machine Service Request          RC Result
    -- ------- ------- ---------------- -- ----------------------------------------
    2  local   PROCESS START SHELL COMM 0  293
                       AND C:/tests/Tes
                       tTerm.exe
    6  server1 STAX    EXECUTE FILE C:/ 16 STAFConnectionProviderConnect: Timed out
                       stax/jobTerm.xml     connecting to endpoint: select() timeou
                                           t: 22, Endpoint: tcp://server1
</PRE>
</UL>
<A NAME="IDX375"></A>
<P><H3><A NAME="Header_429">8.8.8 ENABLE</A></H3>
Allows you to enable a registration for the LifeCycle service.
This means that the STAF service request for this registration will be
submitted when STAFProc starts up or shuts down (depending on the phase
specified for the registration).
<P>
<P><H4><A NAME="Header_430">Syntax</A></H4>
<PRE>
ENABLE ID &lt;Registration ID&gt;
</PRE>
<P><TT>ID</TT> specifies the registration ID which is to be enabled.
<P>
<P><H4><A NAME="Header_431">Security</A></H4>
<P>This command requires trust level 5.
<P>
<P><H4><A NAME="Header_432">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_433">Results</A></H4>
<P>If successful, the result buffer will be empty.
Note that an error will not be returned if the registration ID is already
enabled.
<P>
<P><H4><A NAME="Header_434">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Enable registration ID 2.
<P><B>Syntax:</B>
<P><TT>ENABLE ID 2</TT>
</UL>
<A NAME="IDX378"></A>
<P><H3><A NAME="Header_435">8.8.9 DISABLE</A></H3>
Allows you to disable a registration for the LifeCycle service.
This means that the STAF service request for this registration will not be
submitted when STAFProc starts up or shuts down (depending on the phase
specified for the registration).
<P>
<P><H4><A NAME="Header_436">Syntax</A></H4>
<PRE>
DISABLE ID &lt;Registration ID&gt;
</PRE>
<P><TT>ID</TT> specifies the registration ID which is to be disabled.
<P>
<P><H4><A NAME="Header_437">Security</A></H4>
<P>This command requires trust level 5.
<P>
<P><H4><A NAME="Header_438">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_439">Results</A></H4>
<P>If successful, the result buffer will be empty.
Note that an error will not be returned if the registration ID is already
disabled.
<P>
<P><H4><A NAME="Header_440">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Enable registration ID 2.
<P><B>Syntax:</B>
<P><TT>ENABLE ID 2</TT>
</UL>
<A NAME="IDX380"></A>
<P><H3><A NAME="Header_441">8.8.10 LifeCycle Error Code Reference</A></H3>
<P>All return codes from the LifeCycle service are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<A NAME="IDX382"></A>
<P><H3><A NAME="HDRLIFECYCLESERVICELOG">8.8.11 LifeCycle Service Logging</A></H3>
<P>
The STAF LifeCycle service maintains a STAF machine log where it writes
information about the STAF service requests that have been registered with
the LifeCycle service and that it has submitted.  When debugging a problem
with a registration for the LifeCycle service, be sure to check the LifeCycle
service log to determine the results of STAF service requests submitted by
the LifeCycle service.
<P>
The logname for the STAF LifeCycle service is LIFECYCLE.
Note that tags like <TT>[ID=&lt;id&gt;]</TT> in the log entries can be useful
when querying the LifeCycle service log by using the <TT>CONTAINS</TT>
option in the LOG QUERY request.
<P>
For example:
<P>
<UL>
<P><LI>To query the entries for registration ID 1 in the LifeCycle service log
on the local machine, you could specify:
<P>
<PRE>
STAF local LOG QUERY MACHINE {STAF/Config/MachineNickname} LOGNAME LIFECYCLE CONTAINS "[ID=1]"
Response
--------
Date-Time         Level Message
----------------- ----- -------------------------------------------------------
20071127-17:45:19 Info  [ID=1] [client10.company.com, STAF/Client, 24] Register
                         request: register phase Startup machine local service
                        PROCESS request &#58;38&#58;START SHELL COMMAND C:/tests/TestA.
                        exe priority 25 description &#58;9&#58;Run TestA
20071127-18:05:56 Info  [ID=1] [client10.company.com, STAF/Client, 48] [TRIGGER
                         Startup] Submitted: STAF local PROCESS START SHELL COM
                        MAND C:/tests/TestA.exe
20071127-18:05:56 Info  [ID=1] [client10.company.com, STAF/Client, 48] [TRIGGER
                         Startup] Completed. RC=0, Result=49
20071128-11:37:37 Info  [ID=1] [client10.company.com, STAF_Process, 1] [TRIGGER
                         Startup] Submitted: STAF local PROCESS START SHELL COM
                        MAND C:/tests/TestA.exe
20071128-11:37:37 Info  [ID=1] [client10.company.com, STAF_Process, 1] [TRIGGER
                         Startup] Completed. RC=0, Result=22
</PRE>
<P>
<P><LI>To query the entries for registration ID 2 in the LifeCycle service log
on the local machine, you could specify:
<P>
<PRE>
STAF local lOG QUERY MACHINE {STAF/Config/MachineNickname} LOGNAME LIFECYCLE CONTAINS "[ID=2]"
Response
--------
Date-Time         Level Message
----------------- ----- -------------------------------------------------------
20071127-17:46:18 Info  [ID=2] [client10.company.com, STAF/Client, 25] Register
                         request: register phase Shutdown machine local service
                         PROCESS request &#58;41&#58;START SHELL COMMAND C:/tests/TestT
                        erm.exe priority 25
20071127-18:08:54 Info  [ID=2] [client10.company.com, STAF/Client, 50] [TRIGGER
                         Shutdown] Submitted: STAF local PROCESS START SHELL CO
                        MMAND C:/tests/TestTerm.exe
20071127-18:08:54 Info  [ID=2] [client10.company.com, STAF/Client, 50] [TRIGGER
                         Shutdown] Completed. RC=0, Result=51
20071128-11:36:27 Info  [ID=2] [client10.company.com, STAF_Process, 1] [TRIGGER
                         Shutdown] Submitted: STAF local PROCESS START SHELL CO
                        MMAND C:/tests/TestTerm.exe
20071128-11:36:27 Info  [ID=2] [client10.company.com, STAF_Process, 1] [TRIGGER
                         Shutdown] Completed. RC=0, Result=78
</PRE>
</UL>
<P>
The LifeCycle service will log an entry when the following actions occur:
<UL>
<P><LI>When a <TT>REGISTER</TT> request is received, a log entry with level
"Info" is logged with message:
<P>
<TT>
[ID=&lt;id&gt;] [&lt;orgMachine&gt;, &lt;orgHandleName&gt;, &lt;orgHandle#&gt;] Register request: &lt;request&gt;
</TT>
<P>
where:
<UL COMPACT>
<LI><TT>&lt;id&gt;</TT> is the registration ID,
<LI><TT>&lt;orgMachine&gt;</TT> is the machine that originated the request,
<LI><TT>&lt;orgHandleName&gt;</TT> is the name or the handle that originated the request,
<LI><TT>&lt;orgHandle#&gt;</TT> is the handle number that originated the request,
<LI><TT>&lt;request&gt;</TT> is the <TT>REGISTER</TT> request.
</UL>
<P>
<P><LI>When a <TT>UNREGISTER</TT> request is received, a log entry with
level "Info" is logged with message:
<P>
<TT>
[ID=&lt;id&gt;] [&lt;orgMachine&gt;, &lt;orgHandleName&gt;, &lt;orgHandle#&gt;] Unregistered.
</TT>
<P>
where:
<UL COMPACT>
<LI><TT>&lt;id&gt;</TT> is the registration ID,
<LI><TT>&lt;orgMachine&gt;</TT> is the machine that originated the request,
<LI><TT>&lt;orgHandleName&gt;</TT> is the name or the handle that originated the request,
<LI><TT>&lt;orgHandle#&gt;</TT> is the handle number that originated the request,
</UL>
<P>
<P><LI>When STAFProc is started or when a <TT>TRIGGER PHASE Startup</TT>
request is submitted, each enabled registration with phase "Startup"
will have its STAF service request submitted and a log entry with level
"Info" is logged with message:
<TT>
[ID=&lt;id&gt;] [&lt;orgMachine&gt;, &lt;orgHandleName&gt;, &lt;orgHandle#&gt;] [TRIGGER Startup] 
Submitted: STAF &lt;machine&gt; &lt;service&gt; &lt;request&gt;
</TT>
<P>
where:
<UL COMPACT>
<LI><TT>&lt;id&gt;</TT> is the registration ID,
<LI><TT>&lt;orgMachine&gt;</TT> is the machine that originated the request,
<LI><TT>&lt;orgHandleName&gt;</TT> is the name or the handle that originated the request,
<LI><TT>&lt;orgHandle#&gt;</TT> is the handle number that originated the request,
<LI><TT>&lt;machine&gt;</TT> is where the STAF service request was submitted,
<LI><TT>&lt;service&gt;</TT> is the service to which the STAF service request was submitted,
<LI><TT>&lt;request&gt;</TT> is the STAF service request submitted.
</UL>
<P>
<P><LI>When STAFProc is shutdown or when a <TT>TRIGGER PHASE Shutdown</TT>
request is submitted, each enabled registration with phase "Shutdown"
will have its STAF service request submitted and a log entry with level
"Info" is logged with message:
<TT>
[ID=&lt;id&gt;] [&lt;orgMachine&gt;, &lt;orgHandleName&gt;, &lt;orgHandle#&gt;] [TRIGGER Shutdown] 
Submitted: STAF &lt;machine&gt; &lt;service&gt; &lt;request&gt;
</TT>
<P>
where:
<UL COMPACT>
<LI><TT>&lt;id&gt;</TT> is the registration ID,
<LI><TT>&lt;orgMachine&gt;</TT> is the machine that originated the request,
<LI><TT>&lt;orgHandleName&gt;</TT> is the name or the handle that originated the request,
<LI><TT>&lt;orgHandle#&gt;</TT> is the handle number that originated the request,
<LI><TT>&lt;machine&gt;</TT> is where the STAF service request was submitted,
<LI><TT>&lt;service&gt;</TT> is the service to which the STAF service request was submitted,
<LI><TT>&lt;request&gt;</TT> is the STAF service request submitted.
</UL>
<P>
<P><LI>When a <TT>TRIGGER ID</TT> request for a registration (enabled or
disabled) is submitted, its STAF service request will be submitted and
a log entry with level "Info" is logged with message:
<TT>
[ID=&lt;id&gt;] [&lt;orgMachine&gt;, &lt;orgHandleName&gt;, &lt;orgHandle#&gt;] [TRIGGER ID] 
Submitted: STAF &lt;machine&gt; &lt;service&gt; &lt;request&gt;
</TT>
<P>
where:
<UL COMPACT>
<LI><TT>&lt;id&gt;</TT> is the registration ID,
<LI><TT>&lt;orgMachine&gt;</TT> is the machine that originated the request,
<LI><TT>&lt;orgHandleName&gt;</TT> is the name or the handle that originated the request,
<LI><TT>&lt;orgHandle#&gt;</TT> is the handle number that originated the request,
<LI><TT>&lt;machine&gt;</TT> is where the STAF service request was submitted,
<LI><TT>&lt;service&gt;</TT> is the service to which the STAF service request was submitted,
<LI><TT>&lt;request&gt;</TT> is the STAF service request submitted.
</UL>
<P>
<P><LI>When STAFProc is started or when a <TT>TRIGGER PHASE Startup</TT>
request is submitted, for each disabled registration with phase "Startup",
a log entry with level "Info" is logged with message:
<TT>
[ID=&lt;id&gt;] ID is disabled.  STAF service request not submitted.
</TT>
<P>
where:
<UL COMPACT>
<LI><TT>&lt;id&gt;</TT> is the registration ID of the disabled registration.
</UL>
<P>
<P><LI>When STAFProc is shutdown or when a <TT>TRIGGER PHASE Shutdown</TT>
request is submitted, for each disabled registration with phase "Shutdown",
a log entry with level "Info" is logged with message:
<TT>
[ID=&lt;id&gt;] ID is disabled.  STAF service request not submitted.
</TT>
<P>
where:
<UL COMPACT>
<LI><TT>&lt;id&gt;</TT> is the registration ID of the disabled registration.
</UL>
<P>
<P><LI>When a submitted STAF service request has completed, a log entry
with level "Info" is logged with message:
<TT>
[ID=&lt;id&gt;] [&lt;orgMachine&gt;, &lt;orgHandleName&gt;, &lt;orgHandle#&gt;] 
Completed. RC=&lt;rc&gt;, Result=&lt;result&gt;
</TT>
<P>
where:
<UL COMPACT>
<LI><TT>&lt;id&gt;</TT> is the registration ID,
<LI><TT>&lt;orgMachine&gt;</TT> is the machine that originated the request,
<LI><TT>&lt;orgHandleName&gt;</TT> is the name or the handle that originated the request,
<LI><TT>&lt;orgHandle#&gt;</TT> is the handle number that originated the request,
<LI><TT>&lt;rc&gt;</TT> is the return code from the STAF service request that was submitted,
<LI><TT>&lt;result&gt;</TT> is the result from the STAF service request that was submitted.
</UL>
<P>
<P><LI>When an <TT>UPDATE</TT> request is received, a log entry with
level "Info" is logged with message:
<TT>
[ID=&lt;id&gt;] [&lt;orgMachine&gt;, &lt;orgHandleName&gt;, &lt;orgHandle#&gt;] 
Update request: &lt;request&gt;
</TT>
<P>
where:
<UL COMPACT>
<LI><TT>&lt;id&gt;</TT> is the registration ID,
<LI><TT>&lt;orgMachine&gt;</TT> is the machine that originated the request,
<LI><TT>&lt;orgHandleName&gt;</TT> is the name or the handle that originated the request,
<LI><TT>&lt;orgHandle#&gt;</TT> is the handle number that originated the request,
<LI><TT>&lt;request&gt;</TT> is the UPDATE request.
</UL>
<P>
<P><LI>When an <TT>ENABLE</TT> request is received, a log entry with
level "Info" is logged with message:
<TT>
[ID=&lt;id&gt;] [&lt;orgMachine&gt;, &lt;orgHandleName&gt;, &lt;orgHandle#&gt;] Enabled.
</TT>
<P>
where:
<UL COMPACT>
<LI><TT>&lt;id&gt;</TT> is the registration ID,
<LI><TT>&lt;orgMachine&gt;</TT> is the machine that originated the request,
<LI><TT>&lt;orgHandleName&gt;</TT> is the name or the handle that originated the request,
<LI><TT>&lt;orgHandle#&gt;</TT> is the handle number that originated the request,
</UL>
<P>
<P><LI>When a <TT>DISABLE</TT> request is received, a log entry with
level "Info" is logged with message:
<TT>
[ID=&lt;id&gt;] [&lt;orgMachine&gt;, &lt;orgHandleName&gt;, &lt;orgHandle#&gt;] Disabled.
</TT>
<P>
where:
<UL COMPACT>
<LI><TT>&lt;id&gt;</TT> is the registration ID,
<LI><TT>&lt;orgMachine&gt;</TT> is the machine that originated the request,
<LI><TT>&lt;orgHandleName&gt;</TT> is the name or the handle that originated the request,
<LI><TT>&lt;orgHandle#&gt;</TT> is the handle number that originated the request,
</UL>
</UL>
<P>
<A NAME="IDX383"></A>
<A NAME="IDX385"></A>
<HR><H2><A NAME="HDRLOGSRV" HREF="#ToC_443">8.9 Log Service</A></H2>
<P><H3><A NAME="Header_444">8.9.1 Description</A></H3>
The Log service is an external STAF service that provides the following
functions:
<UL COMPACT>
<LI>LOG - Write data to a log file
<LI>QUERY - Query data from a log file
<LI>LIST - List log file characteristics
<LI>DELETE - Delete a log file
<LI>PURGE - Purge records from a log file
<LI>SET - Set operation characteristics
<LI>HELP &#45; Returns syntax information
</UL>
<P>The purpose of the Log service is to allow a test case to easily and
flexibly manage information that needs to be logged.  It allows you to specify
a log mask which defines which messages actually get logged to the log file.
This log mask can be dynamically changed to alter the set of log messages
written to the log file(s).  This can greatly assist in debugging.  For example,
while a test case is running, you can dynamically alter the log mask to allow
debug and trace log messages to start being logged.  The log query mechanism
allows for record selection based on many selection criteria matches.
<P>The Log service can be run in one of two modes.  In local mode, all log
requests are handled locally, and all log files are stored locally.  In remote
mode, all log requests are forwarded to a central system for processing.  In
addition, all log files are stored on the central system.  While it is possible
to delegate the log service to a central system, this has some unwanted side
effects.  The primary one being that many unwanted messages are likely to be
sent over the network, consuming time and bandwidth.
<P>The following is an example of the major difference between delegating
the Log service and using the Log service in remote logging mode.
<PRE><FONT SIZE="2">
Example Delegated Log
 
                                  NETWORK
            start                    ! start
            info                     ! info
            warning                  ! warning
 +------+   trace    +-----------+   ! trace    +-------+
 ! TEST !-&gt; debug -&gt; !   STAF    !-&gt; ! debug -&gt; ! STAF  ! -&gt; WRITE LOG
 ! CASE !   trace    ! DELEGATED !   ! trace    ! LOG   !    =========
 +------+   error    !   LOG     !   ! error    ! Mask= !    error
            debug    +-----------+   ! debug    ! Error !    fail
            trace                    ! trace    ! Fail  !
            debug                    ! debug    +-------+
            fail                     ! fail
 
 
Example Remote Logging
 
                                 NETWORK
            start                    !
            info                     !
            warning                  !
 +------+   trace    +-----------+   !          +------+
 ! TEST !-&gt; debug -&gt; !  LOG      !-&gt; ! error -&gt; ! STAF ! -&gt; WRITE LOG
 ! CASE !   trace    !  Mask=    !   ! fail     ! LOG  !    =========
 +------+   error    !  Error    !   !          +------+    error
            debug    !  Fail     !   !                      fail
            trace    +-----------+   !
            debug                    !
            fail                     !
</FONT></PRE>
<P>In the above Delegated Log service example, all the messages flowed over
the network to the ultimate log server even though only error and fail
conditions were selected to be logged. In the above Remote Logging example, the
selection of the messages occur at the local box and only those
messages that are selected get sent over the network to the ultimate
log server.
<P><B>Note: </B>When using the Log service in remote logging mode, you should have the
log mask disabled (i.e. log everything) at the ultimate log server to avoid
confusion and multiple log mask filtering.
<A NAME="IDX387"></A>
<P><H3><A NAME="Header_445">8.9.2 Registration</A></H3>
The Log service is an external service and must be registered with the SERVICE
configuration statement. The syntax is:
<PRE>
SERVICE <TT>&lt;Name&gt;</TT> LIBRARY STAFLog &#91;PARMS &lt;Log parameters&gt;&#93;
</PRE>
<P><TT>&lt;Name&gt;</TT> is the name by which the Log service will be known on this
machine.  The recommended name of the Log service is "LOG"
<P><TT>&lt;Log parameters&gt;</TT> are valid log parameters described below.
<P><H4><A NAME="Header_446">Example</A></H4>
<PRE>
service log library STAFLog
service log library STAFLog parms "Directory {STAF/Config/STAFRoot}/logdata ResolveMessage"
</PRE>
<A NAME="IDX389"></A>
<P><H3><A NAME="HDRLOGPARMS">8.9.3 Parameters</A></H3>
<P>The Log service accepts a parameter string in the following formats
<PRE>
&#91;DIRECTORY &lt;Log Directory Root&gt;&#93;
&#91;MAXRECORDSIZE &lt;Size&gt;&#93; &#91;DEFAULTMAXQUERYRECORDS &lt;Number&gt;&#93;
&#91;RESOLVEMESSAGE | NORESOLVEMESSAGE&#93;
&#91;ENABLERESOLVEMESSAGEVAR | DISABLERESOLVEMESSAGEVAR&#93;
</PRE>
or
<PRE>
ENABLEREMOTELOGGING REMOTELOGSERVER &lt;Server name&gt;
                    &#91;REMOTELOGSERVICE &lt;Service Name&gt;&#93;
</PRE>
<P><TT>DIRECTORY</TT> specifies the root directory under which log files are
stored.  The default is <TT>{STAF/DataDir}/service/&lt;Service Name (lower-case)&gt;</TT>.
<P><B>Note: </B>Previously, in STAF 2.x, the default root directory was
<TT>{STAF/Config/STAFRoot}/data/log</TT>.
So, if you want to continue to use the STAF 2.x log files with the
current version of STAF, move the log files to the new default root
directory or specify the old root directory for the <TT>DIRECTORY</TT> parameter.
<P><TT>MAXRECORDSIZE</TT> specifies the maximum length (in characters) of a
logged message.  The default is 100000.
<P><TT>DEFAULTMAXQUERYRECORDS</TT> specifies the maximum number of records
that will be returned if your query criteria selects more records than this number.
The default is 100.  If no limit on the maximum number of records returned by
a query is desired, specify 0.
If a non-zero value is specified, it's equivalent to specifying LAST &lt;Number&gt;.
This limit is only used if none of the following options are specified on a
<TT>QUERY</TT> request:  <TT>FIRST, LAST, ALL, TOTAL, or STATS</TT>.
<P><TT>RESOLVEMESSAGE</TT> specifies that variables in log messages should
be resolved by default.
<P><TT>NORESOLVEMESSAGE</TT> specifies that variables in log messages should
not be resolved by default.  This is the default.
<P><TT>ENABLERESOLVEMESSAGEVAR</TT> specifies that the log service should
check the value of the STAF/Service/&lt;Name&gt;/ResolveMessage variable to determine
if variables in log messages should be resolved.  This option will adversely
affect the performance of the Log service.  See below for more information.
<P><TT>DISABLERESOLVEMESSAGEVAR</TT> specifies that the log service should not
check the value of the STAF/Service/&lt;Name&gt;/ResolveMessage variable to determine
if variables in log messages should be resolved.  See below for more information.
This is the default.
<P><TT>ENABLEREMOTELOGGING</TT> specifies that the Log service should operate
in remote/forwarding mode.
<P><TT>REMOTELOGSERVER</TT> specifies the server to which forwarded log
requests should be sent.  This machine must be running STAF V3.0.0 or later.
<P><B>Note: </B>From a trust perspective, the tcp interface names on the remote log
server and on the machine forwarding requests to it must match or the remote
log server must use a wildcard to match any interface in the trust statement for
the machine that is forwarding log requests to it.
<P><TT>REMOTELOGSERVICE</TT> specifies the service to which forwarded log
requests should be sent.  The default is the same name under which the Log
service was registered on the local machine.
<P><B>Note: </B>All these parameters, with the exception of <TT>DIRECTORY</TT>,
<TT>ENABLEREMOTELOGGING</TT>, <TT>REMOTELOGSERVER</TT>, and
<TT>REMOTELOGSERVICE</TT> may be changed with the <TT>SET</TT> command,
see <A HREF="#HDRLOGSET">8.9.10, "SET"</A> for more information.
<A NAME="IDX391"></A>
<P><H3><A NAME="Header_448">8.9.4 Variables</A></H3>
The following variables will affect the behavior of the Log service.
<DL COMPACT>
<DD><TT>STAF/Service/&lt;Name&gt;/Mask:</TT> A string of log mask descriptions, or a 32 bit binary mask.
<DD><TT>STAF/Service/&lt;Name&gt;/ResolveMessage:</TT> Whether to resolve variables in the message
</DL>
<P><H4><A NAME="Header_449">STAF/Service/&lt;Name&gt;/Mask</A></H4>
The variable determines what messages will and will NOT be written
to the log file. You can set it to only have FATAL and ERROR messages written
to the log file for example, or turn on DEBUG in the middle of a running test.
This allows you to put as much informational, trace, debug, status, etc.
logging messages into your testcases as you want, but based on the circumstance,
dynamically alter the logging levels via configuration, not the testcase.
<P>See <A HREF="#HDRLOGLEV">8.9.11, "Logging Levels Reference"</A> for a complete list of logging levels.
<P>The log mask contains the set of levels that will actually be logged to the
log file.
<DL COMPACT>
<DD><B>Example:</B> set shared var "STAF/Service/Log/Mask=START STOP WARNING FATAL ERROR"
<DD><B>Default:</B> All logging levels will be logged
</DL>
Alternatively, a 32 bit binary string may be specified that determines which logging
levels will be applied.
<DL COMPACT>
<DD><B>Example:</B> set shared var STAF/Service/Log/Mask=11111111000000000000000000000000
</DL>
<P><H4><A NAME="Header_450">STAF/Service/&lt;Name&gt;/ResolveMessage</A></H4>
This variable determines if messages should be resolved before writing them.
If message resolution is desired, then a call to the STAF variable
service is made and all variables in the message are resolved.  If for any reason
the resolution is unsuccessful (e.g. unbalanced braces {}, infinite recursion,
etc.) then an error is generated.
<P><B>Note: </B>This variable is not checked unless the <TT>ENABLERESOLVEMESSAGEVAR</TT>
option has been set.
<DL COMPACT>
<DD><B>Example:</B> set shared var STAF/Service/Log/ResolveMessage=1
<DD><B>Default:</B> 0 (messages are NOT resolved)
</DL>
If a message was "Machine booted from {STAF/Config/BootDrive}" and
STAF/Service/<TT>&lt;Name&gt;</TT>/ResolveMessage was set to 1 then what would
actually be logged would look like: "Machine booted from C:".  If
STAF/Service/<TT>&lt;Name&gt;</TT>/ResolveMessage was not defined or set to 0 then
the original text of the message would be logged:
"Machine booted from {STAF/Config/BootDrive}".
<P><B>Note: </B>There are three places where message resolution can be affected.  They are
evaluated in the following order
<UL COMPACT>
<LI>The <TT>RESOLVEMESSAGE</TT> or <TT>NORESOLEMESSAGE</TT> options on a
<TT>LOG</TT> request.
<LI>The variable STAF/Service/&lt;Name&gt;/ResolveMessage, if the
<TT>ENABLERESOLVEMESAGEVAR</TT> option has been set.
<LI>The <TT>RESOLVEMESSAGE</TT> or <TT>NORESOLVEMESSAGE</TT> operational
parameters, settable via the <TT>PARMS</TT> option when configuring the
service or via the <TT>SET</TT> command.
</UL>
<A NAME="IDX394"></A>
<P><H3><A NAME="Header_451">8.9.5 LOG</A></H3>
Writes data to a log file.
<P><H4><A NAME="Header_452">Syntax</A></H4>
<PRE>
LOG &lt;GLOBAL | MACHINE | HANDLE&gt; LOGNAME &lt;Logname&gt; LEVEL &lt;Level&gt; MESSAGE &lt;Message&gt;
    &#91;RESOLVEMESSAGE | NORESOLVEMESSAGE&#93;
</PRE>
<P><TT>GLOBAL</TT> indicates you want to write to a global log.  The global
log is intended to facilitate multiple testcases on multiple machines all
writing to a common log.
<P><TT>MACHINE</TT> indicates you want to write to a machine log.  The machine
log is intended to facilitate multiple testcases on a single machine all writing
to a common machine name log.
<P><TT>HANDLE</TT> indicates you want to write to a handle log.  The handle
log is intended to facilitate each testcase writing to a separate log (no matter
how many machines and processes are involved)
<P><TT>LOGNAME</TT> contains the name of the log to which you want to write.
This option will resolve variables.
<P><TT>LEVEL</TT> determines the level that you want to log. This can be in
the form of level type such as "FATAL", "ERROR",  WARNING", etc. or a 32 byte
binary string such as "00000000000000000000000000000001". This option will resolve variables.
See <A HREF="#HDRLOGLEV">8.9.11, "Logging Levels Reference"</A> for a complete list of logging levels.
<P><TT>MESSAGE</TT> contains the message (data) that you want to write to the
log.  This option will not resolve messages by default but can be configured to
do so in the STAF configuration file or by using RESOLVEMESSAGE.
Any private data in the message will be masked before writing to the log.
<P><TT>RESOLVEMESSAGE</TT> causes the LOG service to call the STAF variable
service to resolve any variables in the message before being written.  This
overrides any other message resolution settings.
<P><TT>NORESOLVEMESSAGE</TT> causes the LOG service to not call the STAF
variable service.  This overrides any other message resolution settings.
<P><H4><A NAME="Header_453">Security</A></H4>
<P>This command requires trust level 3.
<P><H4><A NAME="Header_454">Return Codes</A></H4>
<P><H4><A NAME="Header_455">Results</A></H4>
<P>The result buffer will contain no data on return from a LOG command.
<P><H4><A NAME="Header_456">Examples</A></H4>
<UL>
<P><LI><TT>LOG GLOBAL  LOGNAME stresstst LEVEL fatal MESSAGE &#58;33&#58;Testcase aborted with error "255"</TT>
<P><LI><TT>LOG MACHINE LOGNAME stresstst LEVEL 10000000000000000000000000000000 MESSAGE Recovered</TT>
<P><LI><TT>LOG HANDLE  LOGNAME stresstst LEVEL start MESSAGE "Step1 in Test1 initiated"</TT>
</UL>
<A NAME="IDX397"></A>
<P><H3><A NAME="HDRQUERY">8.9.6 QUERY</A></H3>
<P>Allows you to query records from a log based on a set of selection criteria.
<P><B>Note: </B>A stand-alone utility also exists, called FmtLog, that can read a log file
and write the data to an output file in a readable format.
See <A HREF="#HDRFMTLOG">9.4, "Format Log Utility"</A> for additional information.
<P><H4><A NAME="Header_458">Syntax</A></H4>
<PRE>
QUERY  &lt;GLOBAL | MACHINE &lt;Machine&gt; &#91;HANDLE &lt;Handle&gt;&#93;&gt; LOGNAME &lt;Logname&gt;
       &#91;LEVELMASK &lt;Mask&gt;&#93; &#91;QMACHINE &lt;Machine&gt;&#93;... &#91;QHANDLE &lt;Handle&gt;&#93;...
       &#91;NAME &lt;Name&gt;&#93;... &#91;USER &lt;User&gt;&#93;... &#91;ENDPOINT &lt;Endpoint&gt;&#93;...
       &#91;CONTAINS &lt;String&gt;&#93;... &#91;CSCONTAINS &lt;String&gt;&#93;...
       &#91;STARTSWITH &lt;String&gt;&#93;... &#91;CSSTARTSWITH &lt;String&gt;&#93;...
       &#91;FROM &lt;Timestamp&gt; | AFTER &lt;Timestamp&gt;&#93;
       &#91;BEFORE &lt;Timestamp&gt; | TO &lt;Timestamp&gt;&#93;
       &#91;FROMRECORD &lt;Num&gt;&#93; &#91;TORECORD &lt;Num&gt;&#93;
       &#91;FIRST &lt;Num&gt; | LAST &lt;Num&gt; | ALL&#93; &#91;TOTAL | STATS | LONG&#93;
       &#91;LEVELBITSTRING&#93;
</PRE>
<P><TT>GLOBAL</TT> indicates you want to query to a global log.  The global log is intended
to facilitate multiple testcases on multiple machines all writing to a common log.
<P><TT>MACHINE</TT> indicates you want to query to a machine log.  Specify the machine nickname.
The machine log is intended to facilitate multiple testcases on a single machine all
writing to a common log.  This option will resolve variables.
<P><TT>HANDLE</TT> indicates you want to query to a handle log.  The handle log is intended
to facilitate each testcase writing to a separate log. This option will resolve variables.
<P><TT>LOGNAME</TT> contains the name of the log you want to query. All log files have the ".log"
extension automatically added to the file name. This option will resolve variables.
<P><TT>LEVELMASK</TT> determines the levels that are selected.  This can be in the form of
"FATAL ERROR WARNING" or a 32 byte bit string such as "00000000000000000000000000000111".  This option will resolve variables.
<P><TT>QMACHINE</TT> selects only those records that originated from a certain machine.
Multiple <TT>QMACHINE</TT> statements are handled as an "or" condition. This option will resolve variables.
<P><TT>QHANDLE</TT> selects only those records that are associated with a certain handle.
Multiple <TT>QHANDLE</TT> statements are handled as an "or" condition. This option will resolve variables.
<P><TT>NAME</TT> selects only those records with a certain registered name.
Multiple <TT>NAME</TT> statements are handled as an "or" condition. This option will resolve variables.
<P><TT>USER</TT> selects only those records with a certain user.
<TT>&lt;User&gt;</TT> format is <TT>&lt;Authenticator&gt;&#58;//&lt;User Identifier&gt;</TT> (e.g.
none&#58;//anonymous, SampleAuth&#58;//johnDoe@company.com).
Multiple <TT>USER</TT> statements are handled as an "or" condition. This option will resolve variables.
<P><TT>ENDPOINT</TT> selects only those records with a certain endpoint.
Multiple <TT>ENDPOINT</TT> statements are handled as an "or" condition. This option will resolve variables.
<P><TT>CONTAINS</TT> selects only those records that contain a specified string in the message.  Note
that this match is case insensitive. Multiple <TT>CONTAINS</TT> statements are
handled as an "or" condition. This option will resolve variables.
<P><TT>CSCONTAINS</TT> selects only those records that contain a specified string in the message.  Note
that this match is case sensitive. Multiple <TT>CSONTAINS</TT> statements are
handled as an "or" condition. This option will resolve variables.
<P><TT>STARTSWITH</TT> selects only those records that start with a specified string in the message.
Note that this match is case insensitive. Multiple <TT>STARTSWITH/CSSTARTSWITH</TT> statements are
handled as an "or" condition. This option will resolve variables. 
<P><TT>CSSTARTSWITH</TT> selects only those records that start with a specified string in the message.
Note that this match is case sensitive. Multiple <TT>CSSTARTSWITH/STARTSWITH</TT> statements are
handled as an "or" condition. This option will resolve variables. 
<P><TT>FROM</TT> selects only those records that have a date and/or time from the specified format.  This option will resolve variables.
<P><TT>AFTER</TT> selects only those records that have a date and/or time after the specified format.  This option will resolve variables.
<P><TT>TO</TT> selects only those records that have a date and/or time to the specified format. This option will resolve variables.
<P><TT>BEFORE</TT> selects only those records that have a date and/or time before the specified format. This option will resolve variables.
<P><B>Note: </B><TT>&lt;Timestamp&gt;</TT> format is date, @time, or date@time (e.g. 19980214, @16:30:45, 19980214@16:30:45)
<P><B>Note: </B>The keyword <B><I>TODAY</I></B> can be used for the current date in the <TT>FROM, AFTER, TO, BEFORE</TT> options.
<P><TT>FROMRECORD</TT> selects only those records whose record number is greater than or equal
to the specified record number (which must be &gt;= 1). This option will resolve variables.
<P><TT>TORECORD</TT> selects only those records whose record number is less than or equal to
the specified record number (which must be &gt;= 1). This option will resolve variables.
<P><TT>FIRST</TT> selects only the first &lt;Num&gt; records. This option will resolve variables.
<P><TT>LAST</TT> selects only the last &lt;Num&gt; records. This option will resolve variables.
<P><TT>ALL</TT> selects all the records that meet the query criteria.
<P><TT>TOTAL</TT> display only the total number of records selected instead of the records themselves.
<P><TT>STATS</TT> display the totals for each level instead of the records themselves.
<P><TT>LONG</TT> displays all of the fields for each log record instead of just the timestamp, level, and 
message fields.
<P><TT>LEVELBITSTRING</TT> displays the selected records with the level displayed as a 32 byte binary bit
string, e.g. 00000000000000000000000000000001 instead of the standard level text e.g. Error.
See <A HREF="#HDRLOGLEV">8.9.11, "Logging Levels Reference"</A> for a complete list of logging levels.
<P><H4><A NAME="Header_459">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_460">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
QUERY also returns codes documented in <A HREF="#HDRLOGERR">8.9.12, "Log Error Code Reference"</A>.
<P><H4><A NAME="Header_461">Results</A></H4>
<P>
If the query criteria selects more records than allowed by the DefaultMaxQueryRecords
parameter/setting (and none of the following options are specified:  <TT>FIRST, LAST,
ALL, TOTAL, or STATS</TT>), the return code will be set to 4010 and the result buffer will
contain only the 'last' default maximum number of query records.
<P>
If successful, the result buffer will contain data based on the QUERY command:
<P>
<UL>
<P><LI>If the <TT>TOTALS</TT> option is specified, the result buffer
will contain only the total number of records selected instead
of the records themselves.
<P>
<P><LI>If the <TT>STATS</TT> option is specified, the result buffer will
contain a marshalled <TT>&lt;Map&#58;STAF/Service/Log/QueryStats&gt;</TT>
defined as follows:
<BR>
<P><B><A NAME="Table_40">Table 40. Definition of map class STAF/Service/Log/QueryStats</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the totals for the log levels of the
selected records in the log.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Value / Format
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">fatal
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Fatal
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">warning
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Warning
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">info
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Info
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">trace
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Trace
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">trace2
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Trace2
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">trace3
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Trace3
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">debug
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Debug
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">debug2
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Debug2
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">debug3
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Debug3
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">start
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Start
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">stop
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Stop
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">pass
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Pass
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">fail
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Fail
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">status
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Status
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">user1
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">User1
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">user2
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">User2
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">user3
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">User3
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">user4
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">User4
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">user5
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">User5
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">user6
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">User6
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">user7
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">User7
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">user8
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">User8
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR></TABLE>
<P>
<P><LI>If the <TT>LONG</TT> option is specified, the result buffer will
contain a marshalled <TT>&lt;List&gt; of
&lt;Map&#58;STAF/Service/Log/LogRecordLong&gt;</TT>,
representing detailed information for the selected log records.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_41">Table 41. Definition of map class STAF/Service/Log/LogRecordLong</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents detailed information for a log record.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Value / Format
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">recordNumber
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Record #
<BR>
(R#)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">timestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle
<BR>
(H#)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handleName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle Name
<BR>
(Name)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">user
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">User
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Interface&gt;://&lt;System Identifier&gt;[@&lt;Port&gt;]</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">level
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Level
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">message
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Message
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR></TABLE>
<P>
<P><LI>Otherwise, the result buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Log/LogRecord&gt;</TT>,
representing the selected log records (in a "short" format).
The map is defined as follows:
<BR>
<P><B><A NAME="Table_42">Table 42. Definition of map class STAF/Service/Log/LogRecord</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a log record.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Value / Format
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">timestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">level
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Level
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">message
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Message
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_462">Examples</A></H4>
<P>Assume this example log file called STRESSTST contains the following records:
<PRE>
R# Date-Time         Machine                 H# Name   User             Endpoint                          Level   Message
-- ----------------- ----------------------  -- ------ ---------------- --------------------------------- ------- ----------------------------------
1  20070210-18:04:00 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Start   Stress Test 1A Initiated
2  20070210-19:37:15 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Trace   Step 1: processing time: 01:31:26
3  20070210-19:39:09 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Debug   Step 1: debug: files=23 threads=37
4  20070210-22:20:34 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Warning Step 2: File not ready, retry=3
5  20070210-22:21:01 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Info    Step 2: File ready on retry 3
6  20070211-01:21:39 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Trace   Step 2: processing time: 03:02:41
7  20070211-01:21:58 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Debug   Step 2: debug: files=31 threads=54
8  20070211-01:37:25 crazy8s.austin.ibm.com  41 Test2  none://anonymous tcp://crazy8s.austin.ibm.com@6500 Trace   Step 1: processing time: 03:11:53
9  20070211-01:43:46 crazy8s.austin.ibm.com  41 Test2  none://anonymous tcp://crazy8s.austin.ibm.com@6500 Debug   Step 1: debug: files=43 threads=67
10 20070211-02:53:20 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Error   Step 3: Sharing buffer exceeded
11 20070211-02:54:22 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     User1   Step 3: Error recovery started
12 20070211-04:32:53 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     User2   Step 3: Error recovery completed
13 20070211-04:33:49 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Trace   Step 3: processing time: 03:10:41
14 20070211-04:34:07 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Debug   Step 3: debug: files=78 threads=98
15 20070211-08:46:22 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Stop    Stress Test 1A Completed
16 20070211-08:47:21 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Pass    Stress Test 1A: Errors=1 Recover=1
17 20070211-08:48:46 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Status  Step1=P, Step2=P, Step3=W, TC=P
</PRE>
<P><B>Note: </B> The output for these examples are formatted for ease of reading in this
document, the actual format will vary depending on whether the command is
submitted via STAF.exe or via a program's submit(), etc. method.
<UL>
<P><LI><B>Goal:</B> Show me all the trace and debug entries for global log stresstst
<P><B>Syntax:</B>&nbsp; <TT>QUERY GLOBAL LOGNAME stresstst LEVELMASK "TRACE TRACE2 TRACE3 DEBUG DEBUG2 DEBUG3"</TT>
<P><B>Results:</B>  If the request was issued from the
command line, the result, in table format, could look like:
<PRE>
Date-Time         Level Message
----------------- ----- ----------------------------------
20070210-19:37:15 Trace Step 1: processing time: 01:31:26
20070210-19:39:09 Debug Step 1: debug: files=23 threads=37
20070211-01:21:39 Trace Step 2: processing time: 03:02:41
20070211-01:21:58 Debug Step 2: debug: files=31 threads=54
20070211-01:37:25 Trace Step 1: processing time: 03:11:53
20070211-01:43:46 Debug Step 1: debug: files=43 threads=67
20070211-04:33:49 Trace Step 3: processing time: 03:10:41
20070211-04:34:07 Debug Step 3: debug: files=78 threads=98
</PRE>
<P>
<P><LI><B>Goal:</B> Show me all the errors
<P><B>Syntax:</B>&nbsp; <TT>QUERY GLOBAL LOGNAME stresstst LEVELMASK "ERROR"</TT>
<P><B>Results:</B>  If the request was issued from the
command line, the result in table format, could look like:
<PRE>
Date-Time         Level Message
----------------- ----- -------------------------------
20070211-02:53:20 Error Step 3: Sharing buffer exceeded
</PRE>
<P>
<P><LI><B>Goal:</B> How many log records are there?
<P><B>Syntax:</B>&nbsp; <TT>QUERY GLOBAL LOGNAME stresstst total</TT>
<P><B>Results:</B>
<PRE>
17
</PRE>
<P>
<P><LI><B>Goal:</B> Show me everything that happened after I left until I came in on machine "automate"
<P><B>Syntax:</B>&nbsp; <TT>QUERY GLOBAL LOGNAME stresstst FROM 20070210@19:00:00 QMACHINE automate to today@08:00:00</TT>
<P><B>Results:</B>  If the request was issued from the
command line, the result, in table format, could look like:
<PRE>
Date-Time         Level   Message
----------------- ------- ----------------------------------
20070210-19:37:15 Trace   Step 1: processing time: 01:31:26
20070210-19:39:09 Debug   Step 1: debug: files=23 threads=37
20070210-22:20:34 Warning Step 2: File not ready, retry=3
20070210-22:21:01 Info    Step 2: File ready on retry 3
20070211-01:21:39 Trace   Step 2: processing time: 03:02:41
20070211-01:21:58 Debug   Step 2: debug: files=31 threads=54
20070211-02:53:20 Error   Step 3: Sharing buffer exceeded
20070211-02:54:22 User1   Step 3: Error recovery started
20070211-04:32:53 User2   Step 3: Error recovery completed
20070211-04:33:49 Trace   Step 3: processing time: 03:10:41
20070211-04:34:07 Debug   Step 3: debug: files=78 threads=98
</PRE>
<P>
<P><LI><B>Goal:</B> Show me everything that happened after I left until I came in that
has "threads" or "buffer" in the message (in the long format)
<P><B>Syntax:</B>&nbsp; <TT>QUERY LONG GLOBAL LOGNAME stresstst FROM 20070210@19:00:00 TO today@08:00:00 CONTAINS threads CONTAINS buffer</TT>
<P><B>Results:</B>  If the request was issued from the
command line, the result, in table format, could look like:
<PRE>
R# Date-Time         Machine                 H# Name   User             Endpoint                          Level Message
-- ----------------- ----------------------- -- ------ ---------------- --------------------------------- ----- ----------------------------------
3  20070210-19:39:09 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Debug Step 1: debug: files=23 threads=37
7  20070211-01:21:58 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Debug Step 2: debug: files=31 threads=54
9  20070211-01:43:46 crazy8s.austin.ibm.com  41 Test2  none://anonymous tcp://crazy8s.austin.ibm.com@6500 Debug Step 1: debug: files=43 threads=67
10 20070211-02:53:20 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Error Step 3: Sharing buffer exceeded
14 20070211-04:34:07 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Debug Step 3: debug: files=78 threads=98
</PRE>
<P>
<P><LI><B>Goal:</B> Show me all the debug entries for global log stresstst
that starts with "Step 1:" or "Step 2:" in the message (in the long format)
<P><B>Syntax:</B>&nbsp; <TT>QUERY LONG GLOBAL LOGNAME stresstst CSCONTAINS "Step 1:" CSCONTAINS "Step 2:" LEVELMASK Debug</TT>
<P><B>Results:</B>  If the request was issued from the
command line, the result, in verbose format, could look like:
<PRE>
[
  {
    Record #   : 3
    Date-Time  : 20070210-19:39:09
    Machine    : automate.austin.ibm.com
    Handle     : 37
    Handle Name: Test1A
    User       : none://anonymous
    Endpoint   : local://local
    Level      : Debug
    Message    : Step 1: debug: files=23 threads=37
  }
  {
    Record #   : 7
    Date-Time  : 20070211-01:21:58
    Machine    : automate.austin.ibm.com
    Handle     : 37
    Handle Name: Test1A
    User       : none://anonymous
    Endpoint   : local://local
    Level      : Debug
    Message    : Step 2: debug: files=31 threads=54
  }
  {
    Record #   : 9
    Date-Time  : 20070211-01:43:46
    Machine    : crazy8s.austin.ibm.com
    Handle     : 41
    Handle Name: Test2
    User       : none://anonymous
    Endpoint   : tcp://crazy8s.austin.ibm.com@6500
    Level      : Debug
    Message    : Step 1: debug: files=43 threads=67
  }
]
</PRE>
<P>
<P><LI><B>Goal:</B> Show the statistics for the file.
<P><B>Syntax:</B>&nbsp; <TT>QUERY GLOBAL LOGNAME stresstst STATS</TT>
<P><B>Results:</B>  If the request was issued from the
command line, the result, in default format, could look like:
<PRE>
Fatal  : 0
Error  : 1
Warning: 1
Info   : 1
Trace  : 4
Trace2 : 0
Trace3 : 0
Debug  : 4
Debug2 : 0
Debug3 : 0
Start  : 1
Stop   : 1
Pass   : 1
Fail   : 0
Status : 1
User1  : 1
User2  : 1
User3  : 0
User4  : 0
User5  : 0
User6  : 0
User7  : 0
User8  : 0
</PRE>
<P>
<P><LI><B>Goal:</B> Show me log record numbers 5 to 10 in global log stresstst in the long format.
<P><B>Syntax:</B>&nbsp; <TT>QUERY GLOBAL LOGNAME stresstst FROMRECORD 5 TORECORD 10 LONG</TT>
<P><B>Results:</B>  If the request was issued from the
command line, the result, in table format, could look like:
<PRE>
R# Date-Time         Machine                 H# Name   User             Endpoint                          Level Message
-- ----------------- ----------------------- -- ------ ---------------- --------------------------------- ----- ----------------------------------
5  20070210-22:21:01 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Info  Step 2: File ready on retry 3
6  20070211-01:21:39 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Trace Step 2: processing time: 03:02:41
7  20070211-01:21:58 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Debug Step 2: debug: files=31 threads=54
8  20070211-01:37:25 crazy8s.austin.ibm.com  41 Test2  none://anonymous tcp://crazy8s.austin.ibm.com@6500 Trace Step 1: processing time: 03:11:53
9  20070211-01:43:46 crazy8s.austin.ibm.com  41 Test2  none://anonymous tcp://crazy8s.austin.ibm.com@6500 Debug Step 1: debug: files=43 threads=67
10 20070211-02:53:20 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Error Step 3: Sharing buffer exceeded
</PRE>
<P>
<P><LI><B>Goal:</B> Show me which log records numbered 5 to 10 in global log stresstst have log level "Trace".
Use the long format.
<P><B>Syntax:</B>&nbsp; <TT>QUERY GLOBAL LOGNAME stresstst FROMRECORD 5 TORECORD 10 LEVELMASK Trace LONG</TT>
<P><B>Results:</B>  If the request was issued from the
command line, the result, in table format, could look like:
<PRE>
R# Date-Time         Machine                 H# Name   User             Endpoint                          Level Message
-- ----------------- ----------------------- -- ------ ---------------- --------------------------------- ----- ----------------------------------
6  20070211-01:21:39 automate.austin.ibm.com 37 Test1A none://anonymous local://local                     Trace Step 2: processing time: 03:02:41
8  20070211-01:37:25 crazy8s.austin.ibm.com  41 Test2  none://anonymous tcp://crazy8s.austin.ibm.com@6500 Trace Step 1: processing time: 03:11:53
</PRE>
</UL>
<A NAME="IDX400"></A>
<P><H3><A NAME="Header_463">8.9.7 LIST</A></H3>
Allows you to list the names of the log files based on a global, machine,
or handle location.   Also allows you to list current operational settings
<P><H4><A NAME="Header_464">Syntax</A></H4>
<PRE>
LIST GLOBAL | MACHINES | MACHINE &lt;Machine&gt; &#91;HANDLES | HANDLE &lt;Handle&gt;&#93;
</PRE>
or
<PRE>
LIST SETTINGS
</PRE>
<P><TT>GLOBAL</TT> indicates you want to list all global logs.
<P><TT>MACHINES</TT> indicates you want to list all the machines which have
created machine logs.
<P><TT>MACHINE</TT> indicates you want to list all the machine logs for the
specified machine nickname.  This option will resolve variables.
<P><TT>HANDLES</TT> indicates you want to list all the handles that have
created handle logs for the given machine.
<P><TT>HANDLE</TT> indicates you want to list all the handle logs for the
specified handle of the specified machine. This option will resolve variables.
<P><TT>SETTINGS</TT> indicates you want to list the current operational
settings.
<P><H4><A NAME="Header_465">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_466">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
LIST also returns codes documented in <A HREF="#HDRLOGERR">8.9.12, "Log Error Code Reference"</A>.
<P><H4><A NAME="Header_467">Results</A></H4>
<P>If successful, the result buffer will contain data based on the LIST command:
<P>
<UL>
<P><LI>If the <TT>MACHINES</TT> option is specified, the result buffer
will contain a marshalled <TT>&lt;List&gt;</TT> of <TT>&lt;String&gt;</TT>, which
represents the machines for which machine logs have been generated.
<P>
<P><LI>If the <TT>HANDLES</TT> option is specified, the result buffer
will contain a marshalled <TT>&lt;List&gt;</TT> of <TT>&lt;String&gt;</TT>, which
represents the handles for which handle logs have been generated.
<P>
<P><LI>If the <TT>GLOBAL</TT> option is specified, the result buffer
will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Log/ListLogs&gt;</TT>,
which represents the global logs.
<P>If option <TT>MACHINE</TT> is specified without the
<TT>HANDLES</TT> option, the result buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Log/ListLogs&gt;</TT>,
which represents the machine logs for the specified machine nickname.
<P>If both options <TT>MACHINE</TT> and <TT>HANDLE</TT> are specified,
the result buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Log/ListLogs&gt;</TT>,
which represents the handle logs for the specified machine nickname and handle.
<P>The map is defined as follows:
<BR>
<P><B><A NAME="Table_43">Table 43. Definition of map class STAF/Service/Log/ListLogs</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a log file.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Value / Format
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">logName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Log Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">timestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">upperSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">U-Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">L-Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B> 
The "U-Size" value is the upper 32-bits of the size and the "L-Size" value is
the lower 32-bits of the size.  The sizes are shown in bytes.
</TD></TR></TABLE>
<P>
<P><LI>If the <TT>SETTINGS</TT> option is specified, the result buffer will
contain a marshalled map of the settings for the log service in one of
two formats:
<P>
<UL>
<P><LI>If the logging mode is local, the default mode, the
<TT>LIST SETTINGS</TT> request will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Log/ListLocalSettings&gt;</TT> defined as follows:
<BR>
<P><B><A NAME="Table_44">Table 44. Definition of map class STAF/Service/Log/ListLocalSettings</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the settings for a Log service
whose logging mode is local.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Value / Format
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">loggingMode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Logging Mode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'Local'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">directory
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Directory
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">maxRecordSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Max Record Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">defaultMaxQueryRecords
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Default Max Query Records
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">resolveMessage
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Resolve Message
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">resolveMessageVar
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Resolve Message Var
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR></TABLE>
<P>
<P><LI>If the logging mode is remote, the <TT>LIST SETTINGS</TT> request
will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Log/ListRemoteSettings&gt;</TT> defined as follows:
<BR>
<P><B><A NAME="Table_45">Table 45. Definition of map class STAF/Service/Log/ListRemoteSettings</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the settings for a Log service
whose logging mode is remote.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">loggingMode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Logging Mode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Remote'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">remoteLogServer
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Remote Log Server
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">remoteLogService
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Remote Log Service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR></TABLE>
</UL>
</UL>
<P>
<P><H4><A NAME="Header_468">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Show me all the global logs.
<P><B>Syntax:</B>&nbsp; <TT>LIST GLOBAL</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in table format, could look like:
<PRE>
Log Name  Date-Time         U-Size L-Size
--------- ----------------- ------ ------
StressTST 20070210-14:17:00 0      120823
Suite100  20070211-15:45:00 0      2622
</PRE>
<P>
<P><LI><B>Goal:</B> Show me all the machines that have created machine logs.
<P><B>Syntax:</B>&nbsp; <TT>LIST MACHINES</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
automate.austin.ibm.com
testmachine1
</PRE>
<P>
<P><LI><B>Goal:</B> Show me all the machine logs for machine automate.austin.ibm.com.
<P><B>Syntax:</B>&nbsp; <TT>LIST MACHINE automate.austin.ibm.com</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in table format, could look like:
<PRE>
Log Name Date-Time         U-Size L-Size
-------- ----------------- ------ ------
AutoGlob 20070210-10:54:00 0      1168
</PRE>
<P>
<P><LI><B>Goal:</B> Show me all the handles for machine automate.austin.ibm.com that have created logs.
<P><B>Syntax:</B> LIST MACHINE automate.austin.ibm.com HANDLES
<P><B>Results:</B>  If the request is submitted from the
command line, the result could look like:
<PRE>
42
43
44
45
</PRE>
<P>
<P><LI><B>Goal:</B> Show me all the handle logs for machine automate.austin.ibm.com and handle 43.
<P><B>Syntax:</B>&nbsp; <TT>LIST MACHINE automate.austin.ibm.com HANDLE 43</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in table format, could look like:
<PRE>
Log Name Date-Time         U-Size L-Size
-------- ----------------- ------ ------
HandLog1 20070210-10:54:00 0      19043
HandLog2 20070211-18:23:00 0      45264
</PRE>
<P>
<P><LI><B>Goal:</B> Show me the current operational settings.
<P><B>Syntax:</B>&nbsp; <TT>LIST SETTINGS</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
Logging Mode             : Local
Directory                : C:\STAF\data\STAF\service\log
Max Record Size          : 100000
Default Max Query Records: 100
Resolve Message          : Disabled
Resolve Message Var      : Disabled
</PRE>
</UL>
<A NAME="IDX403"></A>
<P><H3><A NAME="Header_469">8.9.8 DELETE</A></H3>
Delete a log file.
<P><H4><A NAME="Header_470">Syntax</A></H4>
<PRE>
DELETE &lt;GLOBAL | MACHINE &lt;Machine&gt; &#91;HANDLE &lt;Handle&gt;&#93;&gt; LOGNAME&lt;Logname&gt; CONFIRM
</PRE>
<P><TT>GLOBAL</TT> indicates you want to delete a global log.
<P><TT>MACHINE</TT> indicates you want to delete a machine log. Specify the machine nickname.  This option will resolve variables.
<P><TT>HANDLE</TT> indicates you want to delete a handle log. This option will resolve variables.
<P><TT>LOGNAME</TT> contains the name of the log you want to delete. This option will resolve variables.
<P><TT>CONFIRM</TT> confirms you really want to delete the log file.
<P><H4><A NAME="Header_471">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_472">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
DELETE also returns codes documented in <A HREF="#HDRLOGERR">8.9.12, "Log Error Code Reference"</A>.
<P><H4><A NAME="Header_473">Results</A></H4>
<P>The result buffer will contain no data on return from a DELETE command.
<P><H4><A NAME="Header_474">Examples</A></H4>
<UL>
<P><LI><TT>DELETE GLOBAL LOGNAME stresstst CONFIRM</TT>
<P><LI><TT>DELETE MACHINE automate.austin.ibm.com LOGNAME autoglob CONFIRM</TT>
<P><LI><TT>DELETE MACHINE testmachine1 HANDLE 45 LOGNAME handlog5 CONFIRM</TT>
</UL>
<A NAME="IDX406"></A>
<P><H3><A NAME="Header_475">8.9.9 PURGE</A></H3>
Purge selected records from a log file.  
The purge command will lock the log file during the entire purge process.
It is recommended that you refrain from logging records to a log file
that is being purged.
<P>
<P><H4><A NAME="Header_476">Syntax</A></H4>
<PRE>
PURGE  &lt;GLOBAL | MACHINE &lt;Machine&gt; &#91;HANDLE &lt;Handle&gt;&#93;&gt; LOGNAME &lt;Logname&gt;
       CONFIRM | CONFIRMALL
       &#91;LEVELMASK &lt;Mask&gt;&#93; &#91;QMACHINE &lt;Machine&gt;&#93;... &#91;QHANDLE &lt;Handle&gt;&#93;...
       &#91;NAME &lt;Name&gt;&#93;... &#91;USER &lt;User&gt;&#93;... &#91;ENDPOINT &lt;Endpoint&gt;&#93;...
       &#91;CONTAINS &lt;String&gt;&#93;... &#91;CSCONTAINS &lt;String&gt;&#93;...
       &#91;STARTSWITH &lt;String&gt;&#93;... &#91;CSSTARTSWITH &lt;String&gt;&#93;...
       &#91;FROM &lt;Timestamp&gt; | AFTER &lt;Timestamp&gt;&#93;
       &#91;BEFORE &lt;Timestamp&gt; | TO &lt;Timestamp&gt;&#93;
       &#91;FROMRECORD &lt;Num&gt;&#93; &#91;TORECORD &lt;Num&gt;&#93;
       &#91;FIRST &lt;Num&gt; | LAST &lt;Num&gt;&#93; 
</PRE>
<P><TT>GLOBAL</TT> indicates you want to purge a global log.
<P><TT>MACHINE</TT> indicates you want to purge a machine log.  Specify the machine nickname.  This option will resolve variables.
<P><TT>HANDLE</TT> indicates you want to purge a handle log. This option will resolve variables.
<P><TT>LOGNAME</TT> contains the name of the log you want to purge. This option will resolve variables.
<P><TT>CONFIRM</TT> confirms you really want to purge the log file,
but protects you from deleting all records in the log file accidently.
<P><TT>CONFIRMALL</TT> confirms you really want to purge the log file,
even if your purge selection criteria selects every record in the log file.
<P><B>Note: </B>If your purge selection criteria selects every record in the log
file and you specified the <TT>CONFIRM</TT> option, you will receive
an error indicating you need to use the <TT>CONFIRMALL</TT> option instead,
or you can submit a DELETE request to the LOG service if you really want
to delete all records in the log file.
<P>Purge allows almost the same selection options as Query.
See <A HREF="#HDRQUERY">8.15.9, "QUERY"</A> for a list of valid purge selection options with
the exception of TOTAL, STATS, ALL, LONG, and LEVELBITSTRING not allowed.
<P>
<P><H4><A NAME="Header_477">Security</A></H4>
<P>This command requires trust level 4.
<P>
<P><H4><A NAME="Header_478">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
PURGE also returns codes documented in <A HREF="#HDRLOGERR">8.9.12, "Log Error Code Reference"</A>.
<P>
<P><H4><A NAME="Header_479">Results</A></H4>
<P>If successful, the result buffer will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Log/PurgeStats&gt;</TT>, representing
the number of log records that were purged and the total number of
log records.  The map is defined as follows:
<BR>
<P><B><A NAME="Table_46">Table 46. Definition of map class STAF/Service/Log/PurgeStats</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class respresents the purge statistics for the log.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">purgedRecords
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Purged Records
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">totalRecords
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Total Records
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR></TABLE>
<P>
For example, suppose you submitted a <TT>PURGE</TT> request for a log that
contained 129 records and 21 of the records met the purge criteria you
specified.  If the <TT>PURGE</TT> request was submitted from the
command line, the result could look like:
<PRE>
Purged Records: 21
Total Records : 129
</PRE>
<P>
<P><H4><A NAME="Header_480">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Purge all the trace and debug entries for global log stresstst
<P><B>Syntax:</B>&nbsp; <TT>PURGE GLOBAL LOGNAME stresstst CONFIRM LEVELMASK "TRACE TRACE2 TRACE3 DEBUG DEBUG2 DEBUG3"</TT>
<P><B>Results:</B>  If the <TT>PURGE</TT> request was issued from the
command line, the result could look like:
<PRE>
Purged Records: 8
Total Records : 17
</PRE>
<P>
<P><LI><B>Goal:</B> Purge all the entries in machine log test1 for machine
{STAF/Config/MachineNickname} whose timestamp is prior to year 2008
<P><B>Syntax:</B>&nbsp; <TT>PURGE MACHINE {STAF/Config/MachineNickname} LOGNAME test1 CONFIRM BEFORE 20080101</TT>
<P><B>Results:</B>  If the <TT>PURGE</TT> request was issued from the
command line, the result could look like:
<PRE>
Purged Records: 2710
Total Records : 3269
</PRE>
<P>
<P><LI><B>Goal:</B> Purge all the records in machine log myTest for machine
{STAF/Config/MachineNickname}
<P><B>Syntax:</B>&nbsp; <TT>PURGE MACHINE {STAF/Config/MachineNickname} LOGNAME myTest CONFIRMALL</TT>
<P><B>Results:</B>  If the <TT>PURGE</TT> request was issued from the
command line, the result could look like:
<PRE>
Purged Records: 152
Total Records : 152
</PRE>
</UL>
<A NAME="IDX409"></A>
<P><H3><A NAME="HDRLOGSET">8.9.10 SET</A></H3>
The SET command allows you to change the operation parameters of the Log
service.
<P><H4><A NAME="Header_482">Syntax</A></H4>
<PRE>
SET  &#91;MAXRECORDSIZE &lt;Size&gt;&#93; &#91;DEFAULTMAXQUERYRECORDS &lt;Number&gt;&#93;
     &#91;ENABLERESOLVEMESSAGEVAR | DISABLERESOLVEMESSAGEVAR&#93;
     &#91;RESOLVEMESSAGE | NORESOLVEMESSAGE&#93;
</PRE>
<P>See section <A HREF="#HDRLOGPARMS">8.9.3, "Parameters"</A> for a description of these options.
<P><H4><A NAME="Header_483">Security</A></H4>
<P>This command requires trust level 5.
<P><H4><A NAME="Header_484">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
SET also returns codes documented in <A HREF="#HDRLOGERR">8.9.12, "Log Error Code Reference"</A>.
<P><H4><A NAME="Header_485">Results</A></H4>
<P>The result buffer will contain no data on return from a successful SET command.
<P><I><B><A NAME="Header_486">Examples</A>:&nbsp;</B></I>&nbsp;
<UL>
<P><LI><B>Goal:</B> Change the maximum record size to 150000
<P><B>Syntax:</B>&nbsp; <TT>SET MaxRecordSize 150000</TT>
<P>
<P><LI><B>Goal:</B> Change the default maximum number of records returned
on a generic query request to 50
<P><B>Syntax:</B>&nbsp; <TT>SET DefaultMaxQueryRecords 50</TT>
<P>
<P><LI><B>Goal:</B> Turn on message resolution
<P><B>Syntax:</B>&nbsp; <TT>SET ResolveMessage</TT>
</UL>
<A NAME="IDX410"></A>
<P><H3><A NAME="HDRLOGLEV">8.9.11 Logging Levels Reference</A></H3>
Logging levels consist of a 32 byte binary string that represents the
level type of each record.  You can use the 32 byte binary string or
the description of the level type when referencing a level.  The
following are the valid logging levels along with their appropriate
32 byte binary string:
<P>
<BR>
<P><B><A NAME="Table_47">Table 47. Logging Levels Reference</A></B><BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Level Definition
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">32 Byte Bit String Representation
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Fatal</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000000000000000001
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Error</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000000000000000010
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Warning</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000000000000000100
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Info</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000000000000001000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Trace</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000000000000010000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Trace2</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000000000000100000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Trace3</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000000000001000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Debug</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000000000010000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Debug2</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000000000100000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Debug3</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000000001000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Start</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000000010000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Stop</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000000100000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Pass</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000001000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Fail</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000010000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>Status</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000000100000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>&lt;Reserved1&gt;</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000001000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>&lt;Reserved2&gt;</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000010000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>&lt;Reserved3&gt;</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000000100000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>&lt;Reserved4&gt;</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000001000000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>&lt;Reserved5&gt;</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000010000000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>&lt;Reserved6&gt;</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000000100000000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>&lt;Reserved7&gt;</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000001000000000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>&lt;Reserved8&gt;</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000010000000000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>&lt;Reserved9&gt;</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000000100000000000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>User1</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000001000000000000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>User2</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000010000000000000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>User3</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00000100000000000000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>User4</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00001000000000000000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>User5</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00010000000000000000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>User6</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">00100000000000000000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>User7</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">01000000000000000000000000000000
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><B>User8</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">10000000000000000000000000000000
</TD></TR></TABLE>
<P><B>Note: </B>The <B>User1-8</B> logging levels have been set aside for the user of
STAFLog to implement as deemed necessary.  You may decide that for a
testcase or test suite that you want to log a certain behavior
as "User1" for example.  This will enable you to easily extract
log records associated with level "User1".
<P><B>Note: </B>The <B>&lt;Reserved1-8&gt;</B> levels cannot be used and as the name implies,
they are reserved by STAF for future use. If you would like to see a common
logging level added to this list, please contact the document
owners for discussion.
<A NAME="IDX412"></A>
<P><H3><A NAME="HDRLOGERR">8.9.12 Log Error Code Reference</A></H3>
<P>In addition to the common STAF return codes (see <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A> for additional information),
the following Log return codes are defined:
<BR>
<P><B><A NAME="TBLLOGERR">Table 48. Log Service Return Codes</A></B><BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">Error Code
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Meaning
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Comment
</TH></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4004</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid level
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">An invalid logging level was specified.
See <A HREF="#HDRLOGLEV">8.9.11, "Logging Levels Reference"</A> for a complete list of logging levels.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4007</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid file format
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">An invalid/unknown record format was encountered while reading the log file.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4008</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Unable to purge all log records
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Your purge criteria selected every record in the log file.  Use CONFIRMALL
instead of CONFIRM if you really want to delete every record (or submit a
DELETE request to the LOG service).  Or, modify your purge criteria if you
don't want to delete every record.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4010</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Exceeded default maximum query records
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Your query criteria selected more records than allowed by the
DefaultMaxQueryRecords setting.  Use the FIRST &lt;Num&gt; or LAST &lt;Num&gt; option to
specify the number of records or the ALL option if you really want all of the records.
</TD></TR></TABLE>
<P>
<A NAME="IDX413"></A>
<A NAME="IDX415"></A>
<HR><H2><A NAME="HDRMISCSRV" HREF="#ToC_489">8.10 Misc Service</A></H2>
<P><H3><A NAME="Header_490">8.10.1 Description</A></H3>
<P>The MISC service is one of the internal STAF services.  It provides a
home for miscellaneous commands.
<UL COMPACT>
<LI>VERSION - Displays the STAF version that is currently running
<LI>WHOAMI - Displays information about who a system thinks you are
<LI>WHOAREYOU  - Displays information about a system
<LI>LIST - Displays a list of interfaces (aka connection providers) that
are enabled or lists the current operational settings for STAF or lists
the cached endpoints used by automatic interface cycling or lists the
STAF install properties
<LI>QUERY - Displays information about a specify interface (aka
connection provider)
<LI>SET - Set STAF operational characteristics 
<LI>PURGE - Purges one or more (or all) of the endpoints from the
cache used for automatic interface cycling.
<LI>HELP &#45; Returns syntax information
</UL>
<A NAME="IDX418"></A>
<P><H3><A NAME="Header_491">8.10.2 VERSION</A></H3>
<P>VERSION will display the STAF version number that is currently running.
<P><H4><A NAME="Header_492">Syntax</A></H4>
<PRE>
VERSION
</PRE>
<P><H4><A NAME="Header_493">Security</A></H4>
<P>This command requires trust level 1.
<P><H4><A NAME="Header_494">Return Codes</A></H4>
<P>All return codes from VERSION are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_495">Results</A></H4>
<P>On successful return, the result buffer will contain the version number.
<P><H4><A NAME="Header_496">Examples</A></H4>
<P>
<UL COMPACT>
<LI><B>Goal:</B> Display the version of STAF running.
<P><B>Syntax:</B>
<P><TT>VERSION</TT>
<P><B>Results:</B>
<PRE>
3.4.6
</PRE>
</UL>
<A NAME="IDX421"></A>
<P><H3><A NAME="Header_497">8.10.3 WHOAMI</A></H3>
<P>WHOAMI will display information about who a system thinks you are.
This can be useful in debugging trust issues and other problems.
<P><H4><A NAME="Header_498">Syntax</A></H4>
<PRE>
WHOAMI
</PRE>
<P><H4><A NAME="Header_499">Security</A></H4>
<P>This command requires trust level 1.
<P><H4><A NAME="Header_500">Return Codes</A></H4>
<P>All return codes from WHOAMI are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_501">Results</A></H4>
<P>On successful return, the result buffer for a <TT>WHOAMI</TT> request
will contain a marshalled <TT>&lt;Map&#58;STAF/Service/Misc/Whoami&gt;</TT>
representing information about who a system thinks you are.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_49">Table 49. Definition of map class STAF/Service/Misc/Whoami</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information about
who a system thinks you are.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">instanceName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Instance Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">instanceUUID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Instance UUID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">requestNumber
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Request Number
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">interface
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Interface
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">logicalID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Logical ID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">physicalID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Physical ID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Macine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">machineNickname
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Machine Nickname
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">isLocalRequest
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Local Request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Yes' | 'No'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">handleName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Handle Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">user
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">User
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">trustLevel
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Trust Level
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The "Instance Name" value contains the STAF instance name that identifies
the instance of STAF to which the request is communicating (in case
multiple instances of STAF are running.  The default STAF instance
name is "STAF".
<LI>The "Instance UUID" value contains the STAF Universally Unique ID
that uniquely identifies a STAF instance.
<LI>The format for the "Endpoint" value is &lt;Interface&gt;://&lt;Logical ID&gt;[@&lt;Port&gt;].
<LI>The format for the "User" value is &lt;Authenticator&gt;://&lt;User ID&gt;.
</OL>
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_502">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Display information about who the remote system thinks you are,
<P><B>Syntax:</B>
<P><TT>WHOAMI</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
Instance Name   : STAF
Instance UUID   : 648C8241CC0B00000929359375636173
Request Number  : 1812
Interface       : tcp
Logical ID      : server1.austin.ibm.com
Physical ID     : 9.41.53.147
Endpoint        : tcp://server1.austin.ibm.com@6500
Machine         : server1.austin.ibm.com
Machine Nickname: Server1
Local Request   : No
Handle          : 33
Handle Name     : myHandle
User            : authSample://User1
Trust Level     : 5
</PRE>
<P>
<P><LI><B>Goal:</B> Display information about who you think you are (e.g. run locally).
<P><B>Syntax:</B>
<P><TT>WHOAMI</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
Instance Name   : STAF
Instance UUID   : 711E9E411B0A00000929359245636173
Request Number  : 92
Interface       : local
Logical ID      : local
Physical ID     : local
Endpoint        : local://local
Machine         : server1.austin.ibm.com
Machine Nickname: Server1
Local Request   : Yes
Handle          : 29
Handle Name     : STAF/Client
User            : none://anonymous
Trust Level     : 5
</PRE>
</UL>
<P>
<A NAME="IDX424"></A>
<P><H3><A NAME="Header_503">8.10.4 WHOAREYOU</A></H3>
<P>WHOAREYOU will display information about a system, such as the STAF instance
name, instance UUID, machine name (the value of the STAF/Config/Machine 
system variable for the machine), machine nickname, (the value of
the STAF/Config/MachineNickname variable for the machine) and if it's the
same system as the machine who submitted the request.
<P><H4><A NAME="Header_504">Syntax</A></H4>
<PRE>
WHOAREYOU
</PRE>
<P><H4><A NAME="Header_505">Security</A></H4>
<P>This command requires trust level 1.
<P><H4><A NAME="Header_506">Return Codes</A></H4>
<P>All return codes from WHOAREYOU are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_507">Results</A></H4>
<P>On successful return, the result buffer for a <TT>WHOAREYOU</TT> request
will contain a marshalled <TT>&lt;Map&#58;STAF/Service/Misc/WhoAreYou&gt;</TT>
representing information about a system.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_50">Table 50. Definition of map class STAF/Service/Misc/WhoAreYou</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information about
a system.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">instanceName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Instance Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">instanceUUID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Instance UUID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Macine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">machineNickname
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Machine Nickname
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">isLocalRequest
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Local Request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Yes' | 'No'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">currentTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Current Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The "Instance Name" value contains the STAF instance name that identifies
the instance of STAF to which the request is communicating (in case
multiple instances of STAF are running.  The default STAF instance
name is "STAF".
<LI>The "Instance UUID" value contains the STAF Universally Unique ID
that uniquely identifies a STAF instance.
</OL>
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_508">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Display information about a remote system,
<P><B>Syntax:</B>
<P><TT>WHOAREYOU</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
Instance Name    : STAF
Instance UUID    : 648C8241CC0B00000929359375636173
Machine          : server1.austin.ibm.com
Machine Nickname : Server1
Local Request    : No
Current Date-Time: 20100615-14:46:30
</PRE>
<P>
<P><LI><B>Goal:</B> Display information about yourself (e.g. run locally).
<P><B>Syntax:</B>
<P><TT>WHOAREYOU</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
Instance Name    : STAF
Instance UUID    : 711E9E411B0A00000929359245636173
Machine          : client2.austin.ibm.com
Machine Nickname : client2.austin.ibm.com
Local Request    : Yes
Current Date-Time: 20100615-15:35:11
</PRE>
</UL>
<A NAME="IDX427"></A>
<P><H3><A NAME="Header_509">8.10.5 LIST</A></H3>
<P>LIST allows you to obtain information about the interfaces (aka connection
providers) that are enabled for a system, or you can list the current
operational settings for STAF, or you can show the cached endpoints
used by automatic interface cycling or, or you can list the STAF install
properties.
<P>
<P><H4><A NAME="Header_510">Syntax</A></H4>
<PRE>
LIST INTERFACES | SETTINGS | ENDPOINTCACHE | PROPERTIES
</PRE>
<P><TT>INTERFACES</TT> specifies that you want information for interfaces.
<P><TT>SETTINGS</TT> specifies that you want to list the current operational
settings for STAF.
<P><TT>ENDPOINTCACHE</TT> specifies that you want to show the cached
endpoints used by automatic interface cycling.
<P><TT>PROPERTIES</TT> specifies that you want to list the install
properties for STAF.
<P>
<P><H4><A NAME="Header_511">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_512">Return Codes</A></H4>
<P>All return codes from LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_513">Results</A></H4>
<P>
<UL>
<P><LI>On successful return from a <TT>LIST INTERFACES</TT> request, the
result buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Misc/Interface&gt;</TT>
representing the enabled interfaces (aka connection providers).
The map is defined as follows:
<BR>
<P><B><A NAME="Table_51">Table 51. Definition of map class STAF/Service/Misc/Interface</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents an interface.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Interface Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">library
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Library
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">optionMap
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Options
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;Map&gt;</TT> of <TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The option names are the keys in the option map.
<LI>Valid option names for TCP interfaces are:  <TT>Port</TT>,
<TT>Protocol</TT>, <TT>ConnectTimeout</TT>, <TT>Secure</TT>.
If <TT>Secure=Yes</TT>, the following options will also exist:
<TT>SSL/CACertificate</TT>, <TT>SSL/ServerCertificate</TT>, and
<TT>SSL/ServerKey</TT>.
<LI>Valid option names for the local interface are:  <TT>IPCName</TT>
and <TT>IPCMethod</TT>
</OL>
</TD></TR></TABLE>
<P>
<P><LI>On successful return from a <TT>LIST SETTINGS</TT> request, the result
buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Misc/Settings&gt;</TT>
representing the current operational settings for STAF.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_52">Table 52. Definition of map class STAF/Service/Misc/Settings</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the operational
settings for STAF.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">connectAttempts
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Connection Attempts
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">connectRetryDelay
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Connect Retry Delay
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">interfaceCycling
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Interface Cycling
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">maxQueueSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Maximum Queue Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">maxReturnFileSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Maximum Return File Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">handleGCInterval
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Handle GC Interval
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'5000' - '86400000'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">initialThreads
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Initial Threads
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">threadGrowthDelta
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Thread Growth Delta
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">dataDir
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Data Directory
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">defaultInterface
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Default Interface
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">defaultAuthenticator
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Default Authenticator
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">resultCompatibilityMode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Result Compatibility Mode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Verbose' | 'None'</TT>
</TD></TR></TABLE>
<P>
<P><LI>On successful return from a <TT>LIST ENDPOINTCACHE</TT> request, the
result buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Misc/EndpointCache&gt;</TT>
representing the contents of the endpoint cache used by automatic
interface cycling.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_53">Table 53. Definition of map class STAF/Service/Misc/EndpointCache</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents an cached endpoint.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">interface
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Interface
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">createdTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The "Date-Time" value contains the timestamp for when the
entry was added to the endpoint cache.
</OL>
</TD></TR></TABLE>
<P>
<P><LI>On successful return from a <TT>LIST PROPERTIES</TT> request, the result
buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Misc/Properties&gt;</TT>
representing the install properties for STAF.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_54">Table 54. Definition of map class STAF/Service/Misc/Properties</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the install properties
for STAF.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">version
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">version
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">platform
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">platform
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">architecture
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">architecture
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'32-bit' | '64-bit'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">installer
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">installer
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'IA' | 'IA_NoJVM' | 'STAFInst'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">file
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">file
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">osname
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">osname
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">osversion
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">osversion
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">"*" indicates the build is supported on any version of the OS; a version
number followed by a "+" indicates the build supports that version or later
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">osarch
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">osarch
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_514">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> List all enabled interfaces.
<P><B>Syntax:</B>
<P><TT>LIST INTERFACES</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in verbose format, could look like:
<PRE>
[
  {
    Interface Name: local
    Library       : STAFLIPC
    Options       : {
      IPCMethod: Shared memory
      IPCName  : STAF
    }
  }
  {
    Interface Name: ssl
    Library       : STAFTCP
    Options       : {
      ConnectTimeout       : 5000
      Port                 : 6550
      Protocol             : IPv4
      SSL/CACertificate    : C:\STAF\bin\CAList.crt
      SSL/ServerCertificate: C:\STAF\bin\STAFDefault.crt
      SSL/ServerKey        : C:\STAF\bin\STAFDefault.key
      Secure               : Yes
    }
  }
  {
    Interface Name: tcp
    Library       : STAFTCP
    Options       : {
      ConnectTimeout: 5000
      Port          : 6500
      Protocol      : IPv4
      Secure        : No
    }
  }
  {
    Interface Name: alt-tcp
    Library       : STAFTCP
    Options       : {
      ConnectTimeout: 30000
      Port          : 6502
      Protocol      : IPv6
      Secure        : No
    }
  }
]
</PRE>
<P>
<P><LI><B>Goal:</B> Show the operational settings for STAF.
<P><B>Syntax:</B>
<P><TT>LIST SETTINGS</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
Connection Attempts      : 2
Connect Retry Delay      : 1000
Interface Cycling        : Enabled
Maximum Queue Size       : 10000
Maximum Return File Size : 0
Handle GC Interval       : 60000
Initial Threads          : 10
Thread Growth Delta      : 1
Data Directory           : c:\STAF\data\STAF
Default Interface        : tcp
Default Authenticator    : none
Result Compatibility Mode: Verbose
</PRE>
<P>
<P><LI><B>Goal:</B> Show the cached endpoints used by automatic
interface cycling, if it is enabled.
<P><B>Syntax:</B>
<P><TT>LIST ENDPOINTCACHE</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in tabular format, could look like:
<PRE>
Endpoint             Interface Date-Time
-------------------- --------- -----------------
machine1             tcp2      20051101-16:42:41
machine1.company.com tcp2      20051102-11:11:37
machine2.company.com tcp3      20051101-15:23:59
machine3             tcp2      20051102-09:05:34
</PRE>
<P>
<P><LI><B>Goal:</B> Show the install properties for STAF.
<P><B>Syntax:</B>
<P><TT>LIST PROPERTIES</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
version     : 3.4.22
platform    : win32
architecture: 32-bit
installer   : IA
file        : STAF3422-setup-win32.exe
osname      : Windows
osversion   : *
osarch      : x86
</PRE>
</UL>
<A NAME="IDX430"></A>
<P><H3><A NAME="Header_515">8.10.6 QUERY</A></H3>
<P>QUERY allows you to obtain detailed information about an enabled interface
(aka connection provider).
<P>
<P><H4><A NAME="Header_516">Syntax</A></H4>
<PRE>
QUERY INTERFACE &lt;Name&gt;
</PRE>
<P><TT>INTERFACE</TT> specifies the name of the interface you want
information on.  This option will resolve variables.
<P>
<P><H4><A NAME="Header_517">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_518">Return Codes</A></H4>
<P>All return codes from QUERY are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_519">Results</A></H4>
<P>
On successful return, the result buffer for a <TT>QUERY INTERFACE</TT>
request will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Misc/Interface&gt;</TT>
representing the specified interface (aka connection provider).
The map is defined as follows:
<BR>
<P><B><A NAME="Table_55">Table 55. Definition of map class STAF/Service/Misc/Interface</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents an interface.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Interface Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">library
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Library
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">optionMap
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Options
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;Map&gt;</TT> of <TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The option names are the keys in the option map.
<LI>Valid option names for TCP interfaces are:  <TT>Port</TT>,
<TT>Protocol</TT>, <TT>Secure</TT>, and <TT>ConnectTimeout</TT>
<LI>Valid option names for the local interface are:  <TT>IPCName</TT>
and <TT>IPCMethod</TT>
</OL>
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_520">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Query the ssl interface.
<P><B>Syntax:</B>
<P><TT>QUERY INTERFACE ssl</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
{
  Interface Name: ssl
  Library       : STAFTCP
  Options       : {
    ConnectTimeout       : 5000
    Port                 : 6550
    Protocol             : IPv4
    SSL/CACertificate    : C:\STAF\bin\CAList.crt
    SSL/ServerCertificate: C:\STAF\bin\STAFDefault.crt
    SSL/ServerKey        : C:\STAF\bin\STAFDefault.key
    Secure               : Yes
  }
}
</PRE>
<P>
<P><LI><B>Goal:</B> Query the tcp interface.
<P><B>Syntax:</B>
<P><TT>QUERY INTERFACE tcp</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
{
  Interface Name: tcp
  Library       : STAFTCP
  Options       : {
    ConnectTimeout: 5000
    Port          : 6500
    Protocol      : IPv4
    Secure        : No
  }
}  
</PRE>
<P>
<P><LI><B>Goal:</B> Query the local interface.
<P><B>Syntax:</B>
<P><TT>QUERY INTERFACE local</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
{
  Interface Name: local
  Library       : STAFLIPC
  Options       : {
    IPCMethod: Shared memory 
    IPCName  : STAF
  }
}
</PRE>
</UL>
<A NAME="IDX433"></A>
<P><H3><A NAME="HDRMISCSET">8.10.7 SET</A></H3>
The SET command allows you to change the operational parameters for STAF
dynamically (without stopping/restarting STAF) which is important for
STAF machines that must be continuously available.
<P>
Note that to make these settings permanent (e.g. if you want these changes
to apply once STAF is stopped and restarted), you'll need to update the
STAF configuration file with these new settings.
<P>
<P><H4><A NAME="Header_522">Syntax</A></H4>
<PRE>
SET  &#91;CONNECTATTEMPTS &lt;Number&gt;&#93; &#91;CONNECTRETRYDELAY &lt;Number&gt;&#93;
     &#91;MAXQUEUESIZE &lt;Number&gt;&#93; &#91;HANDLEGCINTERVAL &lt;Number&gt;&#91;s|m|h|d&#93;&#93;
     &#91;INTERFACECYCLING &lt;Enabled | Disabled&gt;&#93;
     &#91;DEFAULTINTERFACE &lt;Name&gt;&#93;  &#91;DEFAULTAUTHENTICATOR &lt;Name&gt;&#93;
     &#91;RESULTCOMPATIBILITYMODE &lt;Verbose | None&gt;&#93;
</PRE>
<P>See section <A HREF="#HDROPPARMS">4.7, "Operational parameters"</A> for a description of these options.
<P><H4><A NAME="Header_523">Security</A></H4>
<P>This command requires trust level 5.
<P><H4><A NAME="Header_524">Return Codes</A></H4>
<P>All return codes from <TT>SET</TT> are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_525">Results</A></H4>
<P>The result buffer will contain no data on return from a successful SET command.
<P><H4><A NAME="Header_526">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Change the maximum queue size to 10000.
<P><B>Syntax:</B>&nbsp; <TT>SET MAXQUEUESIZE 50</TT>
<P>
<P><LI><B>Goal:</B> Change two operational parameters for STAF.  Change the 
maximum number of times to attempt to connect to a remote system to 5 and
change the maximum time in milliseconds to wait after a failed connection
attempt to a remote system before trying to connect again to 2 seconds.
<P><B>Syntax:</B>&nbsp; <TT>SET CONNECTATTEMPTS 5 CONNECTRETRYDELAY 2s</TT>
<P>
<P><LI><B>Goal:</B> Disabled automatic interface cycling.
<P><B>Syntax:</B>&nbsp; <TT>SET INTERFACECYCLING Disabled</TT>
<P>
<P><LI><B>Goal:</B>  Set the default interface to be 'tcp'.
<P><B>Syntax:</B>&nbsp; <TT>SET DEFAULTINTERFACE tcp</TT>
<P>
<P><LI><B>Goal:</B> Change the garbage collection interval for handles
to 50 seconds.
<P><B>Syntax:</B>&nbsp; <TT>SET HANDLEGCINTERVAL 50s</TT>
</UL>
<P>
<A NAME="IDX436"></A>
<P><H3><A NAME="HDRMISCPURGE">8.10.8 PURGE</A></H3>
The PURGE command allows you to purge one or more (or all) of the endpoints
from the endpoint cache used by automatic interface cycling.
<P>
<P><H4><A NAME="Header_528">Syntax</A></H4>
<PRE>
PURGE ENDPOINTCACHE &lt;ENDPOINT &lt;Endpoint&gt;... | CONFIRM&gt;
</PRE>
<P><TT>ENDPOINTCACHE</TT> indicates that you want to purge one or
more endpoints from the endpoint cache.
<P><TT>ENDPOINT</TT> specifies the endpoint that you want to purge.
This option will resolve variables.
<P><TT>CONFIRM</TT> indicates that you really want to purge the entire
contents of the endpoint cache.
<P>
<P><H4><A NAME="Header_529">Security</A></H4>
<P>This command requires trust level 5.
<P>
<P><H4><A NAME="Header_530">Return Codes</A></H4>
<P>All return codes from <TT>PURGE</TT> are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_531">Results</A></H4>
<P>
If successful, the result buffer will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Misc/PurgeStats&gt;</TT>, representing the number
of endpoints that were purged and the number of endpoints remaining in the
endpoint cache. The map is defined as follows: 
<BR>
<P><B><A NAME="Table_56">Table 56. Definition of map class STAF/Service/Misc/PurgeStats</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the purge statistics
for the endpoint cache.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">numPurged
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Purged Endpoints
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">numRemaining
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Remaining Endpoints
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_532">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Remove endpoints 'client1' and 'client1.company.com' from
the endpoint cache..
<P><B>Syntax:</B>&nbsp; <TT>PURGE ENDPOINTCACHE ENDPOINT client1 ENDPOINT client1.company.com</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in tabular format, could look like:
<PRE>
Purged Endpoints   : 2
Remaining Endpoints: 8
</PRE>
<P>
<P><LI><B>Goal:</B> Purge all entries from the endpoint cache.
<P><B>Syntax:</B>&nbsp; <TT>PURGE ENDPOINTCACHE CONFIRM</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in tabular format, could look like:
<PRE>
Purged Endpoints   : 8
Remaining Endpoints: 0
</PRE>
</UL>
<P>
<A NAME="IDX437"></A>
<A NAME="IDX439"></A>
<HR><H2><A NAME="HDRMONSRV" HREF="#ToC_533">8.11 Monitor Service</A></H2>
<P><H3><A NAME="Header_534">8.11.1 Description</A></H3>
The Monitor service is an external STAF service that provides the following
functions:
<UL COMPACT>
<LI>LOG - Write monitor data
<LI>QUERY - Query monitor data
<LI>LIST - List the Monitor settings or machines/handles that have logged data
<LI>DELETE - Delete monitor data
<LI>SET - Set the monitor parameters
<LI>HELP &#45; Returns syntax information
</UL>
The purpose of the Monitor service is to give a test case the ability
to write status messages.  This allows someone to query a process or
workload and easily get the current status.  The status messages are stored
based on a combination of the originating machine and the process handle
(where only the process can update the status message), or on a combination
of the originating machine and a specified monitor name (where any process on
the originating machine can update the named monitor).  The Monitor service
only keeps the last monitor message it receives from a particular machine and
process/name.  A "centralized network clipboard" is a term that could be
used to describe the Monitor service.  All Monitor service status messages are
lost when STAFProc is shutdown or the Monitor service is dynamically removed.
<A NAME="IDX441"></A>
<P><H3><A NAME="Header_535">8.11.2 Registration</A></H3>
The Monitor service is written in C and since it is an external service,
it must be registered with the SERVICE configuration statement. The
syntax is:
<PRE>
SERVICE &lt;Name&gt; LIBRARY STAFMon PARMS &lt;Parms&gt;
</PRE>
<P><TT>&lt;Name&gt;</TT> is the name by which the Monitor service will be known on this machine.
<P><TT>&lt;Parms&gt;</TT> is any parameters that are accepted at initialization time.  The same
parameters for the Monitor SET command can be specified during initialization time.  See the
Monitor SET command for details on the available parameters.
<P><H4><A NAME="Header_536">Example</A></H4>
<PRE>
service Monitor library STAFMon PARMS "RESOLVEMESSAGE MAXRECORDSIZE 512"
</PRE>
<A NAME="IDX443"></A>
<P><H3><A NAME="Header_537">8.11.3 Variables</A></H3>
The following variables are defined in the STAF configuration file
and Monitor will query their values:
<DL COMPACT>
<DD><TT>STAF/Service/&lt;Name&gt;/ResolveMessage:</TT> Whether to resolve variables in the message
</DL>
<P><H4><A NAME="Header_538">STAF/Service/&lt;Name&gt;/ResolveMessage</A></H4>
This flag determines if messages should be resolved before writing them.
If message resolution is desired, then a call to the STAF variable
service is made and all variables are resolved.  If for any reason the
resolution is unsuccessful (i.e. unbalanced braces {}, infinite recursion, etc.)
then an error code will be returned.
<P><B>Note: </B>Note that this variable will only be examined if the ENABLERESOLVEMESSAGEVAR option
is set either during the Monitor registration (via the PARMS options) or by use of the
SET ENABLERESOLVEMESSAGEVAR Monitor command.
<P><B>Note: </B>The default if STAF/Service/<TT>&lt;Name&gt;</TT>/ResolveMessage is not specified, is
not to resolve messages.  This is due to the fact that you can resolve variables
yourself before logging messages and the fact that the messages could be quite
large.  This can be overridden on a per message basis by using the
RESOLVEMESSAGE or NORESOLVEMESSAGE option.
<DL COMPACT>
<DD><B>Example:</B> var STAF/Service/<TT>&lt;Name&gt;</TT>/ResolveMessage=1
<DD><B>Default:</B> 0 
</DL>
An example would be a monitor message of "Machine booted from {STAF/Config/BootDrive}",
if STAF/Service/&lt;Name&gt;/ResolveMessage was set to 1 then what would actually
be logged would look like: "Machine booted from C:".  If
STAF/Service/Monitor/ResolveMessage was set to 0 then the original text
of the message would be logged: "Machine booted from {STAF/Config/BootDrive}".
<A NAME="IDX446"></A>
<P><H3><A NAME="Header_539">8.11.4 LOG</A></H3>
Writes monitor data.
<P><H4><A NAME="Header_540">Syntax</A></H4>
<PRE>
LOG MESSAGE &lt;Message&gt; [NAME &lt;Name&gt;] &#91;RESOLVEMESSAGE | NORESOLVEMESSAGE&#93;
</PRE>
<P><TT>MESSAGE</TT> contains the message (data) that you want to write to
the monitor. This option will not resolve messages by default but can be
configured to do so in the STAF configuration file or by using RESOLVEMESSAGE.
Any private data in the message will be masked before writing to the monitor.
<P><TT>NAME</TT> indicates that the status message should be written to the
specified named monitor.  This option will be resolved for variables.  If this
option is not specified, the status message will be written to the originating
handle's monitor.
<P><TT>RESOLVEMESSAGE</TT> causes the MONITOR service to call the STAF
variable service to resolve any variables in the message before being written.
<P><TT>NORESOLVEMESSAGE</TT> causes the MONITOR service to not call the STAF
variable service to resolve any variables in the message.
<P><H4><A NAME="Header_541">Security</A></H4>
<P>This command requires trust level 3.
<P><H4><A NAME="Header_542">Return Codes</A></H4>
<P>All return codes from LOG are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_543">Results</A></H4>
<P>The result buffer will contain no data on return from a LOG command.
<P><H4><A NAME="Header_544">Examples</A></H4>
<DL COMPACT>
<DD>LOG MESSAGE &#58;33&#58;Testcase aborted with error "255"
<DD>LOG MESSAGE "Step1 in Test1 initiated on bootdrive {STAF/Config/BootDrive}"
<DD>LOG MESSAGE "TestW: Step 32 of 109" NAME ActiveXYZRequests
<DD>LOG MESSAGE Recovered
</DL>
<A NAME="IDX449"></A>
<P><H3><A NAME="Header_545">8.11.5 QUERY</A></H3>
Allows you to query a message from a monitor based on the 
machine nickname and process handle that generated the monitor message.
<P><H4><A NAME="Header_546">Syntax</A></H4>
<PRE>
QUERY MACHINE &lt;Machine Nickname&gt; &lt; HANDLE &lt;Handle&gt; | NAME &lt;Name&gt; &gt;
</PRE>
<P><TT>MACHINE</TT> determines what machine the monitor message originated
from. This option will resolve variables.
<P><TT>HANDLE</TT> determines the process handle that originated the
message. This option will resolve variables.
<P><TT>NAME</TT> determines the name of the
message. This option will resolve variables.
<P><H4><A NAME="Header_547">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_548">Return Codes</A></H4>
<P>All return codes from QUERY are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_549">Results</A></H4>
<P>The result buffer will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Monitor/MonitorInfo&gt;</TT>, representing
the last monitor message generated by the specified machine/handle or
for the specified machine/name..
The map is defined as follows: 
<BR>
<P><B><A NAME="Table_57">Table 57. Definition of map class STAF/Service/Monitor/MonitorInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a monitor message.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">timestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">message
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Message
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
The "Date-Time" is the date/time at which the last monitor
message was logged.
<P>
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_550">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Show me the monitor message from machine automate.austin.ibm.com and
process handle 32
<P><B>Syntax:</B>&nbsp; <TT>QUERY MACHINE automate.austin.ibm.com HANDLE 32</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
Date-Time: 20040911-16:00:32
Message  : Testcase aborted with error "255"
</PRE>
<P><LI><B>Goal:</B> Show me the monitor message from machine testmachine1.company.com and
process handle 85 (assuming its machine nickname is testmachine1)
<P><B>Syntax:</B>&nbsp; <TT>QUERY MACHINE testmachine1 HANDLE 85</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
Date-Time: 20041022-17:58:01
Message  : TestC: Step 2 of 5
</PRE>
<P><LI><B>Goal:</B> Show me the monitor message from machine automate.austin.ibm.com and
monitor name ActiveXYZRequests
<P><B>Syntax:</B>&nbsp; <TT>QUERY MACHINE automate.austin.ibm.com NAME ActiveXYZRequests</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
Date-Time: 20061205-08:24:01
Message  : TestW: Step 32 of 109
</PRE>
</UL>
<A NAME="IDX452"></A>
<P><H3><A NAME="Header_551">8.11.6 LIST</A></H3>
Allows you to list Monitor settings, the names of the machines that have 
logged monitor data, or the monitor information for a given machine.
<P><H4><A NAME="Header_552">Syntax</A></H4>
<PRE>
LIST &lt;MACHINES | MACHINE &lt;Machine&gt; [NAMES] | SETTINGS&gt;
</PRE>
<P><TT>MACHINES</TT> indicates you want list all the machine nicknames that
have created monitor data.
<P><TT>MACHINE</TT> indicates you want to list the monitor data for the
specified machine nickname. This option will resolve variables.  If the <TT>NAMES</TT> option is
specified, only the monitor data for named monitors will be displayed;
otherwise, the monitor data for (un-named) process handles will be displayed.
<P><TT>NAMES</TT> indicates you want to list the named monitors for the
specified machine nickname. This option will resolve variables.
<P><TT>SETTINGS</TT> returns the Monitor settings.
<P><H4><A NAME="Header_553">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_554">Return Codes</A></H4>
<P>All return codes from LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_555">Results</A></H4>
<P>The result buffer will contain data based on the LIST command:
<P>
<UL>
<P><LI>If the <TT>MACHINES</TT> option is specified, the result buffer will
contain a marshalled <TT>&lt;List&gt;</TT> of <TT>&lt;String&gt;</TT>, which represents 
the machine nicknames for which monitor messages have been logged.
<P>
<P><LI>If the <TT>MACHINE</TT> option is specified (and the <TT>NAMES</TT>
option is not specified), the result buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Monitor/HandleInfo&gt;</TT>, which
represents the handles for the specified machine that have logged monitor
messages.  The map is defined as follows:  
<BR>
<P><B><A NAME="Table_58">Table 58. Definition of map class STAF/Service/Monitor/HandleInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the handle that generated
the monitor message on the specified machine.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">timestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
The "Date-Time" is the date/time at which the last monitor
message was logged.
The "Size" is the size of the last monitor message logged.
</TD></TR></TABLE>
<P>
<P><LI>If the <TT>MACHINE</TT> option is specified with the <TT>NAMES</TT>
option, the result buffer will contain a marshalled <TT>&lt;List&gt; of
&lt;Map&#58;STAF/Service/Monitor/NameInfo&gt;</TT>, which
represents the named monitors for the specified machine.  The map is defined
as follows:
<BR>
<P><B><A NAME="Table_59">Table 59. Definition of map class STAF/Service/Monitor/NameInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the named monitors
on the specified machine.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">timestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
The "Date-Time" is the date/time at which the last monitor
message was logged.
The "Size" is the size of the last monitor message logged.
</TD></TR></TABLE>
<P>
<P><LI>If the <TT>SETTINGS</TT> option is specified, the result buffer will
contain a marshalled <TT>&lt;Map&#58;STAF/Service/Monitor/Settings&gt;</TT> defined
as follows:
<BR>
<P><B><A NAME="Table_60">Table 60. Definition of map class STAF/Service/Monitor/Settings</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the settings for
the Monitor service.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">maxRecordSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Max Record Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">resolveMessage
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Resolve Message
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>Enabled | Disabled</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">resolveMessageVar
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Resolve Message Var
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>Enabled | Disabled</TT>
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_556">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Show me all the machines that have written monitor data.
<P><B>Syntax:</B>&nbsp; <TT>LIST MACHINES</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
automate.austin.ibm.com
testmachine1
</PRE>
<P>
<P><LI><B>Goal:</B> Show me all the monitor information (Handle) for machine automate.austin.ibm.com.
<P><B>Syntax:</B>&nbsp; <TT>LIST MACHINE automate.austin.ibm.com</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in table format, could look like:
<PRE>
Handle Date-Time         Size
------ ----------------- ----
34     20040910-16:29:03 30
36     20040910-16:29:13 148
37     20040910-16:29:19 97
68     20040911-16:00:32 43
</PRE>
<P>
<P><LI><B>Goal:</B> Show me all the monitor information (Handle) for machine testmachine1.
<P><B>Syntax:</B>&nbsp; <TT>LIST MACHINE testmachine1</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in table format, could look like:
<PRE>
Handle Date-Time         Size
------ ----------------- ----
20     20041022-17:43:05 25
</PRE>
<P>
<P><LI><B>Goal:</B> Show me all the named monitors for machine automate.austin.ibm.com.
<P><B>Syntax:</B>&nbsp; <TT>LIST MACHINE automate.austin.ibm.com NAMES</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in table format, could look like:
<PRE>
Name              Date-Time         Size
----------------- ----------------- ----
ActiveXYZRequests 20061205-13:50:06 39
test1             20061205-13:54:14 25
</PRE>
<P>
<P><LI><B>Goal:</B> Show me all the Monitor settings.
<P><B>Syntax:</B>&nbsp; <TT>LIST SETTINGS</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
Max Record Size    : 512
Resolve Message    : Enabled
Resolve Message Var: Disabled
</PRE>
</UL>
<A NAME="IDX455"></A>
<P><H3><A NAME="Header_557">8.11.7 DELETE</A></H3>
The DELETE command will delete handle/named monitor files and directories.  You
can specify whether to delete all monitor data, all monitor data recorded prior
to a specified timestamp, or a specific named monitor.
<P><H4><A NAME="Header_558">Syntax</A></H4>
<PRE>
DELETE &#91;BEFORE &lt;Timestamp&gt; | MACHINE &lt;Machine&gt; NAME &lt;Name&gt;&#93; CONFIRM
</PRE>
<P><TT>BEFORE</TT> specifies that you only want to delete monitor data
recorded prior to the specified timestamp.  If <TT>BEFORE</TT> is not
specified, all handle/name monitor data will be removed. The keyword <B><I>TODAY</I></B>
can be used for <TT>&lt;Timestamp&gt;</TT> to delete all data prior to the
current system date.
<P><TT>MACHINE</TT> is the machine nickname for the named monitor to be
deleted.
<P><TT>NAME</TT> is the named monitor to be deleted.
<P><TT>CONFIRM</TT> confirms you really want to delete the monitor
data.
<P><H4><A NAME="Header_559">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_560">Return Codes</A></H4>
<P>All return codes from DELETE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_561">Results</A></H4>
<P>The result buffer will contain no data on return from a DELETE command.
<P><H4><A NAME="Header_562">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B>&nbsp; Delete all monitor data prior to today.
<P><B>Syntax:</B>&nbsp; <TT>DELETE BEFORE TODAY CONFIRM</TT>
<P>
<P><LI><B>Goal:</B>&nbsp; Delete all monitor data prior to January 1, 2007.
<P><B>Syntax:</B>&nbsp; <TT>DELETE BEFORE 20070101 CONFIRM</TT>
<P>
<P><LI><B>Goal:</B>&nbsp; Delete all monitor data.
<P><B>Syntax:</B>&nbsp; <TT>DELETE CONFIRM</TT>
<P>
<P><LI><B>Goal:</B>&nbsp; Delete the data for named monitor ActiveXYZRequests.
<P><B>Syntax:</B>&nbsp; <TT>DELETE MACHINE automate.austin.ibm.com NAME ActiveXYZRequests CONFIRM</TT>
</UL>
<A NAME="IDX458"></A>
<P><H3><A NAME="Header_563">8.11.8 SET</A></H3>
Sets monitor service options.
<P><H4><A NAME="Header_564">Syntax</A></H4>
<PRE>
SET  &#91;RESOLVEMESSAGE | NORESOLVEMESSAGE&#93;
     &#91;MAXRECORDSIZE &lt;Size&gt;&#93;
     &#91;ENABLERESOLVEMESSAGEVAR | DISABLERESOLVEMESSAGEVAR&#93;
</PRE>
<P><TT>RESOLVEMESSAGE</TT> causes the MONITOR service to call the STAF
variable service to resolve any variables in Monitor Log messages before being 
written.
<P><TT>NORESOLVEMESSAGE</TT> causes the MONITOR service to not call the STAF
variable service to resolve any variables in Monitor Log messages before being
written.  This is the default.
<P><TT>MAXRECORDSIZE &lt;Size&gt;</TT> sets the Maximum record size for Monitor
data.  The default is 1024 bytes.
<P><TT>ENABLERESOLVEMESSAGEVAR</TT> causes STAF/Service/&lt;Name&gt;/ResolveMessage
variable to be queried for every Monitor Log command, to determine if variables
in the Monitor Log command should be resolved.
<P><TT>DISABLERESOLVEMESSAGEVAR</TT> causes STAF/Service/&lt;Name&gt;/ResolveMessage
variable to not be queried for every Monitor Log command.  This is the default.
<P>The highest priority in defining whether variables in a Monitor Log command
are to be resolved will be the
<TT>RESOLVEMESSAGE/NORESOLVEMESSAGE</TT> specified directly in the
Log command.  If the Monitor Log command contains neither option, then if 
<TT>ENABLERESOLVEMESSAGEVAR</TT> is set, the variable
STAF/Service/&lt;Name&gt;/ResolveMessage will be examined to determine whether to
resolve the message.  If <TT>DISABLERESOLVEMESSAGEVAR</TT> is set, then the
<TT>RESOLVEMESSAGE/NORESOLVEMESSAGE</TT> option (set via the PARMS options or
by use of the <TT>SET RESOLVEMESSAGE/NORESOLVEMESSAGE</TT> Monitor command)
will be honored.
<P><H4><A NAME="Header_565">Security</A></H4>
<P>This command requires trust level 5.
<P><H4><A NAME="Header_566">Return Codes</A></H4>
<P>All return codes from SET are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_567">Results</A></H4>
<P>The result buffer will contain no data on return from a successul <TT>SET</TT>
command.
<P><H4><A NAME="Header_568">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B>&nbsp; Enable the resolve message setting for the Monitor service.
<P><B>Syntax:</B>&nbsp; <TT>SET RESOLVEMESSAGE</TT>
<P>
<P><LI><B>Goal:</B>&nbsp; Set two operational settings for the Monitor service.
<P><B>Syntax:</B>&nbsp; <TT>SET MAXRECORDSIZE 512 ENABLERESOLVEMESSAGEVAR</TT>
</UL>
<A NAME="IDX460"></A>
<P><H3><A NAME="HDRMONERR">8.11.9 Monitor Error Code Reference</A></H3>
<P>No additional return codes are defined for the Monitor service.
The Monitor service uses only the STAF return codes (see <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A> for
additional information).
<P>
<A NAME="IDX461"></A>
<A NAME="IDX463"></A>
<HR><H2><A NAME="HDRPINGSRV" HREF="#ToC_570">8.12 Ping Service</A></H2>
<P><H3><A NAME="Header_571">8.12.1 Description</A></H3>
<P>The PING service is an internal STAF service. PING provides a
service similar to the TCP/IP PING service.  This 'are you there'
request can be used to determine if STAFProc is up and running
and accessible.
<A NAME="IDX466"></A>
<P><H3><A NAME="Header_572">8.12.2 PING</A></H3>
<P><H4><A NAME="Header_573">Syntax</A></H4>
<PRE>
PING &#91;MACHINE &lt;Machine&gt;&#93;
</PRE>
<P><TT>MACHINE</TT> specifies the endpoint for a machine to be pinged.
This option allows you to check if the machine you are submitting 
the PING request to can communicate via STAF to another machine.
It can be useful when trying to determine if there is a firewall issue
or other network problem. This option will resolve variables.
<P>
<P><H4><A NAME="Header_574">Security</A></H4>
<P>This command requires trust level 1.
<P><H4><A NAME="Header_575">Return Codes</A></H4>
<P>All return codes from PING are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_576">Results</A></H4>
<P>The result buffer will contain PONG on a successful return from a PING command.
<P><H4><A NAME="Header_577">Examples</A></H4>
<P>The following examples show the syntax, and results using the STAF command
executable from a Windows command prompt.  These STAF requests could also be
submitted from a program (e.g. Java, C++, Perl, shell, etc.). 
<P>
<UL>
<P><LI><B>Goal:</B> See if STAFProc is running on the local machine.
<P><B>Syntax and Results:</B>
<PRE>
C:\&gt;STAF local PING PING
Response
--------
PONG
</PRE>
<P>
<P><LI><B>Goal:</B> See if STAFProc is running on machine host1.company.com
and if you can communicate with the machine via STAF.
<P><B>Syntax and Results:</B>
<PRE>
C:\&gt;STAF host1.company.com PING PING
Response
--------
PONG
</PRE>
<P>
If STAFProc is not running on machine host1.company.com or you cannot
communicate via STAF to that machine, you would get an RC 16 (No path to
endpoint) and an error message.  For example:
<PRE>
C:\&gt;STAF host1.company.com PING PING
Error submitting request, RC: 16
Additional info
---------------
STAFConnectionProviderConnect: Timed out connecting to endpoint: select() timeou
t: 22, Endpoint: tcp://host1.company.com
</PRE>
<P>
Note that you can get more information on return code 16 (and other STAF
return codes) by using the Help service.  For example:
<PRE>
C:\&gt;STAF local HELP ERROR 16
Response
--------
Description: No path to endpoint
Details    : This indicates that STAFProc was not able to submit the request to
the requested endpoint (i.e. machine).  This error usually indicates that STAF i
s not running on the target machine, or that the requested endpoint is not valid
, or that the network interface or port for the requested endpoint is not suppor
ted, or that a firewall is blocking communication via the port for the requested
 endpoint, or that a secure network interface is being used to communicate to a
machine that doesn't have a secure network interface configured with the same ce
rtificate.  Alternatively, you may need to increase your CONNECTTIMEOUT value fo
r the network interface and/or increase your CONNECTATTEMPTS value in your STAF.
cfg file.
</PRE>
<P>
<P><LI><B>Goal:</B> See if machine host1.company.com can communicate via STAF
to machine host2.company.com.
<P><B>Syntax and Results:</B>
<PRE>
C:\&gt;STAF host1.company.com PING PING MACHINE host2.company.com
Response
--------
PONG
</PRE>
<P>
<P><LI><B>Goal:</B> See if machine host1.company.com can communicate via STAF
to machine host2.company.com on port 6501.
<P><B>Syntax and Results:</B>
<PRE>
C:\&gt;STAF host1.company.com PING PING MACHINE host2.company.com@6501
Response
--------
PONG
</PRE>
</UL>
<P>
<A NAME="IDX467"></A>
<A NAME="IDX469"></A>
<HR><H2><A NAME="HDRPROCSRV" HREF="#ToC_578">8.13 Process Service</A></H2>
<P><H3><A NAME="Header_579">8.13.1 Description</A></H3>
<P>The PROCESS service is one of the internal STAF services.  It provides the
following commands
<UL COMPACT>
<LI>START - Starts a process, and optionally registers for process end
notification
<LI>STOP - Stops a process
<LI>LIST - Retrieves brief information on processes or lists the operational
settings for the Process service
<LI>QUERY - Retrieves detailed information about a process with a specified
handle
<LI>FREE - Releases the results data about a process
<LI>NOTIFY REGISTER - Registers for process end notification
<LI>NOTIFY UNREGISTER - Unregisters for process end notification
<LI>NOTIFY LIST - Displays the list of machines/processes to receive process
end notification
<LI>SET - Sets operational settings for the Process service 
<LI>HELP &#45; Returns syntax information
</UL>
<A NAME="IDX472"></A>
<P><H3><A NAME="HDRPROCSTR">8.13.2 START</A></H3>
<P>START allows you to start a process.  Processes may be started synchronously
or asynchronously.  You may also specify to which workload they belong,
parameters to pass to them, their working directory, any process specific
STAF variables to set for them, as well as any environment variables they may
need.
<P><H4><A NAME="Header_581">Syntax</A></H4>
<PRE>
START &#91;SHELL &#91;&lt;Shell&gt;&#93;&#93; COMMAND &lt;Command&gt; &#91;PARMS &lt;Parms&gt;&#93;  &#91;WORKDIR &lt;Directory&gt;&#93;
      &#91;VAR &lt;Variable=Value&gt;&#93;...  &#91;ENV &lt;Variable=Value&gt;&#93;... &#91;USEPROCESSVARS&#93;
      &#91;WORKLOAD &lt;Name&gt;&#93;  &#91;TITLE &lt;Title&gt;&#93;  &#91;WAIT &#91;&lt;Number&gt;[s|m|h|d|w]&#93; | ASYNC&#93;
      &#91;STOPUSING &lt;Method&gt;&#93;  &#91;STATICHANDLENAME &lt;Name&gt;&#93;
      &#91;NEWCONSOLE | SAMECONSOLE&#93;  &#91;FOCUS &lt;Background | Foreground | Minimized&gt;&#93;
      &#91;USERNAME &lt;User name&gt; &#91;PASSWORD &lt;Password&gt;&#93;&#93;
      &#91;DISABLEDAUTHISERROR | IGNOREDISABLEDAUTH&#93;
      &#91;STDIN &lt;File&gt;&#93; &#91;STDOUT &lt;File&gt; | STDOUTAPPEND &lt;File&gt;&#93;
      &#91;STDERR &lt;File&gt; | STDERRAPPEND &lt;File&gt; | STDERRTOSTDOUT&#93;
      &#91;RETURNSTDOUT&#93; &#91;RETURNSTDERR&#93; &#91;RETURNFILE &lt;File&gt;&#93;...
      &#91;NOTIFY ONEND &#91;HANDLE &lt;Handle&gt; | NAME &lt;Name&gt;&#93;  &#91;MACHINE &lt;Machine&gt;&#93;
      &#91;PRIORITY &lt;Priority&gt;&#93; &#91;KEY &lt;Key&gt;&#93;&#93;
</PRE>
<P><TT>WORKLOAD</TT> allows you to specify the name of the workload for which this
process is a member.  This may be useful in conjunction with other PROCESS
commands.  The default is no workload name. This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>TITLE</TT> allows you to specify the program title of the process.
Unless overridden by the process, the <TT>TITLE</TT> will be the text that
is displayed on the title bar of the application. This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>COMMAND</TT> specifies the actual command that you want to start.  If
the path to the command is not specified, the system PATH will be searched
for the command.  Only actual executable files, such as .EXEs, can be STARTed.
Rexx files cannot be STARTed directly.
On Windows systems, they need to be started through REXX.EXE.
This option will resolve variables using the <TT>IGNOREERRORS</TT> option. This option will handle private data.
<P><TT>PARMS</TT> specifies any parameters that you wish to pass to the
command. This option will resolve variables using the <TT>IGNOREERRORS</TT> option. This option will handle private data.
<P><TT>SHELL</TT> specifies that <TT>COMMAND</TT> should be started via a
separate shell.  Using a separate shell allows complex commands involving
pipelines to be readily executed. This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
Note, if <TT>COMMAND</TT> and <TT>PARMS</TT> are both specified they will be
concatenated with a space between them, and the resulting string is what will
be executed.
You may specify an optional shell, which overrides any defaults specified in the
STAF configuration file.  See <A HREF="#HDROPPARMS">4.7, "Operational parameters"</A> for more information on how
to specify the shell.
<P><TT>WORKDIR</TT> specifies the directory from which the command should be
executed.  If you do not specify <TT>WORKDIR</TT>, the command will be
started from whatever directory STAFProc is currently in. This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>WAIT</TT> specifies that the START request should not return until the
process has finished executing.  You may specify an optional time duration,
after which the request should return.  If no time duration is specified,
the request will wait indefinitely until the process has finished executing.
If the <TT>WAIT</TT> does not timeout, the process termination information
will not be saved after the process ends, and no FREE is necessary. This option will resolve variables.
The time duration may be expressed in milliseconds, seconds, minutes,
hours, days, weeks, or years.  Its format is &lt;Number&gt;[s|m|h|d|w],
where &lt;Number&gt; is an integer &gt;= 0 and indicates milliseconds unless one
of the following case-insensitive suffixes is specified:
<UL COMPACT>
<LI>s (for seconds)
<LI>m (for minutes)
<LI>h (for hours)
<LI>d (for days)
<LI>w (for weeks).
</UL>
Note that the calculated timeout cannot exceed 4294967294 milliseconds.
So, the maximum values in each time category that can be specified are:
<UL COMPACT>
<LI>4294967294 (4294967294 milliseconds)
<LI>4294967s (4294967 seconds)
<LI>71582m (71582 minutes)
<LI>1193h (1193 hours)
<LI>49d (49 days)
<LI>7w (7 weeks)
</UL>
<P><TT>ASYNC</TT> specifies that the process should be started asynchronously,
and that the START request should return to the caller as soon as the process
has begun execution.  In this case, the process termination will be saved after
the process ends, and will later need to be FREE'd.  This is the default.
<P><TT>VAR</TT> allows you to specify variables that go into the process
specific variable pool.
<P><TT>ENV</TT> allows you to specify environment variables that will be set
for the process.  Environment variables may be mixed case, however most
programs assume environment variable names will be uppercase, so, in most
cases, ensure that your environment variable names are all in uppercase.
This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>USEPROCESSVARS</TT> specifies that variable references should try to
be resolved from the variable pool associated with the process being started
first.  If the variable is not found in this pool, originating handle's pool,
originator's shared pool, and originator's system pool should be searched if
the request came from local, otherwise originator's handle's pool, originator's
shared pool, remote shared pool and remote system pool should be searched.
<P><TT>STOPUSING</TT> allows you to specify the method by which this process
will be STOPed, if not overridden on the STOP command.  See <A HREF="#HDRPSSTOP">8.13.3, "STOP"</A>
for more information. This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>NEWCONSOLE</TT> specifies that the process should get a new console
window.  So, if a process's stdout/stderr is not redirected, it will be
unavailable.  This is the default for Windows systems.
<P><TT>SAMECONSOLE</TT> specifies that the process should share the STAFProc
console.  So, if a process's stdout/stderr is not redirected, it will be
written to STAFProc's stdout/stderr.  This is the default for Unix systems.
<P><TT>FOCUS</TT> specifies the focus that is to be given to new windows
opened when starting a process on a Windows system.  The window(s) it effects
depends on whether you are using the default command mode or the shell command
mode.  If the process is started using the default command mode (no
<TT>SHELL</TT> option), then the specified focus specified is given to any
new windows opened by the specified command.  Otherwise, if the process is
started using the shell command mode, then the specified focus is given only
to the new shell command window opened, not to any windows opened by the
specified command.  This option only has effect on Windows systems.  This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
This option was added in STAF V3.1.4.  Recognized values are the following:
<UL COMPACT>
<LI>Background:  This indicates to display a window in the background
(not give it focus) in its most recent size and position.
This is the default mode.
<LI>Foreground:  This indicates to display a window in the foreground
(give it focus) in its most recent size and position.
<LI>Minimized:  This indicates to display a window as minimized.
</UL>
<P><TT>USERNAME</TT> specifies the username under which the process should be
started. This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><P><B>Note: </B>The PROCESSAUTHMODE operational parameter must be enabled in the STAF
configuration file on the system where the process is run under a different
username.  See <A HREF="#HDROPPARMS">4.7, "Operational parameters"</A> for more information on how to
enable the PROCESSAUTHMODE operational parameter.  There are additional
requirements that must be met to run a process under a different username
on a Windows system.  See <A HREF="#HDRWINUSER">"Starting a Process Under a Different User on Windows"</A> for more information.
<P><TT>PASSWORD</TT> specifies the password with which to authenticate the user
specified with <TT>USERNAME</TT>. This option will handle private data. This option will resolve variables.
<P><TT>DISABLEDAUTHISERROR</TT> specifies that an error should be returned if
a <TT>USERNAME/PASSWORD</TT> is specified but authentication has been
disabled.  This option overrides any default specified in the STAF configuration
file.
<P><TT>IGNOREDISABLEDAUTH</TT> specifies that any <TT>USERNAME/PASSWORD</TT>
specified on the request is ignored if authentication is disabled.  This option
overrides any default specified in the STAF configuration file.
<P><TT>STATICHANDLENAME</TT> specifies that a static handle should be created
for this process.  The name specified for this option will be the registered
name of the static handle.  Using this option will also cause the environment
variable STAF_STATIC_HANDLE to be set appropriately for the process.
See <A HREF="#HDRSTAFSHS">"Using the STAF command from shell-scripts"</A> for more information on static handles. This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>STDIN</TT> specifies the name of the file from which standard input
will be read. This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>STDOUT</TT> specifies the name of the file to which standard output
will be redirected.  If the file already exists, it will be replaced.
If the directory path specified for the file does not exist, it will be created.
This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>STDOUTAPPEND</TT> specifies the name of the file to which standard
output will be redirected.  If the file already exists, the process' standard
output will be appended to it. If the directory path specified for the file
does not exist, it will be created. This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>STDERR</TT> specifies the name of the file to which standard error
will be redirected.  If the file already exists, it will be replaced.
If the directory path specified for the file does not exist, it will be created.
This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>STDERRAPPEND</TT> specifies the name of the file to which standard
error will be redirected.  If the file already exists, the process' standard
error will be appended to it. If the directory path specified for the file
does not exist, it will be created. This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>STDERRTOSTDOUT</TT> specifies that standard error should be redirected
to the same file to which standard output is being redirected.  This option is
valid only if <TT>STDOUT</TT> or <TT>STDOUTAPPEND</TT>  or <TT>RETURNSTDOUT</TT> is specified.
<P><TT>RETURNSTDOUT</TT> specifies that the contents of the file to which
standard output was redirected should be returned when the process completes.
If <TT>STDOUT</TT> is not specified, standard output will be redirected
to a temporary file.
If <TT>STDERRTOSTDOUT</TT> is specified, the file returned
will contain both standard output and standard error.
This information is only available if using the <TT>WAIT</TT> or
<TT>NOTIFY</TT> options.
<P><TT>RETURNSTDERR</TT> specifies that the contents of the file to which
standard error was redirected should be returned when the process completes.
If <TT>STDERR</TT> is not specified, standard error will be redirected
to a temporary file.
This information is only available if using the <TT>WAIT</TT> or
<TT>NOTIFY</TT> options.
<P><TT>RETURNFILE</TT> specifies that the contents of the specified file
should be returned when the process completes.  This information is only
available if using the <TT>WAIT</TT> or <TT>NOTIFY</TT> options. This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>NOTIFY ONEND</TT> specifies that you wish to send a notification
when this process ends.  See <A HREF="#HDRPROCREG">8.13.8, "NOTIFY REGISTER/UNREGISTER"</A> for the content of the
notification message.
<P><TT>MACHINE</TT> specifies the machine to which the notification should
be sent.  The default is the machine submitting the request. This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>PRIORITY</TT> specifies the priority of the notification message.
The default is 5. This option will resolve variables.
<P><TT>KEY</TT> specifies a key that will be included in the notification
message.  This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P><TT>HANDLE</TT> specifies the handle to which the notification should be
sent.  The default is the handle of the process submitting the request.
This option will resolve variables.
<P><TT>NAME</TT> specifies the registered name of the process(es) to which
the notification should be sent. This option will resolve variables using the <TT>IGNOREERRORS</TT> option.
<P>
<P><H4><A NAME="Header_582">Notes</A></H4>
<P>
<OL TYPE=1>
<P><LI>On Windows systems, if you are redirecting stdin/out/err and are not
using SAMECONSOLE, it is recommended that you redirect all three input/output
streams.  If one or two streams are redirected, but not all three, the
non-redirected streams will not be available to the application.  For example,
if stdout and stderr are redirected, but not stdin, then the application will
receive errors if it tries to read from standard input.  As another example,
if stdin and stdout are redirected, but not stderr, then you will not see any
of the standard error output displayed in the console window.  This problem
only occurs when using NEWCONSOLE, which is the default.  You may freely
redirect any combination of stdin, stdout, and stderr when using SAMECONSOLE.
This problem is due to a known limitation in the Windows API.
<P><LI>A STAF handle variable for the process named STAF/Service/Process/OrgEndpoint
is set that contains the endpoint for the system that originated the
<TT>PROCESS START</TT> request.  The process can use this variable
if it needs to communicate back to the machine that started the process.
<P><LI>Since the entire contents of returned files are stored in the
result string, if you attempt to return the contents of a very large
file, you may run out of memory so it is not recommended that you
use the RETURNSTDOUT, RETURNSTDERR, or RETURNFILE options to return
large files.  To help prevent this problem, you can specify a maximum size
for a file returned by this request by setting the MAXRETURNFILESIZE
operational parameter in the STAF configuration file on the machine where
the process is run, or by setting the STAF/MaxReturnFileSize variable in the
request variable pool of the handle that submitted the request.
The lowest of these two values is used as the maximum return file size
(not including 0 which indicates no limit).
</OL>
<P>
<P><H4><A NAME="Header_583">Security</A></H4>
<P>This command requires trust level 5.
<P>
<P><H4><A NAME="Header_584">Return Codes</A></H4>
<P>All return codes from START are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="HDRPSRES">Results</A></H4>
<P>
<UL>
<P><LI>If the <TT>ASYNC</TT> option is specified, or defaulted to (by not
specifying the <TT>WAIT</TT> option), the result buffer will
contain the handle of the started process.
<P>
<P><LI>If the <TT>WAIT</TT> option is specified and the submit call
does not timeout, the result buffer will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Process/CompletionInfo&gt;</TT> which
represents the completion information for the process,
including the return code from the process, the <TT>KEY</TT>
(if one was specified with the <TT>NOTIFY ONEND</TT> option), as well as
any files specified by <TT>RETURNSTDOUT</TT>, <TT>RETURNSTDERR</TT>,
and/or <TT>RETURNFILE</TT>.
<P> 
The maps are defined as follows:
<BR>
<P><B><A NAME="Table_61">Table 61. Definition of map class STAF/Service/Process/CompletionInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents completion information
for a process.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Return Code
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">key
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Key
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">fileList
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Files
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Process/ReturnFileInfo&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
The "Files" value will contain a list of information about the files
requested to be returned, or an empty list if no files were requested
to be returned.  Files will be returned in the order of standard output,
then standard error, then any files specified with the <TT>RETURNFILE</TT>
option.
</TD></TR></TABLE>
<P>
<BR>
<P><B><A NAME="Table_62">Table 62. Definition of map class STAF/Service/Process/ReturnFileInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a file returned by the process.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Return Code
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">data
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Data
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
For each file, a standard STAF return code indicating the success or failure
of retrieving the file's contents is provided.  If the file's return code
is 0, then the data contained in the file is also provided.
If the file's return code is 58 (Maximum Size Exceeded), that indicates
that the file size exceeded the maximum return file size.
</TD></TR></TABLE>
<P>
For example, suppose a <TT>PROCESS START COMMAND "java TestA" WAIT</TT>
request is submitted from the command line, and assume that the
process completed successfully and returned 0.
The result, in verbose format, could look like the following:
<PRE>
{
  Return Code: 0
  Key        : &lt;None&gt;
  Files      : []
}
</PRE>
<P>
For example, suppose a <TT>PROCESS START COMMAND "java TestA" RETURNSTDOUT RETURNSTDERR WAIT</TT>
request is submitted from the command line, and assume that the
process completed successfully and returned 0, that the
standard output of the process was simply "Success !!!", and that the
standard error of the process was blank.
The result, in verbose format, could look like the following:
<PRE>
{
  Return Code: 0
  Key        : &lt;None&gt;
  Files      : [
    {
      Return Code: 0
      Data       : Success !!!
    }
    {
      Return Code: 0
      Data       : 
    }
  ]
}
</PRE>
<P>
<P><LI>If the <TT>WAIT</TT> option is specified but the submit call timed out,
the result buffer will contain the handle of the started process.  Note, you
will also receive a Timeout error code in this case.
</UL>
<P>
<P><H4><A NAME="Header_586">Examples</A></H4>
<P>
The following examples show the syntax, and results using the STAF command
executable from a Windows command prompt.  These STAF requests could
also be submitted from a program (e.g. Java, C++, Perl, shell, etc.) or
via a &lt;process&gt; element in a STAX job.
<UL>
<P><LI><B>Goal:</B> Start the java executable (with the -version parameter)
on the local machine.
<P><B>Syntax and Results:</B>
<PRE>
C:\&gt;STAF local PROCESS START SHELL COMMAND "java -version"
Response
--------
35
</PRE>
The result buffer contains the handle number of the process that was started
(which in this case is 35).  This is not the return code of the process
as the process was started asynchronously (no <TT>WAIT</TT> option was specified)
so it doesn't wait for the process to complete.
<P>If you invoke the same process again, you'll get a different handle number
each time.  For example:
<PRE>
C:\&gt;STAF local PROCESS START SHELL COMMAND "java -version"
Response
--------
37
</PRE>
If you want the STAF command to wait for the process to complete before
returning, specify the <TT>WAIT</TT> option.  For example:
<PRE>
C:\&gt;STAF local PROCESS START SHELL COMMAND "java -version" WAIT
Response
--------
{
  Return Code: 0
  Key        : &lt;None&gt;
  Files      : []
}
</PRE>
The result buffer contains a map of the results from running the "java -version"
command, including the return code from the command which was 0 in this example.
A return code of 0 from a "java -version" command indicates that the
command ran successfully.  Note that no files were returned, as indicated
by an empty list, [], since none of the return file options (<TT>RETURNSSTDOUT</TT>,
<TT>RETURNSTDERR</TT>, <TT>RETURNFILE</TT>) were specified.
<P>
The "java -version" command writes the Java version information to standard error (stderr).
To obtain that information, plus any information written to standard output (stdout),
you could use the <TT>STDERRTOSTDOUT</TT> option to redirect stderr to stdout and
use the <TT>RETURNSTDOUT</TT> option to return the content of stdout.  For example:
<PRE>
C:\&gt;STAF local PROCESS START SHELL COMMAND "java -version" WAIT STDERRTOSTDOUT RETURNSTDOUT
Response
--------
{
  Return Code: 0
  Key        : &lt;None&gt;
  Files      : [
    {
      Return Code: 0
      Data       : java version "1.5.0"
Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0-b64)
Java HotSpot(TM) Client VM (build 1.5.0-b64, mixed mode, sharing)
 
    }
  ]
}
</PRE>
The result buffer contains a map of the results from running the "java -version"
command, including a return code of 0 and a list of the files returned by the
process, which in this case contains one file (the stdout file).
For each file returned, a standard STAF return code is provided which
indicates the success or failure of retrieving the file's contents, which
in this case was 0, indicating the file's contents were successfully retrieved.
In addition, if the file's return code is 0, then the data contained in the
file is also provided.  In this case, it contains the java version information.
<P>
Note that instead of specifying local as the machine on which to start this
process, you could have specified the name of a remote machine that is also
running STAF and which has given trust level 5 to the requesting machine.
<P>
<P><LI><B>Goal:</B> Start the myTest.exe executable on machine client1.
<P><B>Syntax and Results:</B>
<PRE>
C:\&gt;STAF client1 PROCESS START COMMAND myTest.exe
Response
--------
60
</PRE>
The result buffer contains the handle number of the process that was started
(which in this case is 60).  This is not the return code of the process
as the process was started asynchronously (without the <TT>WAIT</TT> option)
so the STAF request completes as soon as the process is started and doesn't
wait for the process to complete.
<P>
However, if the myTest.exe file was not found in the system path on machine client1,
you would get an error starting the process.  For example:
<PRE>
C:\&gt;STAF client1 PROCESS START COMMAND myTest.exe
Error submitting request, RC: 10
Additional info
---------------
Error starting the process. CreateProcess failed with OS RC 2: The system cannot
 find the file specified.
</PRE>
The return code from the STAF request is 10.  STAF RC 10 indicates a base
operating system error was encountered (e.g. STAF local HELP ERROR 10 gives
more information about STAF RC 10) and an error message that includes the
actual base operating system error code, 2, is provided in the result buffer.
OS error code 2 indicates that a file was not found.  In this case, the
myTest.exe file was not found since it's not in the system path.
<P>
If myTest.exe is located in directory C:\tests on machine client1, you
can fully qualify the path to myTest.exe so that the command can be located
and successfully started.  For example:
<PRE>
C:\&gt;STAF client1 PROCESS START COMMAND C:/tests/myTest.exe
Response
--------
62
</PRE>
Or, if you wanted myTest.exe to run in an environment where the system path
included the C:/tests directory, you can use the <TT>ENV</TT> option to
update the system path environment variable.  Note that if you specify the
<TT>SHELL</TT> option in this situation, you don't need to specify the
path to the command because the updated system path will be used to
find the command.  For example:
<PRE>
C:\&gt;STAF client1 PROCESS START SHELL COMMAND myTest.exe ENV PATH=C:/tests{STAF/Config/Sep/Path}{STAF/Env/Path}
Response
--------
64
</PRE>
<P>
<P><LI><B>Goal:</B> Start a java testcase named TestA (located in directory
C:/tests) on machine client1 and wait for it to complete and return any data that
the testcase program wrote to stdout and to stderr.
<P><B>Syntax and Results:</B>
<PRE>
C:\&gt;STAF client1 PROCESS START COMMAND "java -cp C:/tests TestA" WAIT RETURNSTDOUT RETURNSTDERR
Response
--------
{
  Return Code: 0
  Key        : &lt;None&gt;
  Files      : [
    {
      Return Code: 0
      Data       : SUCCESS.  Yippee!!!
    }
    {
      Return Code: 0
      Data       :
    }
  ]
}
</PRE>
The result buffer contains a map of the results from running the java testcase,
including a return code of 0 and a list of the files returned.  The first file
returned is stdout and it contains <TT>"SUCCESS.  Yippee!!!"</TT>.  The second file
returned is stderr and it contains nothing.
<P>
<P><LI><B>Goal:</B> Start a Windows .bat file named C:\test.bat on Windows machine
client2 and wait for it to complete.  If the .bat file exits using the<TT> /B </TT>option,
e.g. <TT> EXIT /B [rc]</TT>, you'll see that the process return code when run via a
PROCESS START request is always 0 instead of the value of ERRORLEVEL.
(Note:  Run "HELP EXIT" from a Windows command prompt to explain what the<TT> /B </TT>
option does.)
In order to get the real process return code, you need to exit without using the<TT> /B </TT>
option.  For example,<TT> EXIT 99 </TT>.
However, if you cannot change the .bat file (or don't want to), then here's an example
of how you can use the Windows command separator (<TT>&</TT>) to run three commands
as a single process.  First, run the .bat file.  Second, get the ERRORLEVEL value and
set another environment variable named PROCESSRC (or whatever name you prefer) to it's value.
Third, exit using the PROCESSRC value.  For this example, C:\test.bat contains:
<PRE>
@echo off
EXIT /B 99
</PRE>
<P><B>Syntax and Results:</B>
<PRE>
C:\&gt;STAF client2 PROCESS START SHELL COMMAND "C:/test.bat & set PROCESSRC=%ERRORLEVEL% & exit %PROCESSRC%" WAIT
Response
--------
{
  Return Code: 99
  Key        : &lt;None&gt;
  Files      : []
}
</PRE>
</UL>
<P>
The following examples show the goal and the syntax of the request to submit to the
<TT>PROCESS</TT> service but not the results.
<UL>
<P><LI><B>Goal:</B> Start tc1.exe with a title of "Testcase 1" from directory
d:\testcase with environment variables RUNMODE set to Type1 and AUTO=1.
<P><B>Syntax:</B>&nbsp;
<TT>START COMMAND tc1.exe TITLE "Testcase 1" WORKDIR d:/testcase ENV RUNMODE=Type1 ENV AUTO=1</TT>
<P>
<P><LI><B>Goal:</B> Start the tc2 executable from directory d:\webtests as part of workload
Web Tests, with STAF variables WebServer set to testsrv1.test.austin.ibm.com and RunMode set to 1,
and don't return until it completes.
<P><B>Syntax:</B>&nbsp;
<TT>START COMMAND tc2 WORKDIR d:/webtests VAR WebServer=testsrv1.test.austin.ibm.com VAR RunMode=1 WORKLOAD "Web Tests" WAIT</TT>
<P>
<P><LI><B>Goal:</B> Start testcase www1.exe.  The testcase resides in and should
be run from the directory referred to by variable WWWTestDir.  Wait a
maximum of 30 minutes for the process to end.
<P><B>Syntax:</B>&nbsp;
<TT>START COMMAND {WWWTestDir}/www1.exe WORKDIR {WWWTestDir} WAIT 30m</TT>
<P>
<P><LI><B>Goal:</B> Start tc2.exe from directory c:/testcase and register to
receive a notification when the process ends.
<P><B>Syntax:</B>&nbsp;
<TT>START COMMAND tc2.exe WORKDIR c:/testcase NOTIFY ONEND</TT>
<P>
<P><LI><B>Goal:</B> Start tc2.exe from directory c:\testcase and register to
have a priority 1 notification sent to registered process name ProcessHandler
on machine EventController.  The Key "9bt1az54fq" will be included in the
notification message.
<P><B>Syntax:</B>&nbsp;
<TT>START COMMAND tc2.exe WORKDIR c:/testcase NOTIFY ONEND PRIORITY 1 MACHINE EventController NAME ProcessHandler KEY 9bt1az54fq</TT>
<P>
<P><LI><B>Goal:</B> Start tc2.exe from directory c:\testcase and it to be STOPed
via the SIGINT method.
<P><B>Syntax:</B>&nbsp;
<TT>START COMMAND tc2.exe WORKDIR c:/testcase STOPUSING SIGINT</TT>
<P>
<P><LI><B>Goal:</B> Start tc2.exe from directory c:\testcase and have it run in the
same console as STAFProc.
<P><B>Syntax:</B>&nbsp;
<TT>START COMMAND tc2.exe WORKDIR c:/testcase SAMECONSOLE</TT>
<P>
<P><LI><B>Goal:</B> Start tc2 from directory /testcases using userid testuser and
password tupass and use privacy delimiters to indicate that the password is private.
<P><B>Syntax:</B>&nbsp;
<TT>START COMMAND tc2 WORKDIR /testcases USERNAME testuser PASSWORD !!@tupass@!!</TT>
<P>
<P><LI><B>Goal:</B> Start tc2 from directory /testcases and redirect standard output
to /testcases/tc2/stdout.txt.
<P><B>Syntax:</B>&nbsp;
<TT>START COMMAND tc2 WORKDIR /testcase STDOUT /testcases/tc2/stdout.txt</TT>
<P>
<P><LI><B>Goal:</B> Start shell-script tc3.sh and ensure it uses a static handle with
registered name "Test case 3".
<P><B>Syntax:</B>&nbsp;
<TT>START COMMAND tc3.sh STATICHANDLENAME "Test case 3"</TT>
<P>
<P><LI><B>Goal:</B> Execute the following shell-style command "ps | grep test |
wc &gt;testcount.txt"
<P><B>Syntax:</B>&nbsp;
<TT>START SHELL COMMAND "ps | grep test | wc &gt;testcount.txt"</TT>
<P>
<P><LI><B>Goal:</B> Execute the following shell-style
command "grep 'Count = ' /tests/out | awk '{print $5}'" redirecting its standard
output and standard error to /tests/awk.out.
<P><B>Syntax:</B>&nbsp;
<TT>START SHELL COMMAND "grep 'Count = ' /tests/out | awk '{print $5}'" STDOUT /tests/awk.out STDERRTOSTDOUT</TT>
<P><B>Note:</B>  When using STAF V3.4.0 or later, you no longer have to use
a caret (^) as an escape character for "{" if it does not denote a variable
reference because the <TT>IGNOREERRRORS</TT> option is used when submitting a
VAR RESOLVE request to resolve variables in option values on a PROCESS START request.
<P>
<P><LI><B>Goal:</B> Start shell-script tc3.sh and redirect its standard output and
standard error to /tmp/tc3.out
<P><B>Syntax:</B>&nbsp;
<TT>START COMMAND tc3.sh STDOUT /tmp/tc3.out STDERRTOSTDOUT</TT>
<P>
<P><LI><B>Goal:</B> Start shell-script tc3.sh, redirect its standard output and
standard error to /tmp/tc3.out, and wait for it to complete.  Additionally,
have the contents of standard output (which also contains standard error),
as well as the contents of file /tmp/tc3.results, returned when the script completes.
<P><B>Syntax:</B>&nbsp;
<TT>START COMMAND tc3.sh STDOUT /tmp/tc3.out STDERRTOSTDOUT WAIT RETURNSTDOUT RETURNFILE /tmp/tc3.results</TT>
<P>
<P><LI><B>Goal:</B> Start shell-script tc3.sh, redirect its standard output and
standard error to a temporary file (indicated by not specifying STDOUT),
and wait for it to complete.  Additionally, have the contents of standard output
(which also contains standard error) returned when the script completes.
<P><B>Syntax:</B>&nbsp;
<TT>START COMMAND tc3.sh STDERRTOSTDOUT WAIT RETURNSTDOUT</TT>
<P>
<P><LI><B>Goal:</B> Start shell-script "D:/tests/test1.sh machA" on a Windows system specifying
to start the command via a Cygwin shell.
<P><B>Syntax:</B>&nbsp;
<TT>START SHELL "D:/Cygwin/bin/bash.exe -c %C" COMMAND "D:/tests/test1.sh machA" WORKDIR D:/tests</TT>
<P>
<P><LI><B>Goal:</B> Start shell-script "/tests/test1.sh machA" on a Unix system specifying
to start the command via a xterm shell with a title of "Test 1" and to redirect standard
output to /tests/test1.out.
<P><B>Syntax:</B>&nbsp;
<TT>START SHELL "xterm -title %T -e /bin/sh -c %X" COMMAND "/tests/test1.sh machA" TITLE "Test 1" STDOUT /tests/test1.out</TT>
<P>
<P><LI><B>Goal:</B> Start shell-script "/tests/test1.sh machA" on a Unix system specifying
to start the command via a C shell.
<P><B>Syntax:</B>&nbsp;
<TT>START SHELL "/bin/csh -c %C" COMMAND "/tests/test1.sh machA" WORKDIR /tests</TT>
<P>
<P><LI><B>Goal:</B> Run a command, 'echo $HOME', on a UNIX system as if the system was
actually logged in as a user named test so that it echos the home directory for user
test, e.g. /home/test, instead of the home directory for the root user that STAFProc
was started with, e.g. /root.
<P><B>Syntax:</B>&nbsp;
<TT>START SHELL 'su - %u -c %C' COMMAND 'echo $HOME' USERNAME test WAIT STDOUT /temp/test.out STDERRTOSTDOUT RETURNSTDOUT</TT>
</UL>
<P>
<A NAME="IDX474"></A>
<P><H4><A NAME="HDRWINUSER">Starting a Process Under a Different User on Windows</A></H4>
<P>
To start a process under a different user name on a Windows system, the following
requirements must be met:
<OL TYPE=1>
<P><LI>The <TT>PROCESSAUTHMODE</TT> operational parameter must be set
to <TT>WINDOWS</TT> on the system where the process is run.
See <A HREF="#HDROPPARMS">4.7, "Operational parameters"</A> for more information on how to enable
the <TT>PROCESSAUTHMODE</TT> operational parameter.
<P><LI>The Windows system where the process is run must be Windows 2000 or later.
<P><LI>The user currently logged on the system where the process is specified to run
must be a member of the Administrators group and must have the following user rights:
<UL COMPACT>
<LI>Act as part of the operating system  (if Win2000)
<LI>Replace a process level token  (if Win2000 or later)
</UL>
See <A HREF="#HDRWINUSERRIGHTS">"Changing User Rights Assignments"</A> for more information on how to change user rights assignments.
<P><LI>On Windows XP systems, the user name specified when starting a process must have a password.
<P><LI>On Windows Vista and Windows Server 2008 systems, STAFProc.exe must be run as an administrator to start
a process as another user.  Otherwise, submitting a STAF PROCESS START request specifying
the USERNAME/PASSWORD options to start a process as another user will fail
with RC 10 "LoadUserProfile failed with OS RC 1314:  A required privilege is not held by the
client" even though you assigned the "Replace a process level token" user right to the
administrator account.  On Windows Vista, STAFProc is run using the least amount of privileges
(e.g. that of a standard user) even though you are logged in as an administrator.
In order to start a process as another user, you must run STAFProc as an administrator.
There are several ways to do this:
<UL COMPACT>
<LI>Find STAFProc.exe (e.g. C:\STAF\bin\STAFProc.exe) via Windows Explorer and
right mouse click on it.  To change just this one instance of starting STAFProc,
select "Run as administrator".
<LI>Or, find STAFProc.exe (e.g. C:\STAF\bin\STAFProc.exe) via Windows Explorer and
right mouse click on it.  Select "Properties" and then select the "Compatibility" tab,
and check the box under "Privilege Level" labeled "Run the program as an administrator"
and select OK.  Now, any time you start STAFProc it will be run as an administrator.
<LI>Or find "Command Prompt" and right mouse on it and select "Run as administrator".
Any program such as STAFProc that is run from a "Administrator: Command Prompt", will be
run as an administrator.
</UL>
</OL>
<P>
There are operating system limitations on how many processes can run concurrently under a
different user in the same desktop.  If you get RC 10 with OS RC 1816, and the user name
that the process is being run under is not a member of the Administrator group, then you
may want to give it the "Increase quotas" user right so that more processes can
run concurrently.  See <A HREF="#HDRWINUSERRIGHTS">"Changing User Rights Assignments"</A> for more information on how to change
user rights assignments.
<P>
If you are having problems starting a process under a different user name, use the Trace service
to enable error and warning trace points to see if you get more information.
<A NAME="IDX476"></A>
<P><H4><A NAME="HDRWINUSERRIGHTS">Changing User Rights Assignments</A></H4>
<P>
This information is provided to help you change user rights assignments as needed to
start a process under a different user name.
<P>
On Windows Vista systems, to view or modify user rights assignments in the local security policy,
perform the following:
<OL COMPACT TYPE=1>
<LI>Open the Control Panel, from the Classic view, double click on "Administrative Tools".
<LI>Double click on "Local Security Policy".
<LI>Double click on "Local Policies".
<LI>Click on "User Rights Assignment".
<LI>Double click on the user right you want to view or modify.
<LI>Add any users or groups you require.
<LI>If the rights for a user currently logged on are changed, the user must
logoff for the changes to take effect.
</OL>
<P>
On Windows XP systems, to view or modify user rights assignments in the local security policy,
when logged on as an administrator, perform the following:
<OL COMPACT TYPE=1>
<LI>Open the Control Panel, from the Classic view, double click on "Administrative Tools".
<LI>Double click on "Local Security Policy".
<LI>Click on "User Rights Assignment".
<LI>Double click on the user right you want to view or modify.
<LI>Add any users or groups you require.
<LI>If the rights for a user currently logged on are changed, the user must
logoff for the changes to take effect.
</OL>
On Windows 2000 systems, to view or modify user rights assignments in the local security policy,
when logged on as an administrator, perform the following:
<OL COMPACT TYPE=1>
<LI>Click on Start -&gt; Settings -&gt; Control Panel and double click on "Administrative Tools".
<LI>Double click on "Local Security Policy" and double click on "Local Policies".
<LI>Double click on "User Rights Assignment".
<LI>Double click on the user right you want to view or modify.
<LI>Add any user names you require.
<LI>If the rights for a user currently logged on are changed, the user must
logoff for the changes to take effect.
</OL>
<A NAME="IDX479"></A>
<P><H3><A NAME="HDRPSSTOP">8.13.3 STOP</A></H3>
<P>STOP allows you to stop a process that was started via STAF (e.g. a process
that was started by submitting a START request to the PROCESS service).
You may stop a single process, all processes that are part of a given workload, or all
processes started by STAF.
<P><H4><A NAME="Header_590">Syntax</A></H4>
<PRE>
STOP &lt;ALL CONFIRM | WORKLOAD &lt;Name&gt; | HANDLE &lt;Handle&gt;&gt; &#91;USING &lt;Method&gt;&#93;
</PRE>
<P><TT>ALL</TT> specifies that you want to stop all running processes that
STAF has STARTed.  If you wish to do this, you must also specify the
<TT>CONFIRM</TT> option.
<P><TT>WORKLOAD</TT> specifies that you want to stop all processes that are
part of a given workload. This option will resolve variables.
<P><TT>HANDLE</TT> specifies that only the specified handle should be stopped. This option will resolve variables.
<P><TT>USING</TT> specifies the method used to stop the process.  This option will resolve variables.
The following methods are supported&#58;
<UL COMPACT>
<LI>SIGKILLALL - This unconditionally stops the process and all of its
child processes.  On Unix systems, this sends a SIGKILL signal to the
process and all of its child processes.
On Windows XP and later systems,  this uses the taskkill command with
the force (/f) and tree (/t) options.
On Windows 2000 and earlier systems, this sends a WM_CLOSE message to
the application (see below for more information on WM_CLOSE).
This is particularly useful for stopping console applications which spawn
numerous child processes.  This is the default.
<LI>SIGKILL - This unconditionally stops the process.  On Unix systems, this
sends a SIGKILL signal to the process.  On Windows, this calls TerminateProcess().
<LI>SIGTERM - On Unix systems, this sends a SIGTERM signal to the process.
On Windows systems, this sends a CTRL-Break event to the process (note,
the process must have been STARTed with the SAMECONSOLE option for this to work).
<LI>SIGTERMALL - On Unix systems, this sends a SIGTERM signal to the process
and all of its child processes.  This is not supported on Windows systems.
<LI>SIGINT - On Unix systems, this sends a SIGINT signal to the process.
On Windows systems, this sends a CTRL-C event to the process (note, the
process must have been STARTed with the SAMECONSOLE option for this to work).
<LI>SIGINTALL - On Unix systems, this sends a SIGINT signal to the process
and all of its child processes.  This is not supported on Windows systems.
<LI>WM_CLOSE - On Windows systems, this unconditionally stops the process
and all of its child processes by sending a WM_CLOSE message to the application.
This will not work on console applications started using the SAMECONSOLE
option.  This is not supported on Unix systems.
</UL>
<P><H4><A NAME="Header_591">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_592">Return Codes</A></H4>
<P>All return codes from STOP are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_593">Results</A></H4>
<P>
<UL>
<P><LI>If the <TT>HANDLE</TT> option is specified, the result buffer
will be empty if successful.
<P>
<P><LI>If the <TT>ALL</TT> or <TT>WORKLOAD</TT> option is specified,
the result buffer will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Process/StopInfo&gt;</TT> defined as follows
if successful:
<BR>
<P><B><A NAME="Table_63">Table 63. Definition of map class STAF/Service/Process/StopInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents statistics for
stopped processes.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">stoppedProcesses
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Stopped Processes
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">totalProcesses
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Total Processes
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
This map contains the number of processes actually stopped
and the total number of processes.  These two numbers will be 
different if some of the processes have already been stopped or
have already completed execution on their own.
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_594">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Stop process with handle 42.
<P><B>Syntax:</B>&nbsp; <TT>STOP HANDLE 42</TT>
<P>
<P><LI><B>Goal:</B> Gracefully stop process with handle 113 using the SIGTERM method.
<P><B>Syntax:</B>&nbsp; <TT>STOP HANDLE 113 USING SIGTERM</TT>
<P>
<P><LI><B>Goal:</B> Unconditionally stop process with handle 17.
<P><B>Syntax:</B>&nbsp; <TT>STOP HANDLE 17 USING SIGKILL</TT>
<P>
<P><LI><B>Goal:</B> Stop all processes in the Web Tests workload.
<P><B>Syntax:</B>&nbsp; <TT>STOP WORKLOAD "Web Tests"</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
Stopped Processes: 5
Total Processes: 18
</PRE>
<P>
<P><LI><B>Goal:</B> Stop all processes currently running via STAF.
<P><B>Syntax:</B>&nbsp; <TT>STOP ALL CONFIRM</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
Stopped Processes: 16
Total Processes: 16
</PRE>
</UL>
<A NAME="IDX482"></A>
<P><H3><A NAME="HDRPSKILL">8.13.4 KILL</A></H3>
<P>KILL allows you to kill any process (even a process not started by STAF),
except for the STAFProc process.  Instead, use the SHUTDOWN service to shut
down the STAFProc process.
<P>
<B>Note&#58;</B> If you want to kill a process that you started via STAF,
in most cases, you probably want to use the STOP request to kill the process
rather than using the KILL request.
<P>
<B>Warning&#58;</B> Be very careful when using this command to specify
the correct pid for the process you want to kill so that you don't accidently
kill a process that you didn't intend to kill.
<P>
<P><H4><A NAME="Header_596">Syntax</A></H4>
<PRE>
KILL PID &lt;Pid&gt; CONFIRM &#91;USING &lt;Method&gt;&#93;
</PRE>
<P><TT>PID</TT> specifies the process id (e.g. pid) of the process that
should be killed. This option will resolve variables.
<P><TT>CONFIRM</TT> confirms that you really want to kill this process.
<P><TT>USING</TT> specifies the method used to kill the process.  This option will resolve variables.
The following methods are supported&#58;
<UL COMPACT>
<LI>SIGKILLALL - This unconditionally stops the process and all of its
child processes.  On Unix systems, this sends a SIGKILL signal to the
process and all of its child processes.
On Windows XP and later systems,  this uses the taskkill command with
the force (/f) and tree (/t) options.
On Windows 2000 and earlier systems, this sends a WM_CLOSE message to
the application (see below for more information on WM_CLOSE).
This is particularly useful for stopping console applications which spawn
numerous child processes.  This is the default.
<LI>SIGKILL - This unconditionally stops the process.  On Unix systems, this
sends a SIGKILL signal to the process.  On Windows, this calls TerminateProcess().
<LI>SIGTERM - On Unix systems, this sends a SIGTERM signal to the process.
On Windows systems, this sends a CTRL-Break event to the process (note,
the process must have been STARTed with the SAMECONSOLE option for this to work).
<LI>SIGINT - On Unix systems, this sends a SIGINT signal to the process.
On Windows systems, this sends a CTRL-C event to the process (note, the
process must have been STARTed with the SAMECONSOLE option for this to work).
<LI>WM_CLOSE - On Windows systems, this unconditionally stops the process
and all of its child processes by sending a WM_CLOSE message to the application.
This will not work on console applications started using the SAMECONSOLE
option.  This is not supported on Unix systems.
</UL>
<P>
If the <TT>USING</TT> option is not specified, it will use the default
stop method for the PROCESS service.  You can list the settings
for the PROCESS service, including the default stop method by submitting
a <TT>LIST SETTINGS</TT> request to the PROCESS service.
<P>
<P><H4><A NAME="Header_597">Security</A></H4>
<P>This command requires trust level 5.
<P>
<P><H4><A NAME="Header_598">Return Codes</A></H4>
<P>All return codes from KILL are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_599">Results</A></H4>
<P>
If successful, the result buffer will be empty.
<P>
<P><H4><A NAME="Header_600">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Kill the process with pid 1884 using the default stop
method for the the PROCESS service.
<P><B>Syntax:</B>&nbsp; <TT>KILL PID 1884 CONFIRM</TT>
<P>
<P><LI><B>Goal:</B> Kill the process with pid 1232 using the SIGKILL method.
<P><B>Syntax:</B>&nbsp; <TT>KILL PID 1231 CONFIRM USING SIGKILL</TT>
<P>
<P><LI><B>Goal:</B> Kill the process with pid 3340 running on Windows using
the WM_CLOSE method.
<P><B>Syntax:</B>&nbsp; <TT>KILL PID 3340 CONFIRM USING WM_CLOSE</TT>
</UL>
<A NAME="IDX485"></A>
<P><H3><A NAME="Header_601">8.13.5 LIST</A></H3>
<P>LIST allows you to obtain information about all of the processes started
via STAF, or only those processes started via STAF that are currently
running, or only those processes started via STAF that have completed.
You may get information about any process started in <TT>WAIT</TT> mode
that is still running and/or about any process started in <TT>ASYNC</TT>
mode that has not yet been freed.
<P>You can also list the operational settings for the Process service.
<P><H4><A NAME="Header_602">Syntax</A></H4>
<PRE>
LIST &#91;HANDLES&#93; &#91;RUNNING&#93; &#91;COMPLETED&#93; &#91;WORKLOAD &lt;Name&gt;&#93; &#91;LONG&#93; 
</PRE>
or
<PRE>
LIST SETTINGS
</PRE>
<P><TT>HANDLES</TT> specifies that you want information for process handles.
<P><TT>RUNNING</TT> specifies that you only want information for processes
that are currently running.
<P><TT>COMPLETED</TT> specifies that you only want information for processes
started in <TT>ASYNC</TT> mode that have completed, but have not yet been
freed.
<P><TT>WORKLOAD</TT> specifies that you want information for processes
that are part of a given workload. This option will resolve variables.
<P><TT>LONG</TT> specifies that you want to list more detailed information
for the processes.
<P><TT>SETTINGS</TT> specifies that you want to list the current
operational settings for the Process service.
<P><H4><A NAME="Header_603">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_604">Return Codes</A></H4>
<P>All return codes from LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_605">Results</A></H4>
<P>On successful return:
<UL>
<P><LI>If option <TT>LONG</TT> is not specified (and option <TT>SETTINGS</TT>
is not speciifed), the result buffer will contain
a marshalled <TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Process/ProcessListInfo&gt;</TT>
representing processes started in <TT>WAIT</TT> mode that are still
running and/or processes started in <TT>ASYNC</TT> mode that have not
yet been freed. 
The map is defined as follows: 
<BR>
<P><B><A NAME="Table_64">Table 64. Definition of map class STAF/Service/Process/ProcessListInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a process.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Handle
<BR>
(H#)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">command
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Command
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Private data will be masked.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">startTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Start Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">endTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">End Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Return Code
<BR>
(RC)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
The value for "End Date-Time" and "Return Code" will be <TT>&lt;None&gt;</TT> if
the process is still running.
</TD></TR></TABLE>
<P>
<P><LI>If option <TT>LONG</TT> is specified, the result buffer will contain
a marshalled <TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Process/ProcessListLong&gt;</TT>
representing more detailed information about processes started in <TT>WAIT</TT> mode
that are still running and/or processes started in <TT>ASYNC</TT> mode that have not
yet been freed. 
The map is defined as follows: 
<BR>
<P><B><A NAME="Table_65">Table 65. Definition of map class STAF/Service/Process/ProcessListLong</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents detailed information for a process.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Handle
<BR>
(H#)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">workload
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Workload
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">command
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Command
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Private data will be masked.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">pid
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">PID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">startTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Start Date-Time
<BR>
(Start D-T)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">endTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">End Date-Time
<BR>
(End D-T)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Return Code
<BR>
(RC)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The "PID" value will contain the process id assigned by the operating system.
<LI>The value for "End Date-Time" and "Return Code" will be <TT>&lt;None&gt;</TT> if
the process is still running.
</OL>
</TD></TR></TABLE>
<P>
<P><LI>If option <TT>SETTINGS</TT> is specified, the result buffer will contain
a marshalled <TT>&lt;Map&#58;STAF/Service/Process/Settings&gt;</TT>
representing the current settings for the Process service.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_66">Table 66. Definition of map class STAF/Service/Process/Settings</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the operational
settings for the Process service.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">defaultStopUsing
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Default Stop Using Method
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">defaultConsoleMode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Default Console Mode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'New' | 'Same'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">defaultFocus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Default Focus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Background' | 'Foreground' | 'Minimized'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">processAuthMode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Process Auth Mode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">defaultAuthUsername
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Default Auth Username
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">defaultAuthPassword
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Default Auth Password
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Private data will be masked.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">defaultAuthDisabledAction
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Default Auth Disabled Action
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Ignore' | 'Error'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">defaultShell
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Default Shell
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">defaultNewConsoleShell
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Default New Console Shell
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">defaultSameConsoleShell
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Default Same Console Shell
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>If the "Default Auth Username" is not set, it's value will be
displayed as <TT>&lt;None&gt;</TT>.
<LI>If the "Default Auth Password" is not set, it's value will be
displayed as <TT>&lt;None&gt;</TT>.  If a password has been set, <TT>'*******'</TT>
will be displayed instead of the actual password.
<LI>The values for "Default Shell", "Default New Console Shell", and
"Default Same Console Shell" will display as <TT>&lt;None&gt;</TT> if the
corresponding default shell is not set (e.g. not overridden).
</OL>
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_606">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> List all processes
<P><B>Syntax:</B>&nbsp; <TT>LIST</TT> (or <TT>LIST HANDLES</TT>)
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in table format, could look like:
<PRE>
Handle Command                Start Date-Time   End Date-Time     RC
------ ---------------------- ----------------- ----------------- ------
17     notepad.exe            20051205-11:33:14 20040912-11:37:55 0
25     java TestProcess 5 5 0 20051205-11:53:18 20040912-11:53:18 1
29     java TestA             20051205-12:01:05 20040912-12:05:23 0
43     java TestB             20051205-12:32:38 &lt;None&gt;            &lt;None&gt;
47     C:/tests/MyTest.exe    20051205-12:32:56 &lt;None&gt;            &lt;None&gt;
56     C:/tests/tc1.exe       20051205-12:33:24 20040912-12:35:32 3
</PRE>
<P>
<P><LI><B>Goal:</B> List all the processes that have completed.
<P><B>Syntax:</B>&nbsp; <TT>LIST COMPLETED HANDLES</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in table format, could look like:
<PRE>
Handle Command                Start Date-Time   End Date-Time     RC
------ ---------------------- ----------------- ----------------- --
17     notepad.exe            20051205-11:33:14 20040912-11:37:55 0
25     java TestProcess 5 5 0 20051205-11:53:18 20040912-11:53:18 1
29     java TestA             20051205-12:01:05 20040912-12:05:23 0
56     C:/tests/tc1.exe       20051205-12:33:24 20040912-12:35:32 3
</PRE>
<P>
<P><LI><B>Goal:</B> List all the processes that are still running
<P><B>Syntax:</B>&nbsp; <TT>LIST RUNNING HANDLES</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in table format, could look like:
<PRE>
Handle Command             Start Date-Time   End Date-Time RC
------ ------------------- ----------------- ------------- ------
43     java TestB          20051205-12:32:38 &lt;None&gt;        &lt;None&gt;
47     C:/tests/MyTest.exe 20051205-12:32:56 &lt;None&gt;        &lt;None&gt;
</PRE>
<P>
<P><LI><B>Goal:</B> List detailed information about all the processes
<P><B>Syntax:</B>&nbsp; <TT>LIST LONG</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in table format, could look like:
<PRE>
H# Workload Command          PID  Start Date-Time   End Date-Time     RC     
-- -------- ---------------- ---- ----------------- ----------------- --------- 
17 &lt;None&gt;   notepad.exe      1444 20051205-11:33:14 20040912-11:37:55 0     
25 &lt;None&gt;   java TestProcess 2836 20051205-11:53:18 20040912-11:53:18 1     
             5 5 0
29 My Test  java TestA       3376 20051205-12:01:05 20040912-12:05:23 0     
43 My Test  java TestB       2776 20051205-12:32:38 &lt;None&gt;            &lt;None&gt;
47 My Test  C:/tests/MyTest. 2448 20051205-12:32:56 &lt;None&gt;            &lt;None&gt;
            exe
56 TC1      C:/tests/tc1.exe 2840 20040912-12:33:24 20040912-12:35:32 3
</PRE>
<P>
<P><LI><B>Goal:</B> List all the processes with workload MyWorkload 
<P><B>Syntax:</B>&nbsp; <TT>LIST WORKLOAD "My Test"</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in table format, could look like:
<PRE>
Handle Command             Start Date-Time   End Date-Time RC     
------ ------------------- ----------------- ------------- ------
43     java TestB          20051205-12:32:38 &lt;None&gt;        &lt;None&gt;
47     C:/tests/MyTest.exe 20051205-12:32:56 &lt;None&gt;        &lt;None&gt;
</PRE>
<P>
<P><LI><B>Goal:</B> List the current operational settings for the
Process service
<P><B>Syntax:</B>&nbsp; <TT>LIST SETTINGS</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in default format, could look like:
<PRE>
Default Stop Using Method   : SigKillAll
Default Console Mode        : New
Default Focus               : Background
Process Auth Mode           : Disabled
Default Auth Username       : &lt;None&gt;
Default Auth Password       : &lt;None&gt;
Default Auth Disabled Action: Ignore
Default Shell               : &lt;None&gt;
Default New Console Shell   : &lt;None&gt;
Default Same Console Shell  : &lt;None&gt;
</PRE>
</UL>
<A NAME="IDX488"></A>
<P><H3><A NAME="Header_607">8.13.6 QUERY</A></H3>
<P>QUERY allows you to obtain detailed information about a process with a
specified handle that was started via STAF.
<P><H4><A NAME="Header_608">Syntax</A></H4>
<PRE>
QUERY HANDLE &lt;Handle&gt;
</PRE>
<P><TT>HANDLE</TT> specifies the handle number of the process
you want information on.  This option will resolve variables.
<P><H4><A NAME="Header_609">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_610">Return Codes</A></H4>
<P>All return codes from QUERY are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_611">Results</A></H4>
<P>The result buffer will contain a marshalled
<TT>Map&#58;STAF/Service/Process/ProcessInfo&gt;</TT>, representing
information about the process specified to be queried.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_67">Table 67. Definition of map class STAF/Service/Process/ProcessInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a process.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">handleName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Handle Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">title
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Title
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">workload
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Workload
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">shell
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Shell
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;Default Shell&gt;</TT> if no value is specified
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">command
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Command
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Private data will be masked.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">parms
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Parms
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Private data will be masked.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">workdir
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Workdir
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">focus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Focus
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>'Background' | 'Foreground' | 'Minimized'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">userName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">User Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">key
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Key
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">pid
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">PID
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">startMode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Start Mode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> 
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>'Async' | 'Wait'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">startTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Start Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">endTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">End Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Return Code
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The value for "PID" will be the process ID assigned by the operating system.
<LI>The value for "End Date-Time" and "Return Code" will be <TT>&lt;None&gt;</TT> if
the process is still running.
</OL>
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_612">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Query a process with handle 17 that is still
running.
<P><B>Syntax:</B>&nbsp; <TT>QUERY HANDLE 17</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
Handle         : 17
Handle Name    : &lt;None&gt;
Title          : Notepad
Workload       : MyWorkload
Shell          : &lt;None&gt;
Command        : notepad.exe
Parms          : &lt;None&gt;
Workdir        : &lt;None&gt;
Focus          : Background
User Name      : &lt;None&gt;
Key            : &lt;None&gt;
PID            : 3280
Start Mode     : Async
Start Date-Time: 20051205-11:33:14
End Date-Time  : &lt;None&gt;
Return Code    : &lt;None&gt;
</PRE>
<P>
<P><LI><B>Goal:</B> Query a process with handle 42 that has completed
<P><B>Syntax:</B>&nbsp; <TT>QUERY HANDLE 42</TT>
<P><B>Results:</B>  If the request was issued from the
command line, the result in default format, could look like:
<PRE>
Handle         : 42
Handle Name    : Web Tests
Title          : TestA
Workload       : &lt;None&gt;
Shell          : &lt;None&gt;
Command        : D:/Tests/TestA.exe
Parms          : &lt;None&gt;
Workdir        : D:/Tests
Focus          : Background
User Name      : &lt;None&gt;
Key            : &lt;None&gt;
PID            : 3285
Start Mode     : Async
Start Date-Time: 20051205-11:33:14
End Date-Time  : 20051205-11:37:55
Return Code    : 0
</PRE>
</UL>
<A NAME="IDX491"></A>
<P><H3><A NAME="Header_613">8.13.7 FREE</A></H3>
<P>When processes are STARTed asynchronously, the termination timestamp and
return code are stored by STAF for later retrieval.  In order to free these
values, you use the PROCESS FREE command.  You may only free information for
processes that are already stopped.  You may free the termination information
for a single process, all the stopped processes of a given workload, or all
stopped processes that have been started by STAF.
<P><H4><A NAME="Header_614">Syntax</A></H4>
<PRE>
FREE &lt;ALL | WORKLOAD &lt;Name&gt; | HANDLE &lt;Handle&gt;&gt;
</PRE>
<P><TT>ALL</TT> specifies that you want to free the termination information
for all stopped processes.
<P><TT>WORKLOAD</TT> specifies that you want to free the termination
information for all processes that are part of a given workload. This option will resolve variables.
<P><TT>HANDLE</TT> specifies that only the termination information for the
specified handle should be freed. This option will resolve variables.
<P><H4><A NAME="Header_615">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_616">Return Codes</A></H4>
<P>All return codes from FREE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_617">Results</A></H4>
<P>
<UL>
<P><LI>If the <TT>HANDLE</TT> option is specified, the termination
information will be freed for the specified handle, and the
result buffer will be empty.
<P>
<P><LI>If the <TT>ALL</TT> or <TT>WORKLOAD</TT> option is specified,
the result buffer will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Process/FreeInfo&gt;</TT>, representing
the statistics for the freed processes.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_68">Table 68. Definition of map class STAF/Service/Process/FreeInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents statistics for
freed processes.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">freedProcesses
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Freed Processes
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">totalProcesses
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Total Processes
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
This map contains the number of processes for which termination
information was actually freed and the total number of processes.
These two numbers will be different if some of the processes have
not yet been stopped or have not completed execution.
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_618">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Free the termination information for a process
with handle 42.
<P><B>Syntax:</B>&nbsp; <TT>FREE HANDLE 42</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
Freed Processes: 1
Total Processes: 10
</PRE>           
<P>
<P><LI><B>Goal:</B> Free the termination information for all the
processes in the "Web Tests" workload.
<P><B>Syntax:</B>&nbsp; <TT>FREE WORKLOAD "Web Tests"</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
Freed Processes: 2
Total Processes: 17
</PRE>           
<P>
<P><LI><B>Goal:</B> Free the termination information for
all stopped processes.
<P><B>Syntax:</B>&nbsp; <TT>FREE ALL</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in table format, could look like:
<PRE>
Freed Processes: 15
Total Processes: 16
</PRE>
</UL>
<A NAME="IDX492"></A>
<A NAME="IDX495"></A>
<P><H3><A NAME="HDRPROCREG">8.13.8 NOTIFY REGISTER/UNREGISTER</A></H3>
<P>NOTIFY REGISTER/UNREGISTER allow you to either register or unregister to
receive a notification when a given process ends.
<P>
<P><H4><A NAME="Header_620">Syntax</A></H4>
<PRE>
NOTIFY &lt;REGISTER | UNREGISTER&gt; ONENDOFHANDLE &lt;Handle&gt; &#91;MACHINE &lt;Machine&gt;&#93;
       &#91;PRIORITY &lt;Priority&gt;&#93;  &#91;HANDLE &lt;Handle&gt; | NAME &lt;Name&gt;&#93;
</PRE>
<P>
<TT>REGISTER</TT> indicates you want to register for a notification
when a process ends.  The queued message will have type "STAF/Process/End" and
its message will contain a marshalled <TT>&lt;Map&gt;</TT> which represents the
completion information for the process.  See tables <A HREF="#TBLSTAFPROCESSENDTABLE">Table 69</A>
and <A HREF="#TBLPROCESSRETURNEDFILETABLE">Table 70</A> for the map definitions of a
process completion message.
<P>
<TT>UNREGISTER</TT> indicates you want to unregister a process end
notification.
<P>
<TT>ONENDOFHANDLE</TT> indicates the handle of the process for which you
wish to receive the notification. This option will resolve variables.
<P>
<TT>MACHINE</TT> specifies the machine to which the notification should
be sent.  The default is the machine submitting the request. This option will resolve variables.
<P>
<TT>PRIORITY</TT> specifies the priority of the notification message.
The default is 5. This option will resolve variables.
<P><TT>HANDLE</TT> specifies the handle to which the notification should be
sent.  The default is the handle of the process submitting the request.
This option will resolve variables.
<P>
<TT>NAME</TT> specifies the registered name of the process(es) to which
the notification should be sent. This option will resolve variables.
<BR>
<P><B><A NAME="TBLSTAFPROCESSENDTABLE">Table 69. Definition of map for "STAF/Process/End" type message</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="3" WIDTH="100%"><B>Description&#58; </B>This map represents process completion information.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">endTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">key
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">fileList
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;List&gt; of &lt;Map&gt;.</TT>  See <A HREF="#TBLPROCESSRETURNEDFILETABLE">Table 70</A> for the
map definition.
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="3" WIDTH="100%"><B>Notes&#58; </B>
The value for "fileList" will contain a list of information about the files
requested to be returned.  Files will be returned in the order of standard output,
then standard error, then any files specified with the <TT>RETURNFILE</TT>
option.  The value for "fileList" will be empty if none of the options
<TT>RETURNSTDOUT</TT>, <TT>RETURNSTDERR</TT>, or <TT>RETURNFILE</TT> were
specified when the process was started.
</TD></TR></TABLE>
<BR>
<P><B><A NAME="TBLPROCESSRETURNEDFILETABLE">Table 70. Definition of map for returned files for a process</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="3" WIDTH="100%"><B>Description&#58; </B>This map class represents a file returned by the process.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">data
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="33%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="3" WIDTH="100%"><B>Notes&#58; </B>
For each file, a standard STAF return code indicating the success or failure
of retrieving the file's contents is provided.  If the file's return code
is 0, then the data contained in the file is also provided.
If the file's return code is 58 (Maximum Size Exceeded), that indicates
that the file size exceeded the maximum return file size.
</TD></TR></TABLE>
<P>
For example, suppose a PROCESS START COMMAND "java TestA" request was
submitted by handle 43, and assume that the process completed
successfully at 20041019-17:03:48 and returned a process return code of 0.
The queued STAF/PROCESS/END message will be a map that could look like the
following: 
<PRE>
{
  handle      : 43
  endTimestamp: 20041019-17:03:48
  rc          : 0
  key         : &lt;None&gt;
  fileList    : []
}
</PRE>
<P>
For example, suppose a <TT>PROCESS START COMMAND "java TestA" KEY 10 RETURNSTDOUT
RETURNSTDERR</TT> request is submitted by handle 26 with key 10, and assume that
the process completed successfully at 20041029-09:30:16 and returned a process
return code of 3 and that the standard output of the process was simply
"Success !!!", and that the standard error of the process was blank.
The queued STAF/PROCESS/END message will be a map that could look like
the following: 
<PRE>
{
  handle      : 26
  endTimestamp: 20041029-09:30:16
  rc          : 3
  key         : 10
  fileList    : [
    {
      rc  : 0
      data: Success !!!
    }
    {
      rc  : 0
      data: 
    } 
  ]
}
</PRE>
<P>
<P><H4><A NAME="Header_621">Security</A></H4>
<P>
These commands require trust level 3.
<P>
<P><H4><A NAME="Header_622">Return Codes</A></H4>
<P>
All return codes from NOTIFY REGISTER/UNREGISTER are documented in
<A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_623">Results</A></H4>
<P>
The result buffer will contain no data on return from a NOTIFY
REGISTER/UNREGISTER command.
<P>
<P><H4><A NAME="Header_624">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Register the current process for a priority 1 notification
when the process with handle 14 ends.
<P><B>Syntax:</B>&nbsp; <TT>NOTIFY REGISTER ONENDOFHANDLE 14 PRIORITY 1</TT>
<P>
<P><LI><B>Goal:</B> Register to have a process end notification sent to all
processes with registered name ProcessHandler on machine EventController
when process with handle 43 ends.
<P><B>Syntax:</B>&nbsp; <TT>NOTIFY REGISTER ONENDOFHANDLE 43 MACHINE EventController NAME ProcessHandler</TT>
<P>
<P><LI><B>Goal:</B> Unregister the event notification for handle 43 which is to be
sent when process with handle 12 ends.
<P><B>Syntax:</B>&nbsp; <TT>NOTIFY UNREGISTER ONENDOFHANDLE 12 HANDLE 43</TT>
</UL>
<A NAME="IDX498"></A>
<P><H3><A NAME="Header_625">8.13.9 NOTIFY LIST</A></H3>
<P>NOTIFY LIST allows you to view the process end notification list for a
given process.
<P><H4><A NAME="Header_626">Syntax</A></H4>
<PRE>
NOTIFY LIST ONENDOFHANDLE &lt;Handle&gt;
</PRE>
<P><TT>ONENDOFHANDLE</TT> indicates the handle of the process for which you
wish to view the notification list. This option will resolve variables.
<P><H4><A NAME="Header_627">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_628">Return Codes</A></H4>
<P>All return codes from NOTIFY LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_629">Results</A></H4>
<P>The result buffer will contain a marshalled
<TT> &lt;List&gt; of &lt;Map&#58;STAF/Service/Process/Notifiee&gt;</TT>, 
representing the registered notifiees.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_71">Table 71. Definition of map class STAF/Service/Process/Notifiee</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a registered notifiee.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">priority
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Priority
<BR>
(P)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">notifyBy
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Notify By
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Name' | 'Handle'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">notifiee
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Notifiee
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
If the "Notify By" value is 'Name', the "Notifiee" value will be
the handle name.  Otherwise, if the "Notify By" value is 'Handle', the
"Notifiee" value will be the handle number.
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_630">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal&#58;</B> Retrieve the list of process end notifiees for the
process with handle 57.  Assume there are 3 registered notfiees for
handle 57: two registered by handle and one registered by name.
<P><B>Syntax&#58;</B>&nbsp; <TT>NOTIFY LIST ONENDOFHANDLE 57</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in table format, could look like:
<PRE>
Priority Machine                 Notify By Notifiee
-------- --------------------    --------- ---------
5        automate.austin.ibm.com Handle    48
1        dyno.austin.ibm.com     Handle    51
3        automate.austin.ibm.com Name      Web Tests
</PRE>
</UL>
<A NAME="IDX501"></A>
<P><H3><A NAME="HDRPROCESSSET">8.13.10 SET</A></H3>
The SET command allows you to change the operational parameters for the
Process service dynamically (without stopping/restarting STAF) which is
important for STAF machines that must be continuously available.
<P>
Note that to make these settings permanent (e.g. if you want these changes
to apply once STAF is stopped and restarted), you'll need to update the
STAF configuration file with these new settings.
<P>
<P><H4><A NAME="Header_632">Syntax</A></H4>
<PRE>
SET  &#91;DEFAULTSTOPUSING &lt;Method&gt;&#93; &#91;DEFAULTCONSOLE &lt;New | Same&gt;&#93;
     &#91;DEFAULTFOCUS &lt;Background | Foreground | Minimized&gt;&#93;
     &#91;PROCESSAUTHMODE &lt;Auth Mode&gt;&#93;
     &#91;DEFAULTAUTHUSERNAME &lt;User Name&gt;&#93; &#91;DEFAULTAUTHPASSWORD &lt;Password&gt;&#93;
     &#91;DEFAULTAUTHDISABLEDACTION &lt;Error | Ignore&gt;&#93; &#91;DEFAULTSHELL &lt;Shell&gt;&#93;
     &#91;DEFAULTNEWCONSOLESHELL &lt;Shell&gt;&#93; &#91;DEFAULTSAMECONSOLESHELL &lt;Shell&gt;&#93;
</PRE>
<P>See section <A HREF="#HDROPPARMS">4.7, "Operational parameters"</A> for a description of these options.
All of these options will resolve variables.
<P>Note that the <TT>DEFAULTAUTPASSWORD</TT> option will handle private data.
<P>Note that setting <TT>DEFAULTCONSOLE New</TT> is equivalent
to setting the <TT>DEFAULTNEWCONSOLE</TT> operational parameter in the
STAF configuration file.
Similarly, setting <TT>DEFAULTCONSOLE Same</TT> is equivalent to setting
the <TT>DEFAULTSAMECONSOLE</TT> operational parameter in the STAF
configuration file.
<P><H4><A NAME="Header_633">Security</A></H4>
<P>This command requires trust level 5.
<P><H4><A NAME="Header_634">Return Codes</A></H4>
<P>All return codes from <TT>SET</TT> are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_635">Results</A></H4>
<P>The result buffer will contain no data on return from a successful SET command.
<P><H4><A NAME="Header_636">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Change the default method used to stop processes
to WM_Close.
<P><B>Syntax:</B>&nbsp; <TT>SET DEFAULTSTOPUSING WM_Close</TT>
<P>
<P><LI><B>Goal:</B> Change three operational parameters for the Process service.
Change the mode by which usernames/passwords are authenticated when starting
processes to use windows-based authentication and set the username under
which processes will be started by default to User1 and set the password
with which processes will be authenticated by default to secret and using privacy
delimiters to indicate that it is private data.
<P><B>Syntax:</B>&nbsp; <TT>SET PROCESSAUTHMODE Windows
DEFAULTAUTHUSERNAME user1 DEFAULTAUTHPASSWORD !!@secret@!!</TT>
</UL>
<P>
<P>
<A NAME="IDX502"></A>
<A NAME="IDX504"></A>
<HR><H2><A NAME="HDRQUEUESRV" HREF="#ToC_637">8.14 Queue Service</A></H2>
<P><H3><A NAME="Header_638">8.14.1 Description</A></H3>
<P>The QUEUE service is one of the internal STAF services.  It provides the
following commands to manipulate the contents of a handle's queue:
<UL COMPACT>
<LI>QUEUE - Queues a message to a handle's queue
<LI>GET - Retrieves and removes element(s) from the queue of the handle
submitting the GET request to the QUEUE service
<LI>PEEK - Retrieves element(s) from the queue of the handle
submitting the PEEK request to the QUEUE service
<LI>DELETE - Deletes a set of elements from a handle's queue
<LI>LIST - Retrieves the entire contents of a handle's queue
<LI>HELP &#45; Returns syntax information
</UL>
<A NAME="IDX507"></A>
<P><H3><A NAME="Header_639">8.14.2 QUEUE</A></H3>
<P>QUEUE allows you to queue a message to a given process handle or to any
process registered with a given name.
<P><H4><A NAME="Header_640">Syntax</A></H4>
<PRE>
QUEUE MESSAGE &lt;Message&gt;
      &#91;HANDLE &lt;Handle&gt; | NAME &lt;Name&gt;&#93; &#91;PRIORITY &lt;Priority&gt;&#93; &#91;TYPE &lt;Type&gt;&#93;
</PRE>
<P><TT>MESSAGE</TT> specifies the message to be queued.
This option will not resolve variables.
<P><TT>HANDLE</TT> specifies the process handle to which the message should
be queued.  If the request is made locally, the default is the handle which
originated the request. This option will resolve variables.
<P><TT>NAME</TT> specifies the registered name of the process(es) to which
the message should be queued. This option will resolve variables.
<P><B>Note: </B>If the request is made to a remote machine then you must specify either
<TT>HANDLE</TT> or <TT>NAME</TT>.
<P><TT>PRIORITY</TT> specifies the priority of the message to be queued.  The
default is 5. This option will resolve variables.
<P><TT>TYPE</TT> specifies the type for the message to be queued.  The
default is no type. This option will resolve variables.
<P>
<P><H4><A NAME="Header_641">Security</A></H4>
<P>This command requires trust level 3.
<P><H4><A NAME="Header_642">Return Codes</A></H4>
<P>All return codes from QUEUE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>If a message is attempted to be queued to a handle whose queue already
contains the maximum number of messages allowed, the message will not be
queued to that handle and return code 28 (Queue Full) will be returned.
<P>
<P><H4><A NAME="Header_643">Results</A></H4>
<P>On successful return:
<UL>
<P><LI>If <TT>HANDLE</TT> was specified, or defaulted to, the result buffer will
contain no data upon return from the submit call.
<P><LI>If <TT>NAME</TT> was specified, the result buffer will contain the number
of processes to which the message was queued.
</UL>
<P>
<P>If unsuccessful due to attempting to queue a message to a handle whose queue
already contains the maximum number of messages allowed, the message will not
be sent to that handle's queue and return code 28 (Queue full) will be returned
and the result buffer will be set as follows:
<P>
<UL>
<P><LI>If <TT>HANDLE</TT> was specified, or defaulted to, the result buffer will
contain the number of messages the handle's queue contains.
<P>
<P><LI>If <TT>NAME</TT> was specified, the result buffer will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Queue/Error&gt;</TT>, providing more information about
the number of handles, if any, that the message was successfully queued to, and
the handles that the message could not be successfully queued to because their
queues are full.  The maps are defined as follows:
<BR>
<P><B><A NAME="Table_72">Table 72. Definition of map class STAF/Service/Queue/Error</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents error information when a
message is attempted to be sent to all handles with a specified name and at
least one handle's queue is full.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">numberQueued
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Number Queued
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">fullQueueList
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handles with Full Queues
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">&lt;List&gt; of &lt;Map&#58;STAF/Service/Queue/FullInfo&gt; 
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
The "Handles with Full Queues" value will contain a list of information
about the handles whose queues are full.
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_73">Table 73. Definition of map class STAF/Service/Queue/FullInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents error information
for a handle whose queue is full.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">queueSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Queue Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> 
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
The "Handle" value will contain the handle number of a handle whose
queue is full and the "Queue Size" value will contain the number of messages
that the handle's queue contains.
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_644">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Queue the message "Hello World" to your own handle's queue on
the local machine.
<P><B>Syntax:</B>&nbsp; <TT>QUEUE MESSAGE "Hello World"</TT>
<P>
<P><LI><B>Goal:</B> Queue priority 1 message "CONTROL/STAGE2" to handle 50.
<P><B>Syntax:</B>&nbsp; <TT>QUEUE HANDLE 50 PRIORITY 1 MESSAGE "CONTROL/STAGE2"</TT>
<P>
<P><LI><B>Goal:</B> Queue the message "Success" with type "Build/Complete" to handle 17.
<P><B>Syntax:</B>&nbsp; <TT>QUEUE HANDLE 17 TYPE "Build/Complete" MESSAGE "Success"</TT>
<P>
<P><LI><B>Goal:</B> Queue the message "Success" to all handles on machine
test1.company.com whose handle name is "MyProduct/Test".
<P><B>Syntax:</B>&nbsp;
<TT>STAF test1.company.com QUEUE QUEUE NAME "MyProduct/Test" MESSAGE "Success"</TT>
<P><B>Results</B>
<UL>
<P><LI>If one handle exists on machine test1.company.com with name "MyProduct/Test"
and the message was successfully queued to its handle, return code 0 would be
returned and the result would contain "1".
<P><LI>If three handles exist on machine test1.company.com with name "MyHandle"
and the message was successfully queued to all three handles, return code 0
would be returned and the result would contain "3".
<P><LI>If no handles exist on machine test1.company.com with name "MyHandle",
return code 5 (Handle does not exist) will be returned.
<P><LI>If one handle exists on machine test1.company.com with name "MyHandle"
and its queue is full, return code 28 (Queue full) would be returned and, if the
command was submitted via the command line, the result in verbose format could
look like:
<PRE>
{
  Number Queued           : 0
  Handles with Full Queues: [
    {
      Handle    : 37
      Queue Size: 100
    }
  ]
}
</PRE>
<P><LI>If three handles exist on machine test1.company.com with name "MyHandle"
and two of the handles' queues are full and one handle's queue is not full,
return code 28 (Queue full) would be returned and, if the command was submitted
via the command line, the result in verbose format could look like:
<PRE>
{
  Number Queued           : 1
  Handles with Full Queues: [
    {
      Handle    : 37
      Queue Size: 100
    }
    {
      Handle    : 41
      Queue Size: 100
    }
  ]
}
</PRE>
</UL>
</UL>
<A NAME="IDX510"></A>
<A NAME="IDX513"></A>
<P><H3><A NAME="Header_645">8.14.3 GET/PEEK</A></H3>
<P>GET allows you to retrieve and remove one or more elements from the queue of
the handle submitting the GET request to the QUEUE service.
<P>PEEK allows you to retrieve one or more elements from the queue of
the handle submitting the PEEK request without removing the element(s) from the queue.
<P>
By default, only one element will be retrieved/removed from the queue if you don't
specify the <TT>ALL</TT> or <TT>FIRST</TT> option.
<P>
For security reasons, you are only allowed to retrieve messages from your own
handle's queue, not from any other handle's queue.  So, a GET/PEEK request only
retrieves messages from the queue of the handle that submitted the GET/PEEK
request to the QUEUE service.  Note that you can use the LIST request to
list messages that are in another handle's queue.
<P>
<P><H4><A NAME="Header_646">Syntax</A></H4>
<PRE>
GET  &#91;PRIORITY &lt;Priority&gt;&#93;... &#91;MACHINE &lt;Endpoint&gt;&#93;... &#91;NAME &lt;Name&gt;&#93;...
     &#91;HANDLE &lt;Handle&gt;&#93;... &#91;USER &lt;User&gt;&#93;... &#91;TYPE &lt;Type&gt;&#93;...
     &#91;CONTAINS &lt;String&gt;&#93;... &#91;ICONTAINS &lt;String&gt;&#93;...
     &#91;FIRST &lt;Number&gt; | ALL&#93;
     &#91;WAIT &#91;&lt;Number&gt;[s|m|h|d|w]&#93; &#93;
 
PEEK &#91;PRIORITY &lt;Priority&gt;&#93;... &#91;MACHINE &lt;Endpoint&gt;&#93;... &#91;NAME &lt;Name&gt;&#93;...
     &#91;HANDLE &lt;Handle&gt;&#93;... &#91;USER &lt;User&gt;&#93;... &#91;TYPE &lt;Type&gt;&#93;...
     &#91;CONTAINS &lt;String&gt;&#93;... &#91;ICONTAINS &lt;String&gt;&#93;...
     &#91;FIRST &lt;Number&gt; | ALL&#93;
     &#91;WAIT &#91;&lt;Number&gt;[s|m|h|d|w]&#93; &#93;
</PRE>
<P><TT>PRIORITY</TT> specifies that you want to retrieve/remove message(s)
with the given priority. The default is the highest priority message (i.e.,
the one with the lowest priority number). You may specify this option multiple
times.  This option will resolve variables.
<P><TT>MACHINE</TT> specifies that you want to retrieve/remove message(s)
originating from the given machine's endpoint.  The default is any machine.  You may
specify this option multiple times.  This option will resolve variables.
The format for a machine's endpoint is:
<PRE>
  &lt;Interface&gt;&#58;//&lt;System Identifier&gt;&#91;@&lt;Port&gt;&#93;
</PRE>
where a case-insensitive match is performed.
You can specify match patterns (e.g. wild cards) for a machine's endpoint.
These patterns recognize two special characters, '*' and '?', where '*'
matches a string of characters (including an empty string) and '?' matches
any single character (the empty string does not match).   
For example, if you want to match on messages from a machine with system
identifier client1.mycompany.com, no matter what interface or port is in
the machine's endpoint, you could specify "*://client1.mycompany.com*"
which would match machines such as "tcp://client1.mycompany.com@6500" and
"tcp2://client1.mycompany.com".
<P><TT>NAME</TT> specifies that you want to retrieve/remove message(s)
originating from a process with the given registered name. The default is any
name. You may specify this option multiple times.  This option will resolve variables.
Note that this option does not specify the handle name for the handle whose
queue you want to retrieve messages from as you can only retrieve messages
from the queue of the handle that submitted the GET/PEEK request to the
QUEUE service.
<P><TT>HANDLE</TT> specifies that you want to retrieve/remove message(s)
originating from a process with the given handle number. The default is any handle.
You may specify this option multiple times.  This option will resolve variables.
Note that this option does not specify the handle number for the handle whose
queue you want to retrieve messages from as you can only retrieve messages
from the queue of the handle that submitted the GET/PEEK request to the
QUEUE service.
<P><TT>USER</TT> specifies that you want to retrieve/remove a message
originating from a process with a handle that has been authenticated
with the specified user.  The format for &lt;User&gt; is:
<PRE>
  &lt;Authenticator&gt;&#58;//&lt;User Identifier&gt;
</PRE>
where a case-insensitive match is performed on the &lt;Authenticator&gt; value and a
case-sensitive match is performed on the User Identifier.
The default is any user.
You may specify this option multiple times.  This option will resolve variables.
<P><TT>TYPE</TT> specifies that you want to retrieve/remove message(s)
with the given type.   The match is case insensitive.
You may specify this option multiple times.  This option will resolve variables.
<P><TT>CONTAINS</TT> specifies that you want to retrieve/remove message(s)
containing the given string.  The search is case sensitive.  The default is any
message.  You may specify this option multiple times.  This option will resolve variables.
<P><TT>ICONTAINS</TT> specifies that you want to retrieve/remove message(s)
containing the given string.  The search is case insensitive.  The default is any
message.  You may specify this option multiple times.  This option will resolve variables.
<P><TT>ALL</TT> specifies that you want to retrieve/remove all appropriate
messages that meet the specified criteria.
If you don't specify the <TT>ALL</TT> or <TT>FIRST</TT> option,
the default is to retrieve/remove one appropriate message.
<P><TT>FIRST</TT> specifies that you want to retrieve/remove the first &lt;Number&gt;
of appropriate messages that meet the specified criteria, where &lt;Number&gt;
must be an integer greater than 0.
If there are fewer appropriate messages on the queue that meet the
specified criteria than the number you specified for the <TT>FIRST</TT> option,
then fewer messages will be returned than the number you specified.
If you don't specify the <TT>ALL</TT> or <TT>FIRST</TT> option,
the default is to retrieve/remove one appropriate message.  This option will resolve variables.
<P><TT>WAIT</TT> specifies that the request should not return until an
appropriate message is available.  You may specify an optional time duration
after which the request should return.  If no time duration is specified,
the request will wait indefinitely until an appropriate message is available.
This option will resolve variables.
The time duration may be expressed in milliseconds, seconds, minutes,
hours, days, weeks, or years.  Its format is &lt;Number&gt;[s|m|h|d|w],
where &lt;Number&gt; is an integer &gt;= 0 and indicates milliseconds unless one
of the following case-insensitive suffixes is specified:
<UL COMPACT>
<LI>s (for seconds)
<LI>m (for minutes)
<LI>h (for hours)
<LI>d (for days)
<LI>w (for weeks).
</UL>
Note that the calculated timeout cannot exceed 4294967294 milliseconds.
So, the maximum values in each time category that can be specified are:
<UL COMPACT>
<LI>4294967294 (4294967294 milliseconds)
<LI>4294967s (4294967 seconds)
<LI>71582m (71582 minutes)
<LI>1193h (1193 hours)
<LI>49d (49 days)
<LI>7w (7 weeks)
</UL>
<P>
<P><H4><A NAME="Header_647">Security</A></H4>
<P>These commands are only valid with respect to the submitting process' queue
and if submitted to the local machine.
<P>
<P><H4><A NAME="Header_648">Return Codes</A></H4>
<P>All return codes from GET/PEEK are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>For example:
<UL>
<P><LI>If the queue is empty or no elements that meet the specified criteria
are in the queue, the return code will be set to 29 (No Queue Element).
<P><LI>If the request times out while the queue is empty or before an element
that meets the specified criteria is sent to the queue, the return code
will be set to 37 (Timeout).
</UL>
<P>
<P><H4><A NAME="Header_649">Results</A></H4>
<UL>
<P><LI>On successful return when you don't specify the <TT>ALL</TT> or <TT>FIRST</TT>
option, the result buffer will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Queue/Entry&gt;</TT>, representing the
appropriate first element from the queue that meets the specified criteria.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_74">Table 74. Definition of map class STAF/Service/Queue/Entry</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents an entry from the queue.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">priority
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Priority
<BR>
(P)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">timestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handleName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle Name
<BR>
(Name)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle
<BR>
(H#)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">message
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Message
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&lt;Any&gt;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR></TABLE>
<P>
For example, if a <TT>GET</TT> or <TT>PEEK</TT> request
is submitted from the command line (without the <TT>ALL</TT> or
<TT>FIRST</TT> option), the result, in default format,
could look like the following:
<PRE>
Priority   : 3
Date-Time  : 20040912-16:49:11
Machine    : tcp://client2.austin.ibm.com@6500
Handle Name: STAF_Process
Handle     : 17
User       : none://anonymous
Type       : STAF/Start
Message    : 
</PRE>
<P>
<P><LI>On successful return when you specify the <TT>ALL</TT> or <TT>FIRST</TT>
option, the result buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Queue/Entry&gt;</TT>, representing the
appropriate element(s) from the queue that meet the specified criteria.
<P>
For example, if a <TT>GET ALL</TT> or <TT>PEEK ALL</TT> request
is submitted from the comand line using a static handle and that
handle's queue contains 5 elements, the result would contain a list of
all 5 elements, and, in default format, could look like the following:
<PRE>
P Date-Time Machine       Name     H#  User             Type Message
- --------- ------------- -------- --- ---------------- ---- ------------------
5 20090324- local://local MyHandle 150 none://anonymous A    This is message #1
  15:48:55
5 20090324- local://local MyHandle 150 none://anonymous A    This is message #2
  15:48:56
5 20090324- local://local MyHandle 150 none://anonymous B    This is message #3
  15:48:59
5 20090324- local://local MyHandle 150 none://anonymous A    This is message #4
  15:49:05
5 20090324- local://local MyHandle 150 none://anonymous B    This is message #5
  15:49:11
</PRE>
<P>
For example, if a <TT>GET FIRST 3</TT> or <TT>PEEK FIRST 3</TT> request
is submitted from the comand line using a static handle and that
handle's queue contains 5 elements, the result would contain a list of the
first 3 elements, and, in default format, could look like the following:
<PRE>
P Date-Time Machine       Name     H#  User             Type Message
- --------- ------------- -------- --- ---------------- ---- ------------------
5 20090324- local://local MyHandle 150 none://anonymous A    This is message #1
  15:48:55
5 20090324- local://local MyHandle 150 none://anonymous A    This is message #2
  15:48:56
5 20090324- local://local MyHandle 150 none://anonymous B    This is message #3
  15:48:59
</PRE>
<P>
For example, if a <TT>GET TYPE B FIRST 2</TT> or <TT>PEEK TYPE B FIRST 2</TT>
request is submitted from the comand line using a static handle and that
handle's queue contains the 5 elements from the first example, the result would
contain a list of the first 2 elements with type B, and, in default format,
could look like the following:
<PRE>
P Date-Time Machine       Name     H#  User             Type Message
- --------- ------------- -------- --- ---------------- ---- ------------------
5 20090324- local://local MyHandle 150 none://anonymous B    This is message #3
  15:48:59
5 20090324- local://local MyHandle 150 none://anonymous B    This is message #5
  15:49:11
</PRE>
</UL>
<P>
<P><H4><A NAME="Header_650">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Wait for, retrieve, and remove the highest priority message
in my handle's queue.
<P><B>Syntax:</B>&nbsp; <TT>GET WAIT</TT>
<P>
<P><LI><B>Goal:</B> Wait for and retrieve, but do not remove, the highest priority
message from machine tcp://server1.company.com@6500 in my handle's queue.
<P><B>Syntax:</B>&nbsp; <TT>PEEK WAIT MACHINE "tcp://server1.company.com@6500"</TT>
<P>
<P><LI><B>Goal:</B> Wait for, retrieve, and remove the highest priority message
with type STAF/Start in my handle's queue.  Wait a maximum of 30 seconds.
<P><B>Syntax:</B>&nbsp; <TT>GET WAIT 30s TYPE STAF/Start</TT>
<P>
<P><LI><B>Goal:</B> Retrieve a priority 3 message in my handle's queue from a
machine whose endpoint contains system identifier client3.company.com (with any
interface or port as indicated by wildcard *) and registered process name JavaTest1
containing the message referenced by variable TestString.
<P><B>Syntax:</B>&nbsp; <TT>PEEK PRIORITY 3 MACHINE "*://client3.company.com*" NAME JavaTest1 CONTAINS {TestString}</TT>
<P>
<P><LI><B>Goal:</B> Wait for, retrieve, and remove the highest priority message
in my handle's queue with a type of either STAF/Start or STAF/Shutdown from
machines tcp://client1.company.com@6500 or tcp://client2.company.com@6500
<P><B>Syntax:</B>&nbsp; <TT>GET WAIT TYPE STAF/Start TYPE STAF/Shutdown MACHINE tcp://client1.company.com@6500 MACHINE tcp://client2.company.com@6500</TT>
<P>
<P><LI><B>Goal:</B> Wait for, retrieve, and remove the highest priority message
in my handle's queue containing either CONTROL or "Hi there"
<P><B>Syntax:</B>&nbsp; <TT>GET WAIT CONTAINS CONTROL CONTAINS "Hi there"</TT>
<P>
<P><LI><B>Goal:</B> Wait for, retrieve, and remove the highest priority message
in my handle's queue containing type "MyProduct/Build/Complete" and containing
the string "Version=1.2.0" from a machine whose endpoint contains system
identifier buildserver.company.com (with any interface or port as indicated by
wildcard *).  Wait a maximum of 1 minute.
<P><B>Syntax:</B>&nbsp; <TT>GET WAIT 1m TYPE "MyProduct/Build/Complete" CONTAINS "Version=1.2.0" MACHINE "*://buildserver.company.com*"</TT>
<P>
<P><LI><B>Goal:</B> Retrieve, but do not remove, all the messages in my handle's
queue.
<P><B>Syntax:</B>&nbsp; <TT>PEEK ALL</TT>
<P>
<P><LI><B>Goal:</B> Retrieve and remove all the messages in my handle's queue.
<P><B>Syntax:</B>&nbsp; <TT>GET ALL</TT>
<P>
<P><LI><B>Goal:</B> Retrieve and remove the first 5 messages in my handle's queue.
<P><B>Syntax:</B>&nbsp; <TT>GET FIRST 5 WAIT</TT>
<P>
<P><LI><B>Goal:</B> Wait for, retrieve, and remove all messages in my handle's queue.
<P><B>Syntax:</B>&nbsp; <TT>GET ALL WAIT</TT>
<P>
<P><LI><B>Goal:</B> Wait for, retrieve, and remove all messages in my handle's queue
with type "STAF/Process/Complete".
<P><B>Syntax:</B>&nbsp; <TT>GET ALL TYPE "STAF/Process/Complete" WAIT</TT>
</UL>
<A NAME="IDX516"></A>
<P><H3><A NAME="Header_651">8.14.4 DELETE</A></H3>
<P>DELETE allows you to delete a set of messages from a queue.
<P><H4><A NAME="Header_652">Syntax</A></H4>
<PRE>
DELETE &#91;PRIORITY &lt;Priority&gt;&#93;... &#91;MACHINE &lt;Endpoint&gt;&#93;... &#91;NAME &lt;Name&gt;&#93;...
       &#91;HANDLE &lt;Handle&gt;&#93;... &#91;USER &lt;User&gt;&#93;... &#91;TYPE &lt;Type&gt;&#93;...
       &#91;CONTAINS &lt;String&gt;&#93;... &#91;ICONTAINS &lt;String&gt;&#93;...
</PRE>
<P><TT>PRIORITY</TT> specifies that you want to delete messages with the
given priority. The default is any priority.  You may specify this option
multiple times. This option will resolve variables.
<P><TT>MACHINE</TT> specifies that you want to delete messages originating
from the given machine's endpoint.  The default is any machine.  You may
specify this option multiple times.  This option will resolve variables.
The format for a machine's endpoint is:
<PRE>
  &lt;Interface&gt;&#58;//&lt;System Identifier&gt;&#91;@&lt;Port&gt;&#93;
</PRE>
where a case-insensitive match is performed.
You can specify match patterns (e.g. wild cards) for a machine's endpoint.
These patterns recognize two special characters, '*' and '?', where '*'
matches a string of characters (including an empty string) and '?' matches
any single character (the empty string does not match).   
For example, if you want to match on messages from a machine with system
identifier client1.mycompany.com, no matter what interface or port is in
the machine's endpoint, you could specify "*://client1.mycompany.com*"
which would match machines such as "tcp://client1.mycompany.com@6500" and
"tcp2://client1.mycompany.com".
<P><TT>NAME</TT> specifies that you want to delete messages originating from
a process with the given registered name. The default is any name.  You may
specify this option multiple times. This option will resolve variables.
<P><TT>HANDLE</TT> specifies that you want to delete messages originating
from a process with the given handle. The default is any handle.  You may
specify this option multiple times. This option will resolve variables.
<P><TT>USER</TT> specifies that you want to delete messages originating
from a process with a handle that has been authenticated
with the specified user.  The format for &lt;User&gt; is:
<PRE>
  &lt;Authenticator&gt;&#58;//&lt;User Identifier&gt;
</PRE>
where a case-insensitive match is performed on the &lt;Authenticator&gt; value and a
case-sensitive match is performed on the &lt;User Identifier&gt; value.
The default is any user.
You may specify this option multiple times.  This option will resolve variables.
<P><TT>TYPE</TT> specifies that you want to delete messages
with the given type.  The match is case insensitive.
You may specify this option multiple times.  This option will resolve variables.
<P><TT>CONTAINS</TT> specifies that you want to delete messages containing
the given string.  The search is case sensitive.  The default is any
message.  You may specify this option multiple times.  This option will resolve variables.
<P><TT>ICONTAINS</TT> specifies that you want to delete messages containing
the given string.  The search is case insensitive.  The default is any
message.  You may specify this option multiple times.  This option will resolve variables.
<P><H4><A NAME="Header_653">Security</A></H4>
<P>This command is only valid with respect to the submitting process' queue
and if submitted to the local machine.
<P>
<P><H4><A NAME="Header_654">Return Codes</A></H4>
<P>All return codes from DELETE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_655">Results</A></H4>
<P>The result buffer will contain the number of messages deleted.
<P>
<P><H4><A NAME="Header_656">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Delete all messages from the local machine.
<P><B>Syntax:</B>&nbsp; <TT>DELETE MACHINE "local://local"</TT>
<P>
<P><LI><B>Goal:</B> Delete all priority 3 messages from processes with registered
name JavaTest1
<P><B>Syntax:</B>&nbsp; <TT>DELETE PRIORITY 3 NAME JavaTest1</TT>
<P>
<P><LI><B>Goal:</B> Delete all priority 3 and 4 messages from the machines
referenced by variables Mach1 and Mach2 containing the string Stage2 or
containing the string referenced by variable StringTest1.
<P><B>Syntax:</B>&nbsp; <TT>DELETE PRIORITY 3 PRIORITY 4 MACHINE {Mach1} MACHINE {Mach2} CONTAINS Stage2 CONTAINS {StringTest1}</TT>
<P>
<P><LI><B>Goal:</B> Delete all messages containing the string "Version=1.2.0" with
type "MyProduct/Build/Complete" from a machine whose endpoint contains
system identifier buildserver.company.com (with any interface or port
as indicated by wildcard *).
<P><B>Syntax:</B>&nbsp; <TT>DELETE TYPE "MyProduct/Build/Complete"
CONTAINS "Version=1.2.0" MACHINE "*://buildserver.company.com*"</TT>
<P>
<P><LI><B>Goal:</B> Delete all messages in the queue.
<P><B>Syntax:</B>&nbsp; <TT>DELETE</TT>
</UL>
<A NAME="IDX519"></A>
<P><H3><A NAME="Header_657">8.14.5 LIST</A></H3>
<P>LIST allows you to retrieve the contents of the queue of a given handle.
<P>
<P><H4><A NAME="Header_658">Syntax</A></H4>
<PRE>
LIST &#91;HANDLE &lt;Handle&gt;&#93;
</PRE>
<P><TT>HANDLE</TT> specifies the handle of the process for which you want
the queue contents.  The default is the handle of the submitting process.  This
option will only default if the request was submitted locally. This option will resolve variables.
<P>
<P><H4><A NAME="Header_659">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_660">Return Codes</A></H4>
<P>All return codes from LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_661">Results</A></H4>
<P>
On successful return, the result buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Queue/Entry&gt;</TT>, representing
the queued messages, sorted in ascending order by priority.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_75">Table 75. Definition of map class STAF/Service/Queue/Entry</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a queued message.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">priority
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Priority
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">timestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handleName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">message
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Message
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">&lt;Any&gt;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Private data will be masked.
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_662">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Retrieve the contents of the submitting process' queue.
<P><B>Syntax:</B>&nbsp; <TT>LIST</TT>
<P><B>Result:</B>&nbsp; If the request is submitted from the
command line, the result, in table format, could look like the following:
<PRE>
P Date-Time Machine        Name   H# User     Type       Message
- --------- -------------- ------ -- -------- ---------- ------------------------
1 20040912- tcp://client1. STAF_P 1  none://a STAF/Start 
  13:56:10  austin.ibm.com rocess    nonymous         
            @6500
3 20040912- tcp://client3. JavaTe 36 none://a FVTTest    CONTROL/STAGE2
  14:01:52  austin.ibm.com st1       nonymous
3 20040912- tcp://client2. STAF_P 1  none://a STAF/Start
  14:02:17  austin.ibm.com rocess    nonymous
            @6500
5 20040912- tcp://client3. JavaTe 36 none://a &lt;None&gt;     This is a test message f
  13:57:36  austin.ibm.com st1       nonymous            rom Test1.  Phase 2 has
            @6500                                             completed.
</PRE>
<P>
<P><LI><B>Goal:</B> Retrieve the contents of the process with handle 37.
<P><B>Syntax:</B>&nbsp; <TT>LIST HANDLE 37</TT>
<P><B>Result:</B>&nbsp; If the request is issued from the command line, the result,
in verbose format, could look like: 
<PRE>
[
  {
    Priority   : 5
    Date-Time  : 20050222-16:50:12
    Machine    : tcp://client1.austin.ibm.com@6500
    Handle Name: STAF_Process
    Handle     : 1
    User       : none://anonymous
    Type       : STAF/Process/End
    Message    : {
      endTimestamp: 20050222-16:50:12
      fileList    : []
      handle      : 30
      key         :
      rc          : 0
    }
  }
]
</PRE>
</UL>
<P>
<A NAME="IDX520"></A>
<A NAME="IDX522"></A>
<HR><H2><A NAME="HDRRESSRV" HREF="#ToC_663">8.15 Resource Pool (ResPool) Service</A></H2>
<P><H3><A NAME="Header_664">8.15.1 Description</A></H3>
The Resource Pool service is an external STAF service that
allows you to manipulate resource pools and contents of the
resource pools via the following functions.:
<UL COMPACT>
<LI>LIST    - Display a list of resource pools or the settings for the service
<LI>CREATE  - Creates a resource pool
<LI>DELETE  - Deletes a resource pool
<LI>ADD     - Adds a unique resource entry to a specified pool
<LI>REMOVE  - Removes a resource entry from a specified pool
<LI>QUERY   - Displays information about a specified pool
<LI>REQUEST - Requests exclusive access to an available resource in a
specified pool
<LI>RELEASE - Releases exclusive access from a resource entry in a specified
pool
<LI>CANCEL  - Cancels a pending request for a resource entry in a specified
pool
<LI>HELP &#45; Returns syntax information
</UL>
The purpose of the Resource Pool service is to manage exclusive access to
the entries within resource pools.  For example, if you had a group of VM
UserIDs and passwords for a particular VM system that needed to be shared
amongst numerous testcases, you could create a resource pool for them and
then testcases that required a logon to that VM system could request a UserID
and password from this resource pool, perform the test, and then release the
UserID and password back to the resource pool.
<A NAME="IDX524"></A>
<P><H3><A NAME="Header_665">8.15.2 Registration</A></H3>
The Resource Pool service is an external service and must be registered with
the SERVICE configuration statement. The syntax is:
<PRE>
SERVICE &lt;Name&gt; LIBRARY STAFPool [PARMS &lt;Parameters&gt;]
</PRE>
<P><TT>&lt;Name&gt;</TT> is the name by which the Resource Pool service will be
known on this machine.
<P><TT>&lt;Parameters&gt;</TT> are valid Resource Pool parameters
described below.
<P><H4><A NAME="Header_666">Example</A></H4>
<PRE>
service respool library STAFPool
service respool library STAFPool parms "Directory {STAF/Config/BootDrive}/STAF/ResPool"
</PRE>
<A NAME="IDX526"></A>
<P><H3><A NAME="HDRRESPOOLPARMS">8.15.3 Parameters</A></H3>
<P>The Resource Pool service accepts a parameter string in the following format:
<PRE>
&#91;DIRECTORY &lt;Resource Pool Directory Root&gt;&#93;
</PRE>
<P><TT>DIRECTORY</TT> specifies the root directory under which resource pool
files are stored.  The default is <TT>{STAF/DataDir}/service/&lt;Service Name (lower-case)&gt;</TT>.
<P><B>Note: </B>Previously, in STAF 2.x, the default root directory was
<TT>{STAF/Config/STAFRoot}/data/&lt;Service Name (lower-case)&gt;</TT>.
So, if you want to continue to use the STAF 2.x resource pools with the
current version of STAF, move the resource pool files to the new default root
directory or specify the old root directory for the <TT>DIRECTORY</TT> parameter.
<A NAME="IDX529"></A>
<P><H3><A NAME="Header_668">8.15.4 LIST</A></H3>
<P>LIST displays a list of resource pools and their descriptions.
<P><H4><A NAME="Header_669">Syntax</A></H4>
<PRE>
LIST [POOLS | SETTINGS]
</PRE>
<P><TT>POOLS</TT> indicates to list the resource pools.
This is the default.
<P><TT>SETTINGS</TT> indicates to list the operational settings for
the Resource Pool service.
<P>
<P><H4><A NAME="Header_670">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_671">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
LIST also returns the return codes documented in
<A HREF="#HDRRPRCODE">8.15.13, "Resource Pool Error Code Reference"</A>.
<P><H4><A NAME="Header_672">Results</A></H4>
<P>
<UL>
<P><LI>The result buffer for a <TT>LIST</TT> or <TT>LIST POOLS</TT> request
will contain a marshalled <TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/ResPool/Pool&gt;</TT>
representing the resource pools that have been created.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_76">Table 76. Definition of map class STAF/Service/ResPool/Pool</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a resource pool.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">poolName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Pool Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR></TABLE>
<P>
<P><LI>The result buffer for a <TT>LIST SETTINGS</TT> request
will contain a marshalled <TT>&lt;Map&#58;STAF/Service/ResPool/Settings&gt;</TT>
representing the operational settings for the service.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_77">Table 77. Definition of map class STAF/Service/ResPool/Service</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the settings for the service.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">directory
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Directory
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_673">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> List all of the resource pools
<P><B>Syntax:</B>&nbsp; <TT>LIST</TT> or <TT>LIST POOLS</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in table format, could look like:
<PRE>
Pool Name           Description
------------------- ------------------------------------------
AUSVMR              UserIDs and Passwords for VM System AUSVMR
AutoTester_Licenses License numbers for AutoTester
</PRE>
<P>
<P><LI><B>Goal:</B> List the operational settings for the RESPOOL service
<P><B>Syntax:</B>&nbsp; <TT>LIST SETTINGS</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result could look like:
<P>
<PRE>Directory: C:\STAF\data\STAF\service\respool
</PRE>
</UL>
<P>
<A NAME="IDX532"></A>
<P><H3><A NAME="HDRCREATE">8.15.5 CREATE</A></H3>
<P>Creates a resource pool.
<P><H4><A NAME="Header_675">Syntax</A></H4>
<PRE>
CREATE POOL &lt;PoolName&gt; DESCRIPTION &lt;Description&gt;
</PRE>
<P><TT>POOL</TT> specifies the name of the resource pool you want to create.  This option will resolve variables.
<P>Note that the pool name will be used in the name of a file that will be
created in the resource pool directory root, (e.g.
<TT>&lt;ResourcePoolDirectoryRoot&gt;/&lt;PoolName&gt;.rpl</TT>).
So, avoid specifying a character that the file system doesn't allow in a file
name such as the following characters:  <TT>&lt; &gt; &#58; " / \ | ? *</TT>
<P><TT>DESCRIPTION</TT> specifies the description of the resource pool.  This option will resolve variables.
<P><H4><A NAME="Header_676">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_677">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
CREATE also returns the return codes documented in
<A HREF="#HDRRPRCODE">8.15.13, "Resource Pool Error Code Reference"</A>.
<P><H4><A NAME="Header_678">Results</A></H4>
<P>The result buffer will contain no data upon return from a CREATE command.
<P><H4><A NAME="Header_679">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Create a resource pool called AUSVMR with the description
"UserIDs and Passwords for VM System AUSVMR"
<P><B>Syntax:</B>&nbsp; <TT>CREATE POOL AUSVMR DESCRIPTION "UserIDs and Passwords for VM System AUSVMR"</TT>
</UL>
<A NAME="IDX535"></A>
<P><H3><A NAME="HDRDELETE">8.15.6 DELETE</A></H3>
<P>Deletes a resource pool and all its entries.
<P><H4><A NAME="Header_681">Syntax</A></H4>
<PRE>
DELETE POOL &lt;PoolName&gt; CONFIRM &#91;FORCE&#93;
</PRE>
<P><TT>POOL</TT> specifies the name of the resource pool you want to delete.  This option will resolve variables.
<P><TT>CONFIRM</TT> confirms you really want to delete the resource pool.
<P><TT>FORCE</TT> allows you to force the deletion of the resource pool, even
if there are pending requests.  If this option is not specified, you will
receive an error if you try to delete a resource pool which has pending
requests.
<P><H4><A NAME="Header_682">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_683">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
DELETE also returns the return codes documented in
<A HREF="#HDRRPRCODE">8.15.13, "Resource Pool Error Code Reference"</A>.
<P><H4><A NAME="Header_684">Results</A></H4>
<P>The result buffer will contain no data upon return from a DELETE command.
<P><H4><A NAME="Header_685">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Delete resource pool AUSVMR, but only if there are no pending
requests
<P><B>Syntax:</B>&nbsp; <TT>DELETE POOL AUSVMR CONFIRM</TT>
<P>
<P><LI><B>Goal:</B> Delete resource pool AUSVM1, even if there are pending requests
<P><B>Syntax:</B>&nbsp; <TT>DELETE POOL AUSVM1 CONFIRM FORCE</TT>
</UL>
<A NAME="IDX538"></A>
<P><H3><A NAME="Header_686">8.15.7 ADD</A></H3>
<P>ADD allows you to add a resource entry to an existing resource pool.  You
may add multiple entries to a resource pool with a single request.  Note,
a resource pool may not contain duplicate entries.  If one or more duplicate
entries are specified with a single request, none of the entries specified are
added.
<P><H4><A NAME="Header_687">Syntax</A></H4>
<PRE>
ADD POOL &lt;PoolName&gt; ENTRY &lt;Value&gt; &#91;ENTRY &lt;Value&gt;&#93;...
</PRE>
<P><TT>POOL</TT> specifies the name of the resource pool to which you
want to add a resource entry.  This option will resolve variables.
<P><TT>ENTRY</TT> specifies the actual entry to be added to the resource
pool.
<P><H4><A NAME="Header_688">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_689">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
ADD also returns the return codes documented in
<A HREF="#HDRRPRCODE">8.15.13, "Resource Pool Error Code Reference"</A>.
<P><H4><A NAME="Header_690">Results</A></H4>
<P>The result buffer will contain no data upon return from the ADD command.
<P><H4><A NAME="Header_691">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Add the entries "User1 Password1" and "User2 Password2" to
resource pool AUSVMR
<P><B>Syntax:</B>&nbsp; <TT>ADD POOL AUSVMR ENTRY "User1 Password1" ENTRY "User2 Password2"</TT>
<P>
<P><LI><B>Goal:</B> Add entry 1047923 to resource pool AutoTester_Licenses
<P><B>Syntax:</B>&nbsp; <TT>ADD POOL AutoTester_Licenses ENTRY 1047923</TT>
</UL>
<A NAME="IDX541"></A>
<P><H3><A NAME="Header_692">8.15.8 REMOVE</A></H3>
<P>REMOVE removes a resource entry from an existing resource pool.  The
resource entry may only be removed if the resource is not in use or if the
FORCE option is specified.  Note, you may remove multiple entries from a
resource pool with a single request.  If one or more invalid entries are 
specified with a single request, none of the entries specified are removed.
<P><H4><A NAME="Header_693">Syntax</A></H4>
<PRE>
REMOVE POOL &lt;PoolName&gt; ENTRY &lt;Value&gt; &#91;ENTRY &lt;Value&gt;&#93;... CONFIRM &#91;FORCE&#93;
</PRE>
<P><TT>POOL</TT> specifies the name of the resource pool from which you
want to remove an entry.  This option will resolve variables.
<P><TT>ENTRY</TT> specifies the actual entry to be removed.
<P><TT>CONFIRM</TT> confirms you really want to remove the resource entry.
<P><TT>FORCE</TT> allows you to force the removal of a resource entry which
is currently owned.  By default, you may only remove a resource entry if it is
not currently owned.
<P><H4><A NAME="Header_694">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_695">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
REMOVE also returns the return codes documented in
<A HREF="#HDRRPRCODE">8.15.13, "Resource Pool Error Code Reference"</A>.
<P><H4><A NAME="Header_696">Results</A></H4>
<P>The result buffer will contain no data upon return from the REMOVE command.
<P><H4><A NAME="Header_697">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Remove entry "User1 Password1" from resource pool AUSVMR, but
only if the entry is not currently owned.
<P><B>Syntax:</B>&nbsp;
<TT>REMOVE POOL AUSVMR ENTRY "User1 Password1" CONFIRM</TT>
<P>
<P><LI><B>Goal:</B> Remove entries 1137849 and 1075234 from resource pool
AutoTester_Licenses regardless of whether the are currently owned
<P><B>Syntax:</B>&nbsp;
<TT>REMOVE POOL AutoTester_Licenses ENTRY 1137849 ENTRY 107523 CONFIRM FORCE</TT>
</UL>
<A NAME="IDX544"></A>
<P><H3><A NAME="HDRQUERY">8.15.9 QUERY</A></H3>
<P>Allows you to get information on a resource pool, including a list of
entries in the pool and the status of each entry, as well as a list of the
pending requests for entries in the resource pool.  The pending requests
will shown in ascending order by priority, and within the same priority
by the request timestamp.
<P><H4><A NAME="Header_699">Syntax</A></H4>
<PRE>
QUERY POOL &lt;PoolName&gt;
</PRE>
<P><TT>POOL</TT> specifies the name of the resource pool you want to query.  This option will resolve variables.
<P><H4><A NAME="Header_700">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_701">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
QUERY also returns the return codes documented in
<A HREF="#HDRRPRCODE">8.15.13, "Resource Pool Error Code Reference"</A>.
<P><H4><A NAME="Header_702">Results</A></H4>
<P>
The result buffer for a <TT>QUERY</TT> request will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/ResPool/PoolInfo&gt;</TT>, representing
information about the specified resource pool.
<P>
The maps used in representing a resource pool are defined as follows:
<BR>
<P><B><A NAME="Table_78">Table 78. Definition of map class STAF/Service/ResPool/PoolInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a resource pool.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Description
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">requestList
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Pending Requests
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/ResPool/Request&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">resourceList
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Resources
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/ResPool/Resource&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
For each pending request in the request list for the pool, information
about the priority, the requested timestamp, the requested entry
(if any), and the originator of the pending request is provided.
For each entry in the resource list for the pool, the resource entry
and owner information is provided.
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_79">Table 79. Definition of map class STAF/Service/ResPool/Request</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a pending request for a resource in a resource pool
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">priority
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Priority
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'1' - '99'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">requestedTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Date-Time Requested
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">requestedEntry
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Requested Entry
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handleName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">user
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">User
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Authenticator&gt;://&lt;User ID&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Interface&gt;://&lt;System Identifier&gt;[@&lt;Port&gt;]</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">gc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Perform Garbage Collection
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'Yes' | 'No'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL TYPE=1>
<P><LI>The "Priority" field contains the priority of the pending request.
<P><LI>The "Date-Time Requested" contains the timestamp when the pending
request was submitted.
<P><LI>The "Requested Entry" contains the specified entry if the ENTRY option
was specified to request a particular entry in a resource pool (instead of
the first or a random entry).  Otherwise, it will be <TT>&lt;None&gt;</TT>.
<P><LI>The "Machine", "Handle Name", "Handle", "User", and "Endpoint" fields
provide information about who submitted (aka originated) the request.
<P><LI>The "Perform Garbage Collection" field indicates whether or not
garbage collection will be performed when the handle that submitted the
request no longer exists.
</OL>
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_80">Table 80. Definition of map class STAF/Service/ResPool/Resource</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a resource in the pool
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">entry
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Entry
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">owner
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Owner
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;None&gt;</TT> |
<BR>
<TT>&lt;Map&#58;STAF/Service/ResPool/ResourceOwner&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
If the resource entry is not owned, the owner will be <TT>&lt;None&gt;</TT>.
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_81">Table 81. Definition of map class STAF/Service/ResPool/ResourceOwner</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a owner of a resource
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handleName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">user
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">User
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Authenticator&gt;://&lt;User ID&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Interface&gt;://&lt;System Identifier&gt;[@&lt;Port&gt;]</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">requestedTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Date-Time Requested
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">acquiredTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Date-Time Acquired
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">gc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Perform Garbage Collection
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'Yes' | 'No'</TT>
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_703">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Query resource pool AUSVMR
<P><B>Syntax:</B>&nbsp; <TT>QUERY POOL AUSVMR</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in verbose format, could look like
the following if the resource pool contained three
entries (where each entry consisted of a user id and a password)
and two of the entries were currently owned.
<PRE>
{
  Description     : UserIDs and Passwords for VM System AUSVMR
  Pending Requests: []
  Resources       : [
    {
      Entry: USER1 PASSWORD1
      Owner: {
        Machine                   : client3.austin.ibm.com
        Handle Name               : CM2_Test
        Handle                    : 19
        User                      : none://anonymous
        Endpoint                  : tcp://client3.austin.ibm.com@6500
        Date-Time Requested       : 20070430-15:58:30
        Date-Time Acquired        : 20070430-15:58:30
        Perform Garbage Collection: Yes
      }
    }
    {
      Entry: USER2 PASSWORD2
      Owner: {
        Machine                   : client1.austin.ibm.com
        Handle Name               : My Test
        Handle                    : 23
        User                      : none://anonymous
        Endpoint                  : tcp://client1.austin.ibm.com@6500
        Date-Time Requested       : 20070430-15:58:19
        Date-Time Acquired        : 20070430-15:58:19
        Perform Garbage Collection: No
      }
    }
    {
      Entry: USER3 PASSWORD3
      Owner: &lt;None&gt;
    }  
  ]
}
</PRE>
<P>
<P><LI><B>Goal:</B> Query resource pool AUSVMR
<P><B>Syntax:</B>&nbsp; <TT>QUERY POOL AUSVMR</TT>
<P><B>Results:</B>  If the request is submitted from the
command line, the result, in verbose format, could look like
the following if the resource pool contained two
entries (where each entry consisted of a user id and a password) and
all of the entries were currently owned, with three pending requests.
<PRE>
{
  Description     : UserIDs and Passwords for VM System AUSVMR
  Pending Requests: [
    {
      Priority                  : 1    
      Date-Time Requested       : 20100230-16:56:55
      Requested Entry           : USER1 PASSWORD1
      Machine                   : client1.austin.ibm.com
      Handle Name               : My Test
      Handle                    : 23
      User                      : none://anonymous
      Endpoint                  : tcp://client1.austin.ibm.com@6500
      Perform Garbage Collection: No
    }
    {
      Priority                  : 50    
      Date-Time Requested       : 20100230-16:54:58
      Requested Entry           : &lt;None&gt;
      Machine                   : client2.austin.ibm.com
      Handle Name               : User Access Test
      Handle                    : 28
      User                      : none://anonymous
      Endpoint                  : tcp://client2.austin.ibm.com@6500
      Perform Garbage Collection: Yes
    }
    {
      Priority                  : 50    
      Date-Time Requested       : 20100230-16:55:02
      Requested Entry           : &lt;None&gt;
      Machine                   : client3.austin.ibm.com
      Handle Name               : CM3_Test
      Handle                    : 21
      User                      : none://anonymous
      Endpoint                  : tcp://client3.austin.ibm.com@6500
      Perform Garbage Collection: Yes
    }
  ]
  Resources       : [
    {
      Entry: USER1 PASSWORD1
      Owner: {
        Machine                   : client3.austin.ibm.com
        Handle Name               : CM2_Test
        Handle                    : 19
        User                      : none://anonymous
        Endpoint                  : tcp://client3.austin.ibm.com@6500
        Date-Time Requested       : 20100230-15:58:30
        Date-Time Acquired        : 20100230-15:58:30
        Perform Garbage Collection: Yes
      }
    }
    {
      Entry: USER2 PASSWORD2
      Owner: {
        Machine                   : client1.austin.ibm.com
        Handle Name               : My Test
        Handle                    : 23
        User                      : none://anonymous
        Endpoint                  : tcp://client1.austin.ibm.com@6500
        Date-Time Requested       : 20100230-15:58:19
        Date-Time Acquired        : 20100230-15:58:19
        Perform Garbage Collection: No
      }
    }
  ]
}
</PRE>
</UL>
<A NAME="IDX547"></A>
<P><H3><A NAME="Header_704">8.15.10 REQUEST</A></H3>
<P>Obtains exclusive access to an entry from the resource pool.
<P>
If an entry is available that meets the specified criteria in
the request, then the entry will become owned by the STAF handle
on the machine that submitted the REQUEST POOL request to the
RESPOOL service.
If an entry is not currently available that meets the specified
criteria in the request, the request will be added to the "Pending
Requests" list in ascending order by "priority" and then by
the timestamp when the request was submitted.
<P>
<P><H4><A NAME="Header_705">Understanding how Garbage Collection effects Resource Pools</A></H4>
<P>
The STAF handle on the machine that submitted a REQUEST POOL request
to the RESPOOL service will be the "owner" of the resource pool entry.
Note that when a STAF handle that requested a resource is deleted,
STAF performs garbage collection for the handle by default, unless you
specified not to perform garbage collection when requesting a resource.
Performing garbage collection means when a handle that requested a
resource is deleted, the RESPOOL service will be notified, and it will
release any resource pool entries that handle owns and will remove any
pending requests for resources submitted by that handle. 
<P>
If you submit a REQUEST POOL request to the RESPOOL service
using the STAF command executable (e.g. from a command prompt or from a
shell script), it's important to understand that a STAF command does the
following:
<UL COMPACT>
<LI>Creates a STAF handle (if not using a static handle)
<LI>Submits the request
<LI>Deletes the STAF handle when the request completes (if not using
a static handle)
</UL>
<P>
So, when using the STAF command executable to submit a REQUEST POOL
request to the RESPOOL service, in order to retain ownership of the
resource pool entry (due to garbage collection), you either need to
specify not to perform garbage collection or you need to use a static
handle when submitting the request.
See <A HREF="#HDRRESSRVCMDEX">"Command Line Example"</A> for examples of how to do this. 
<P>
<P><H4><A NAME="Header_706">Syntax</A></H4>
<PRE>
REQUEST POOL &lt;PoolName&gt;
        &#91;FIRST | RANDOM | ENTRY &lt;Value&gt; &#91;RELEASE&#93;&#93; &#91;PRIORITY &lt;Number&gt;&#93;
        &#91;TIMEOUT &lt;Number&gt;[s|m|h|d|w]&#93; &#91;GARBAGECOLLECT &lt;Yes | No&gt;&#93;
</PRE>
<P><TT>POOL</TT> specifies the name of the resource pool from which you
are requesting a resource.  This option will resolve variables.
<P><TT>TIMEOUT</TT> specifies a timeout duration indicating the longest
you are willing to wait for a resource to become available.
If this option is not specified, the request will wait indefinitely
until a resource is available.  This option will resolve variables.
The time duration may be expressed in milliseconds, seconds, minutes,
hours, days, weeks, or years.  Its format is &lt;Number&gt;[s|m|h|d|w],
where &lt;Number&gt; is an integer &gt;= 0 and indicates milliseconds unless one
of the following case-insensitive suffixes is specified:
<UL COMPACT>
<LI>s (for seconds)
<LI>m (for minutes)
<LI>h (for hours)
<LI>d (for days)
<LI>w (for weeks).
</UL>
Note that the calculated timeout cannot exceed 4294967294 milliseconds.
So, the maximum values in each time category that can be specified are:
<UL COMPACT>
<LI>4294967294 (4294967294 milliseconds)
<LI>4294967s (4294967 seconds)
<LI>71582m (71582 minutes)
<LI>1193h (1193 hours)
<LI>49d (49 days)
<LI>7w (7 weeks)
</UL>
<P><TT>FIRST</TT> specifies that the first available entry in the resource
list should be returned.
<P><TT>RANDOM</TT> specifies that a random available entry should be
returned.  This is the default.
<P><TT>ENTRY</TT> specifies a particular entry in the resource list that
should be returned.
<P><TT>RELEASE</TT> specifies to release the entry after requesting it
(i.e. performs an atomic release and request).  This option can only be
specified when requesting an entry that is already owned by the handle
submitting the request.  This can be useful when you want to re-gain
ownership of the entry before any lesser-priority pending requests.
<P><TT>PRIORITY</TT> specifies the priority of the request.  It must be
a number from 1 to 99, where 1 indicates the highest priority.  The
default is 50.
If an entry is not currently available that meets the specified
criteria in the request, the request will be added to the "Pending
Requests" list in ascending order by "priority" and then by
the timestamp when the request was submitted.
Pending requests with priority 1 will be satisfied first if
possible, followed by pending requests with priority 2, and so on.
This option will resolve variables.
<P><TT>GARBAGECOLLECT</TT> specifies whether to perform garbage collection
when the STAF handle that requested a resource is deleted.  Valid values are
<TT>Yes</TT> and <TT>No</TT>, not case-sensitive.
The default is <TT>Yes</TT> which means that garbage collection will be
performed for the handle that requested the resource.  This option will resolve variables.
<P>
For example, if you need a resource to be owned for a long period of time and
the STAF handle that you're going to use to submit the request may not exist
for that period of time, then you must specify not to perform garbage collection
when requesting a resource.  This ensures that the resource will not be released
until a RELEASE ENTRY request for that resource pool entry is submitted.
<P>
<P><H4><A NAME="Header_707">Security</A></H4>
<P>This command requires trust level 3.
<P>
<P><H4><A NAME="Header_708">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
REQUEST also returns the return codes documented in
<A HREF="#HDRRPRCODE">8.15.13, "Resource Pool Error Code Reference"</A>.
<P>
<P><H4><A NAME="Header_709">Results</A></H4>
<P>On successful return, the result buffer will contain the entry given to the
process.
<P>
<P><H4><A NAME="Header_710">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B>  Request, and wait indefinitely for, the first available entry
from resource pool AUSVMR.
<P><B>Syntax:</B>&nbsp; <TT>REQUEST POOL AUSVMR FIRST</TT>
<P>
<P><LI><B>Goal:</B>  Request a random entry from resource pool AutoTester_Licenses.
If no entry is available within five minutes, timeout.
<P><B>Syntax:</B>&nbsp; <TT>REQUEST POOL AutoTester_Licenses TIMEOUT 5m</TT>
<P>
<P><LI><B>Goal:</B>  Request a random machine from resource pool MachinePool and
specify not to perform garbage collection because you need the resource
to be owned for a long period of time and the STAF handle you're using
to submit the request is short-lived.
<P><B>Syntax:</B>&nbsp; <TT>REQUEST POOL MachinePool GARBAGECOLLECT No</TT>
<P>
<P><LI><B>Goal:</B>  Request entry "machine1" from resource pool MachinePool and
wait indefinitely for this entry to become available.
<P><B>Syntax:</B>&nbsp; <TT>REQUEST POOL MachinePool ENTRY machine1</TT>
<P>
<P><LI><B>Goal:</B>  Request entry "machine2" from resource pool MachinePool and
wait for up to 1 hour for this entry to become available.
<P><B>Syntax:</B>&nbsp; <TT>REQUEST POOL MachinePool ENTRY machine2 TIMEOUT 1h</TT>
<P>
<P><LI><B>Goal:</B>  Request a random entry from resource pool MachinePool and
specify the highest priority so that if all resources are currently in use, your
request will be added to the "Pending Request" list at the highest priority such
that your request will be satisfied before other pending requests with lower
priority.
<P><B>Syntax:</B>&nbsp; <TT>REQUEST POOL MachinePool PRIORITY 1</TT>
<P>
<P><LI><B>Goal:</B>  Request entry "machine1" from resource pool MachinePool and
specify the lowest priority so that if the resource is currently in use, your
request will be added to the "Pending Request" list at the lowest priority such
that other pending requests with higher priority will be satisfied before your
request.
<P><B>Syntax:</B>&nbsp; <TT>REQUEST POOL MachinePool ENTRY machine1 PRIORITY 1</TT>
<P>
<P><LI><B>Goal:</B>  Let's assume that you already own entry "machine1" in
resource pool MachinePool.  Perform an atomic release and request of entry
"machine1" by specifying the RELEASE option on a REQUEST ENTRY request and
specify priority 30 such that your request will be added to the "Pending Request"
list at priority 30 before releasing entry "machine1".  This means that your
request for entry "machine1" will be satisfied before other pending requests
with a lesser priority.
<P><B>Syntax:</B>&nbsp; <TT>REQUEST POOL MachinePool ENTRY machine1 RELEASE PRIORITY 30</TT>
</UL>
<P>
<P><H4><A NAME="HDRRESSRVCMDEX">Command Line Example</A></H4>
<P>
<P>Say you had a resource pool named MachinePool that contained
two entries and you submit a REQUEST POOL request to the RESPOOL service
using the STAF command (instead of submitting the request via a Java program,
etc).  If you didn't specify not to perform garbage collection and if
you didn't use a static handle, the resource entry obtained by the
REQUEST POOL request would show up as available (Unowned) when submitting
a QUERY POOL request to the RESPOOL service because when the STAF command
deleted the handle it created to submit the REQUEST POOL request, that
triggered garbage collection to be performed.
<P>
<PRE>
C:\&gt;STAF local RESPOOL REQUEST POOL MachinePool
Response
--------
machine1
 
C:\&gt;STAF local RESPOOL QUERY POOL MachinePool
Response
--------
{
  Description     : Test Machine Pool
  Pending Requests: []
  Resources       : [
    {
      Entry: machine1
      Owner: &lt;None&gt;
    }
    {
      Entry: machine2
      Owner: &lt;None&gt;
    }
  ]
}
</PRE>
<P>
Instead, you need to specify not to perform garbage collection when submitting
the REQUEST POOL request to the RESPOOL service using the STAF command.
Here's an example shown using the STAF command from a Windows
command prompt:
<P>
<PRE>
C:\&gt;STAF local RESPOOL REQUEST POOL MachinePool GARBAGECOLLECT No
Response
--------
machine1
 
C:\&gt;STAF local RESPOOL QUERY POOL MachinePool
Response
--------
{
  Description     : Test Machine Pool
  Pending Requests: []
  Resources       : [
    {
      Entry: machine1
      Owner: {
        Machine                   : client1.company.com
        Handle Name               : STAF/Client
        Handle                    : 49
        User                      : none://anonymous
        Endpoint                  : local://local
        Date-Time Requested       : 20070430-14:11:18
        Date-Time Acquired        : 20070430-14:11:18
        Perform Garbage Collection: Yes
      }
    }
    {
      Entry: machine2
      Owner: &lt;None&gt;
    }
  ]
}
</PRE>
<P>
Or, you need to first create a static handle and set environment
variable STAF_STATIC_HANDLE to the static handle's number before 
submitting a REQUEST POOL request to the RESPOOL service using the
STAF command so that the static handle can retain ownership of the
resource entry until it releases the entry (or until you delete the
static handle).  See <A HREF="#HDRSTAFSHS">"Using the STAF command from shell-scripts"</A> for more information on
special environment variable STAF_STATIC_HANDLE.
Here's an example shown using the STAF command from a Windows
command prompt:
<PRE>
C:\&gt;STAF local HANDLE CREATE HANDLE NAME ResourcePoolHandle
Response
--------
51
 
C:\&gt;set STAF_STATIC_HANDLE=51
 
C:\&gt;STAF local RESPOOL REQUEST POOL MachinePool
Response
--------
machine1
 
C:\&gt;STAF local RESPOOL QUERY POOL MachinePool
Response
--------
{
  Description     : Test Machine Pool
  Pending Requests: []
  Resources       : [
    {
      Entry: machine1
      Owner: {
        Machine                   : client1.company.com
        Handle Name               : ResourcePoolHandle
        Handle                    : 51
        User                      : none://anonymous
        Endpoint                  : local://local
        Date-Time Requested       : 20070430-14:15:18
        Date-Time Acquired        : 20070430-14:15:18
        Perform Garbage Collection: Yes
      }
    }
    {
      Entry: machine2
      Owner: &lt;None&gt;
    }
  ]
}  
</PRE>
<P>
<A NAME="IDX550"></A>
<P><H3><A NAME="Header_712">8.15.11 RELEASE</A></H3>
<P>RELEASE allows you to release exclusive access of a resource entry in a
resource pool.
<P><H4><A NAME="Header_713">Syntax</A></H4>
<PRE>
RELEASE POOL &lt;PoolName&gt; ENTRY &lt;Value&gt; &#91;FORCE&#93;
</PRE>
<P><TT>POOL</TT> specifies the name of the resource pool to which you are
releasing exclusive access of an entry.  This option will resolve variables.
<P><TT>ENTRY</TT> specifies the actual entry to which you are releasing
exclusive access.
<P><TT>FORCE</TT> allows you to force the release of the resource entry.
By default, only the owner of the resource entry (e.g. the handle on
the machine that submitted the <TT>REQUEST POOL</TT> request) may
<TT>RELEASE</TT> the entry.
<P>
<P><H4><A NAME="Header_714">Security</A></H4>
<P>Command <TT>RELEASE</TT> requires trust level 3.
<P>Command <TT>RELEASE FORCE</TT> requires trust level 4.
<P>
<P><H4><A NAME="Header_715">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
RELEASE also returns the return codes documented in
<A HREF="#HDRRPRCODE">8.15.13, "Resource Pool Error Code Reference"</A>.
<P>
<P><H4><A NAME="Header_716">Results</A></H4>
<P>The result buffer will contain no data upon return from the RELEASE
command.
<P>
<P><H4><A NAME="Header_717">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Release exclusive access of entry "User2 Password2" to resource
pool AUSVMR
<P><B>Syntax:</B>&nbsp; <TT>RELEASE POOL AUSVMR ENTRY "User2 Password2"</TT>
<P>
<P><LI><B>Goal:</B>  Force the release of entry 1137849 which is a member of resource
pool AutoTester_Licenses.
<P><B>Syntax:</B>&nbsp; <TT>RELEASE POOL AutoTester_Licenses ENTRY 1137849 FORCE</TT>
</UL>
<A NAME="IDX553"></A>
<P><H3><A NAME="Header_718">8.15.12 CANCEL</A></H3>
<P>Cancels a pending request for a resource pool entry.
By default, it cancels the last pending request in the Pending
Requests list (which is sorted in ascending order by priority, and
then by the request timestamp) that was submitted by the same
handle/machine submitting the CANCEL request.  You may specify
additional selection criteria (such as machine, handle number or
name, entry, priority, or first) to specify to cancel a different
pending request.
<P>
<P><H4><A NAME="Header_719">Syntax</A></H4>
<PRE>
CANCEL POOL &lt;PoolName&gt;
       &#91;FORCE &#91;MACHINE &lt;Machine&gt;&#93; &#91;HANDLE &lt;Handle #&gt; | NAME &lt;Handle Name&gt;&#93;&#93;
       &#91;ENTRY &lt;Value&gt;&#93; &#91;PRIORITY &lt;Number&gt;&#93; &#91;FIRST | LAST&#93;
</PRE>
<P>
<TT>POOL</TT> specifies the name of the resource pool from which you
want to cancel a request in its Pending Requests list.  This option will resolve variables.
<P>
<TT>FORCE</TT> allows you to force cancelling the pending request.
By default, only the requester (e.g. the handle on the machine
that submitted the REQUEST POOL request) may CANCEL the pending
request unless the <TT>FORCE</TT> option is specified, along with
the <TT>MACHINE</TT> and/or <TT>HANDLE</TT>/<TT>NAME</TT> options.
<P>
<TT>MACHINE</TT> specifies the machine that submitted a
request in the Pending Requests list that you want to cancel.
If not specified, it defaults to the machine submitting the
CANCEL request.  This option will resolve variables.
<P>
<TT>HANDLE</TT> specifies the handle number that submitted
a request in the Pending Requests list that you want to cancel.
If not specified, it defaults to the number of the handle
submitting the CANCEL request.  This option will resolve variables.
<P>
<TT>NAME</TT> specifies the name of a handle that submitted
a request in the Pending Requests list that you want to cancel.
If not specified, it defaults to the name of the handle
submitting the CANCEL request.  This option will resolve variables.
<P>
<TT>ENTRY</TT> specifies a resource entry that matches the
"Requested Entry" field in the Pending Requests list for the
request that you want to cancel.  It can be specified only
if a particular resource entry was specified by the REQUEST
request that you want to cancel.
<P>
<TT>PRIORITY</TT> specifies the priority of the request you
want to cancel.  It must be a number from 1 to 99, where 1
indicates the highest priority.  This option will resolve variables.
<P>
<TT>FIRST</TT> specifies to cancel the first entry in the Pending
Requests list (which is sorted in ascending order by priority and
then by the request timestamp) that matches the selection criteria.
<P>
<TT>LAST</TT> specifies to cancel the last entry in the Pending
Requests list (which is sorted in ascending order by priority and
then by the request timestamp) that matches the selection criteria.
This is the default.
<P>
<P><H4><A NAME="Header_720">Security</A></H4>
<P>Command CANCEL requires trust level 3.
<P>Command CANCEL FORCE requires trust level 4 if you are not
the requester (e.g. the handle on the machine that submitted
the REQUEST POOL request that you are trying to cancel).
<P>
<P><H4><A NAME="Header_721">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
CANCEL also returns the return codes documented in
<A HREF="#HDRRPRCODE">8.15.13, "Resource Pool Error Code Reference"</A>.
<P>
<P><H4><A NAME="Header_722">Results</A></H4>
<P>On successful return, the result buffer will contain no data.
<P>
<P><H4><A NAME="Header_723">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B>  Cancel the last pending request in the
Pending Requests list for resource pool "TestMachines" that was
submitted by my handle.
<P><B>Syntax:</B>&nbsp; <TT>CANCEL POOL TestMachines</TT>
<P>
<P><LI><B>Goal:</B>  Cancel the first pending request in the
Pending Requests list for resource pool "TestMachines" that was
submitted by a handle named "STAX/Job/3" on my machine.
<P><B>Syntax:</B>&nbsp; <TT>CANCEL POOL TestMachines FORCE NAME STAX/Job/3 FIRST</TT>
<P>
<P><LI><B>Goal:</B>  Cancel the last pending request in the
Pending Requests list for resource pool "TestMachine" with
priority 30 and with requested entry "system1" that was
submitted by handle number 43 on machine "client1.company.com".
<P><B>Syntax:</B>&nbsp; <TT>CANCEL POOL MachinePool FORCE MACHINE client1.company.com HANDLE 43 ENTRY system1 PRIORITY 30</TT>
</UL>
<A NAME="IDX555"></A>
<P><H3><A NAME="HDRRPRCODE">8.15.13 Resource Pool Error Code Reference</A></H3>
<P>In addition to STAF return codes (see <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A> for additional
information), the following Resource Pool return codes are defined:
<BR>
<P><B><A NAME="TBLRPERR">Table 82. Resource Pool Service Return Codes</A></B><BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">Error Code
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Meaning
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Comment
</TH></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4005</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Not entry owner
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You are not the owner of the entry you are trying to RELEASE.  Use the
FORCE option if you are sure that the correct entry is specified.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4006</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Pool has pending requests
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">The resource pool you are trying to DELETE has pending requests.  If
necessary, use the FORCE option.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4007</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">No entries available
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">The resource pool has no entries.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4008</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Create pool path error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">The directory specified by the <TT>DIRECTORY</TT> parameter when 
registering the service or the default directory could not be created.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4009</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid pool file format
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">An error occurred reading the resource pool file due to an error in the
file format.  If you are using the latest version of the Resource Pool
service, contact the STAF authors.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4010</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Entry is owned
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">A resource pool entry you specified to REMOVE is owned.  Use the
FORCE option if you are sure that the correct entry is specified.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4011</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Not pending requester
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You cannot cancel a pending request your handle did not submit
unless you specify the FORCE option.
</TD></TR></TABLE>
<P>
<A NAME="IDX556"></A>
<A NAME="IDX558"></A>
<HR><H2><A NAME="HDRSEMSRV" HREF="#ToC_725">8.16 Semaphore (SEM) Service</A></H2>
<P><H3><A NAME="Header_726">8.16.1 Description</A></H3>
<P>The SEM service is one of the internal STAF services that allows you
to manipulate and manage two kinds of semaphores:
<UL>
<P><LI>A <B>mutex</B> semaphore allows you to synchronize access to a
particular resource.  You may request exclusive access of the semaphore,
release exclusive access of the semaphore, cancel a pending request for
the semaphore, query the semaphore, and delete the semaphore.
<P>
<P><LI>An <B>event</B> semaphore is a signaling mechanism used to
synchronize two or more tasks.  You may post an event semaphore to
signal that the event has happened, reset an event semaphore in
preparation for the next event, pulse the event semaphore (which
performs an atomic post and reset on the semaphore), wait on an event
semaphore, delete an event semaphore, and query an event semaphore.
</UL>
<P>
The SEM service provides the following commands:
<UL COMPACT>
<LI>REQUEST - Request exclusive access of a mutex semaphore
<LI>RELEASE - Release exclusive access of a mutex semaphore
<LI>CANCEL - Cancel a pending request for a mutex semaphore
<LI>POST - Post an event semaphore to signal that the event has happened
<LI>RESET - Reset an event semaphore in preparation for the next event
<LI>PULSE - Pulse an event semaphore which performs an atomic post and reset
on the semaphore
<LI>WAIT - Wait on an event semaphore
<LI>DELETE - Delete a mutex or event semaphore
<LI>QUERY - Query a mutex or event semaphore
<LI>LIST - Display a list of mutex or event semaphores
<LI>HELP &#45; Returns syntax information
</UL>
<A NAME="IDX561"></A>
<P><H3><A NAME="Header_727">8.16.2 REQUEST</A></H3>
<P>REQUEST allows you to request exclusive access of a mutex semaphore.
Your request is blocked until all prior pending <TT>REQUEST</TT>s
have been <TT>RELEASE</TT>d.  You may specify a timeout, in milliseconds,
indicating the longest you are willing to wait to gain access to the semaphore.
If no timeout is specified, the request will block indefinitely. The semaphore
is created if it does not exist.
<P>
<P><H4><A NAME="Header_728">Understanding how Garbage Collection effects Mutex Semaphores</A></H4>
<P>
The STAF handle on the machine that submitted the REQUEST MUTEX
request to the SEM service will be the "owner" of the mutex semaphore.
Note that when a STAF handle that requested a mutex semaphore is deleted,
STAF performs garbage collection for the handle by default, unless you
specified not to perform garbage collection when requesting a mutex semaphore.
Performing garbage collection means when a handle that requested a
mutex semaphore is deleted, the SEM service will be notified, and it will
release any mutex semaphores that handle owns and will remove any
pending requests for mutex semaphores submitted by the handle. 
<P>
If you submit a REQUEST MUTEX request to the SEM service
using the STAF command executable (e.g. from a command prompt or from
a shell script), it's important to understand that a STAF command
does the following:
<UL COMPACT>
<LI>Creates a STAF handle (if not using a static handle)
<LI>Submits the request
<LI>Deletes the STAF handle when the request completes (if not using
a static handle)
</UL>
So, when using the STAF command executable to submit a REQUEST MUTEX
request to the SEM service, in order to retain ownership of the
mutex semaphore (due to garbage collection), you either need to
specify not to perform garbage collection or you need to use a static
handle when submitting the request.
See <A HREF="#HDRSEMSRVCMDEX">"Command Line Example"</A> for examples of how to do this. 
<P>
<P><H4><A NAME="Header_729">Syntax</A></H4>
<PRE>
REQUEST MUTEX &lt;Name&gt; &#91;TIMEOUT &lt;Number&gt;[s|m|h|d|w]&#93; &#91;GARBAGECOLLECT &lt;Yes | No&gt;&#93;
</PRE>
<P><TT>MUTEX</TT> specifies the name of the mutex semaphore which you
want to request.  The semaphore is created if it does not exist.  This option will resolve variables.
<P><TT>TIMEOUT</TT> specifies a timeout duration indicating the longest
you are willing to wait to gain access to the semaphore.
If this option is not specified, the request will wait indefinitely until
the semaphore is available.  This option will resolve variables.
The time duration may be expressed in milliseconds, seconds, minutes,
hours, days, weeks, or years.  Its format is &lt;Number&gt;[s|m|h|d|w],
where &lt;Number&gt; is an integer &gt;= 0 and indicates milliseconds unless one
of the following case-insensitive suffixes is specified:
<UL COMPACT>
<LI>s (for seconds)
<LI>m (for minutes)
<LI>h (for hours)
<LI>d (for days)
<LI>w (for weeks).
</UL>
Note that the calculated timeout cannot exceed 4294967294 milliseconds.
So, the maximum values in each time category that can be specified are:
<UL COMPACT>
<LI>4294967294 (4294967294 milliseconds)
<LI>4294967s (4294967 seconds)
<LI>71582m (71582 minutes)
<LI>1193h (1193 hours)
<LI>49d (49 days)
<LI>7w (7 weeks)
</UL>
<P><TT>GARBAGECOLLECT</TT> specifies whether to perform garbage collection
when the STAF handle that requested a mutex semaphore is deleted.
Valid values are <TT>Yes</TT> and <TT>No</TT>, not case-sensitive.
The default is <TT>Yes</TT> which means that garbage collection will be
performed for the handle that requested the mutex semaphore.  This option will resolve variables.
<P>
For example, if you need a mutex semaphore to be owned for a long period of time
and the STAF handle that you're going to use to submit the request may not exist
for that period of time, then you must specify not to perform garbage collection
when requesting a mutex semaphore.  This ensures that the mutex semaphore will
not be released until a RELEASE MUTEX request for that semaphore is submitted.
<P>
<P><H4><A NAME="Header_730">Security</A></H4>
<P>This command requires trust level 3.
<P>
<P><H4><A NAME="Header_731">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_732">Results</A></H4>
<P>The result buffer will contain no data on a successful return from a
REQUEST command.
<P>
<P><H4><A NAME="Header_733">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B>&nbsp; Request exclusive access to mutex semaphore
Printers/Printer1.
<P><B>Syntax:</B>&nbsp; <TT>REQUEST MUTEX Printers/Printer1</TT>
<P>
<P><LI><B>Goal:</B>&nbsp; Request exclusive access to mutex semaphore
DataSource1, but only wait for up to 30 seconds.
<P><B>Syntax:</B>&nbsp; <TT>REQUEST MUTEX DataSource1 TIMEOUT 30s</TT>
<P>
<P><LI><B>Goal:</B>  Request exclusive access to mutex semaphore
Tests/LongLivedSem and specify not to perform garbage collection because
you need the mutex semaphore to be owned for a long period of time and
the STAF handle you're using to submit the request is short-lived.
<P><B>Syntax:</B>&nbsp; <TT>REQUEST MUTEX Tests/LongLivedSem GARBAGECOLLECT No</TT>
</UL>
<P>
<P><H4><A NAME="HDRSEMSRVCMDEX">Command Line Example</A></H4>
<P>
<P>Say you submitted a REQUEST MUTEX request to the SEM service
using the STAF command (instead of submitting the request via a Java program,
etc).  If you didn't specify not to perform garbage collection and if you
didn't use a static handle, the mutex semaphore would show up
as available (Unowned) when submitting a QUERY MUTEX request to the
SEM service because when the STAF command deleted the handle it created to
submit the REQUEST MUTEX request, that triggered garbage collection to be
performed.
<P>
<PRE>
C:\&gt;STAF local SEM REQUEST MUTEX Mutex1
Response
--------
 
 
C:\&gt;STAF local SEM QUERY MUTEX Mutex1
Response
--------
{
  State           : Unowned
  Owner           : &lt;None&gt;
  Pending Requests: []
}
</PRE>
<P>
Instead, you need to specify not to perform garbage collection when submitting
the REQUEST MUTEX request to the SEM service using the STAF command.
Here's an example shown using the STAF command from a Windows
command prompt:
<P>
<PRE>
C:\&gt;STAF local SEM REQUEST MUTEX Mutex1 GARBAGECOLLECT No
Response
--------
 
C:\&gt;STAF local SEM QUERY MUTEX Mutex1
Response
--------
{
  State           : Owned
  Owner           : {
    Machine                   : client1.company.com
    Handle Name               : STAF/Client
    Handle                    : 80
    User                      : none://anonymous
    Endpoint                  : local://local
    Date-Time Requested       : 20070430-15:31:24
    Date-Time Acquired        : 20070430-15:31:24
    Perform Garbage Collection: No
  }
  Pending Requests: []
}
</PRE>
<P>
Or, you need to first create a static handle and set environment
variable STAF_STATIC_HANDLE to the static handle's number before 
submitting a REQUEST MUTEX request to the SEM service using the
STAF command so that the static handle can retain ownership of the
mutex semaphore until it releases the mutex semaphore (or until you
delete the static handle).  See <A HREF="#HDRSTAFSHS">"Using the STAF command from shell-scripts"</A> for more
information on special environment variable STAF_STATIC_HANDLE.
Here's an example shown using the STAF command from a Windows
command prompt:
<PRE>
C:\&gt;STAF local HANDLE CREATE HANDLE NAME MyHandle
Response
--------
82
 
C:\&gt;set STAF_STATIC_HANDLE=82
 
C:\&gt;STAF local SEM REQUEST MUTEX Mutex1
Response
--------
 
 
C:\&gt;STAF local SEM QUERY MUTEX Mutex1
Response
--------
{
  State           : Owned
  Owner           : {
    Machine                   : client1.company.com
    Handle Name               : MyHandle
    Handle                    : 82
    User                      : none://anonymous
    Endpoint                  : local://local
    Date-Time Requested       : 20070430-15:32:34
    Date-Time Acquired        : 20070430-15:32:34
    Perform Garbage Collection: Yes
  }
  Pending Requests: []
}
</PRE>
<A NAME="IDX564"></A>
<P><H3><A NAME="Header_735">8.16.3 RELEASE</A></H3>
<P>RELEASE allows you to release exclusive access to a mutex semaphore.
Normally, only the owning handle may release the mutex semaphore.
Specifying <TT>FORCE</TT> allows you to force the release of the semaphore.
<P><B>Note: </B>Any thread in the owning handle's process may <TT>RELEASE</TT> the semaphore.
This is in contrast to other semaphore systems, where only the
<TT>REQUEST</TT>ing thread may release the semaphore.
<P>
<P><H4><A NAME="Header_736">Syntax</A></H4>
<PRE>
RELEASE MUTEX &lt;Name&gt; &#91;FORCE&#93;
</PRE>
<P><TT>MUTEX</TT> specifies the name of the mutex semaphore which you
want to release.  This option will resolve variables.
<P><TT>FORCE</TT> allows you to force the release of the semaphore even
if you are not the owner.
<P>
<P><H4><A NAME="Header_737">Security</A></H4>
<P>This command requires trust level 3.
<P><B>Note: </B>If the <TT>FORCE</TT> option is specified, trust level 4 is required.
<P>
<P><H4><A NAME="Header_738">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_739">Results</A></H4>
<P>The result buffer will contain no data on a successful return from a
RELEASE command.
<P>
<P><H4><A NAME="Header_740">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B>&nbsp; Release exclusive access to mutex semaphore
Printers/Printer1.
<P><B>Syntax:</B>&nbsp; <TT>RELEASE MUTEX Printers/Printer1</TT>
<P>
<P><LI><B>Goal:</B>&nbsp; Force the release of exclusive access to
mutex semaphore TestABC.
<P><B>Syntax:</B>&nbsp; <TT>RELEASE MUTEX TestABC FORCE</TT>
</UL>
<P>
<A NAME="IDX567"></A>
<P><H3><A NAME="Header_741">8.16.4 CANCEL</A></H3>
<P>CANCEL allows you to cancel a pending request for a mutex semaphore.
By default, it cancels the last pending request in the Pending Requests
list (which is sorted in ascending order by the request timestamp) that
was submitted by the same handle/machine submitting the CANCEL request.
You may specify additional selection criteria (such as machine, handle
number or name, or first) to specify to cancel a different pending request.
<P>
<P><H4><A NAME="Header_742">Syntax</A></H4>
<PRE>
CANCEL MUTEX &lt;Name&gt;
       &#91;FORCE &#91;MACHINE &lt;Machine&gt;&#93; &#91;HANDLE &lt;Handle #&gt; | NAME &lt;Handle Name&gt;&#93;&#93;
       &#91;FIRST | LAST&#93;
</PRE>
<P>
<TT>MUTEX</TT> specifies the name of the mutex semaphore for which you
want to cancel a request in its Pending Requests list.  This option will resolve variables.
<P>
<TT>FORCE</TT> allows you to force canceling the pending request for
the semaphore.  By default, only the requester (e.g. the handle on the
machine that submitted the REQUEST MUTEX request) may CANCEL the pending
request unless the <TT>FORCE</TT> option is specified, along with the
<TT>MACHINE</TT> and/or <TT>HANDLE</TT>/<TT>NAME</TT> options.
<P>
<TT>MACHINE</TT> specifies the machine that submitted a
request in the Pending Requests list that you want to cancel.
If not specified, it defaults to the machine submitting the
CANCEL request.  This option will resolve variables.
<P>
<TT>HANDLE</TT> specifies the handle number that submitted
a request in the Pending Requests list that you want to cancel.
If not specified, it defaults to the number of the handle
submitting the CANCEL request.  This option will resolve variables.
<P>
<TT>NAME</TT> specifies the name of a handle that submitted
a request in the Pending Requests list that you want to cancel.
If not specified, it defaults to the name of the handle
submitting the CANCEL request.  This option will resolve variables.
<P>
<TT>FIRST</TT> specifies to cancel the first entry in the Pending
Requests list (which is sorted in ascending order by the request
timestamp) that matches the selection criteria.
<P>
<TT>LAST</TT> specifies to cancel the last entry in the Pending
Requests list (which is sorted in ascending order by the request
timestamp) that matches the selection criteria. This is the default.
<P>
<P><H4><A NAME="Header_743">Security</A></H4>
<P>Command CANCEL requires trust level 3.
<P>Command CANCEL FORCE requires trust level 4 if you are not
the requester (e.g. the handle on the machine that submitted
the REQUEST MUTEX request that you are trying to cancel).
<P>
<P><H4><A NAME="Header_744">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_745">Results</A></H4>
<P>On successful return, the result buffer will contain no data.
<P>
<P><H4><A NAME="Header_746">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B>&nbsp; Cancel the last pending request in the
Pending Requests list for mutex semaphore "Printers/Printer1" that
was submitted by my handle.
<P><B>Syntax:</B>&nbsp;
<TT>CANCEL MUTEX Printers/Printer1</TT>
<BR>
or
<BR>
<TT>CANCEL MUTEX Printers/Printer1 LAST</TT>
<P>
<P><LI><B>Goal:</B>&nbsp; Force canceling the first pending request
in the Pending Requests list for mutex semaphore "Mutex1" that was
submitted by a handle named "STAX/Job/3" on my machine.
<P><B>Syntax:</B>&nbsp;
<TT>CANCEL MUTEX Mutex1 FORCE NAME STAX/Job/3 FIRST</TT>
<P>
<P><LI><B>Goal:</B>&nbsp; Force canceling the last pending request
in the Pending Requests list for mutex semaphore "Mutex1" that was
submitted by handle number 43 on machine client1.company.com.
<P><B>Syntax:</B>&nbsp;
 <TT>CANCEL MUTEX Mutex1 FORCE MACHINE client1.company.com HANDLE 43</TT>
</UL>
<P>
<A NAME="IDX570"></A>
<P><H3><A NAME="Header_747">8.16.5 POST</A></H3>
<P>POST allows you to post an event semaphore to signal that an event
has happened.  It is valid to post an event semaphore that is already
posted.
<P>
<P><H4><A NAME="Header_748">Syntax</A></H4>
<PRE>
POST EVENT &lt;Name&gt;
</PRE>
<P><TT>EVENT</TT> specifies the name of the event semaphore which you
want to post.  The semaphore is created if it does not exist.  This option will resolve variables.
<P>
<P><H4><A NAME="Header_749">Security</A></H4>
<P>This command requires trust level 3.
<P>
<P><H4><A NAME="Header_750">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_751">Results</A></H4>
<P>The result buffer will contain no data on a successful return from a
POST command.
<P>
<P><H4><A NAME="Header_752">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B>&nbsp; Post event semaphore Server1/LAN_Started.
<P><B>Syntax:</B>&nbsp; <TT>POST EVENT Server1/LAN_Started</TT>
</UL>
<P>
<A NAME="IDX573"></A>
<P><H3><A NAME="Header_753">8.16.6 RESET</A></H3>
<P>RESET allows you to reset an event semaphore in preparation for the
next event.  It is valid to reset an event semaphore that is already
reset.
<P>
<P><H4><A NAME="Header_754">Syntax</A></H4>
<PRE>
RESET EVENT &lt;Name&gt;
</PRE>
<P><TT>EVENT</TT> specifies the name of the event semaphore which you
want to post.  The semaphore is created if it does not exist.  This option will resolve variables.
<P>
<P><H4><A NAME="Header_755">Security</A></H4>
<P>This command requires trust level 3.
<P>
<P><H4><A NAME="Header_756">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_757">Results</A></H4>
<P>The result buffer will contain no data on a successful return from a
RESET command.
<P>
<P><H4><A NAME="Header_758">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B>&nbsp; Reset event semaphore Coffee/Ready.
<P><B>Syntax:</B>&nbsp; <TT>RESET EVENT Coffee/Ready</TT>
</UL>
<P>
<A NAME="IDX576"></A>
<P><H3><A NAME="Header_759">8.16.7 PULSE</A></H3>
<P>
<P>PULSE allows you to post and then reset an event semaphore as a
single atomic action.  It is valid to pulse a semaphore regardless
of whether it is currently posted or reset.  The semaphore will be
in the reset state after the pulse.
<P>
<P><H4><A NAME="Header_760">Syntax</A></H4>
<PRE>
PULSE EVENT &lt;Name&gt;
</PRE>
<P><TT>EVENT</TT> specifies the name of the event semaphore which you
want to pulse.  The semaphore is created if it does not exist.  This option will resolve variables.
<P>
<P><H4><A NAME="Header_761">Security</A></H4>
<P>This command requires trust level 3.
<P>
<P><H4><A NAME="Header_762">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_763">Results</A></H4>
<P>The result buffer will contain no data on a successful return from a
PULSE command.
<P>
<P><H4><A NAME="Header_764">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B>&nbsp; Pulse event semaphore Race/StartLap.
<P><B>Syntax:</B>&nbsp; <TT>PULSE EVENT Race/StartLap</TT>
</UL>
<P>
<A NAME="IDX579"></A>
<P><H3><A NAME="Header_765">8.16.8 WAIT</A></H3>
<P>
<P>WAIT allows you to wait for an event semaphore.  You may specify a
timeout, in milliseconds, indicating the longest you are willing to
wait for an event semaphore.  If no timeout is specified, the
request will block indefinitely.
<P>
<P><H4><A NAME="Header_766">Syntax</A></H4>
<PRE>
WAIT EVENT &lt;Name&gt; &#91;TIMEOUT &lt;Number&gt;[s|m|h|d|w]&#93;
</PRE>
<P><TT>EVENT</TT> specifies the name of the event semaphore which you
want to wait for.  The semaphore is created if it does not exist.  This option will resolve variables.
<P><TT>TIMEOUT</TT> specifies a timeout duration indicating the longest
you are willing to wait for the semaphore.
If this option is not specified, the request will wait indefinitely for
the semaphore.  This option will resolve variables.
The time duration may be expressed in milliseconds, seconds, minutes,
hours, days, weeks, or years.  Its format is &lt;Number&gt;[s|m|h|d|w],
where &lt;Number&gt; is an integer &gt;= 0 and indicates milliseconds unless one
of the following case-insensitive suffixes is specified:
<UL COMPACT>
<LI>s (for seconds)
<LI>m (for minutes)
<LI>h (for hours)
<LI>d (for days)
<LI>w (for weeks).
</UL>
Note that the calculated timeout cannot exceed 4294967294 milliseconds.
So, the maximum values in each time category that can be specified are:
<UL COMPACT>
<LI>4294967294 (4294967294 milliseconds)
<LI>4294967s (4294967 seconds)
<LI>71582m (71582 minutes)
<LI>1193h (1193 hours)
<LI>49d (49 days)
<LI>7w (7 weeks)
</UL>
<P>
<P><H4><A NAME="Header_767">Security</A></H4>
<P>This command requires trust level 3.
<P>
<P><H4><A NAME="Header_768">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_769">Results</A></H4>
<P>The result buffer will contain no data on a successful return from a
WAIT command.
<P>
<P><H4><A NAME="Header_770">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B>&nbsp; Wait for event semaphore Server1/LAN_Started.
<P><B>Syntax:</B>&nbsp; <TT>WAIT EVENT Server1/LAN_Started</TT>
<P>
<P><LI><B>Goal:</B>&nbsp; Wait a maximum of 20 seconds for event
semaphore Coffee/Ready.
<P><B>Syntax:</B>&nbsp; <TT>WAIT EVENT Coffee/Ready TIMEOUT 20s</TT>
</UL>
<P>
<A NAME="IDX582"></A>
<P><H3><A NAME="Header_771">8.16.9 DELETE</A></H3>
<P>
DELETE allows you to delete a mutex or event semaphore.
<P>
<P><H4><A NAME="Header_772">Syntax</A></H4>
<PRE>
DELETE MUTEX &lt;Name&gt; | EVENT &lt;Name&gt;
</PRE>
<P><TT>MUTEX</TT> specifies the name of the mutex semaphore which you
want to delete.  A mutex semaphore may only be deleted if there are no pending
<TT>REQUEST</TT>s.  This option will resolve variables.
<P><TT>EVENT</TT> specifies the name of the event semaphore which you
want to delete.  An event semaphore may only be deleted if there are no processes
<TT>WAIT</TT>ing for it.  This option will resolve variables.
<P>
<P><H4><A NAME="Header_773">Security</A></H4>
<P>This command requires trust level 4.
<P>
<P><H4><A NAME="Header_774">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_775">Results</A></H4>
<P>The result buffer will contain no data on a successful return from a
DELETE command.
<P>
<P><H4><A NAME="Header_776">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B>&nbsp; Delete the Printers/Printer1 mutex semaphore.
<P><B>Syntax:</B>&nbsp; <TT>DELETE MUTEX Printers/Printer1</TT>
<P>
<P><LI><B>Goal:</B>&nbsp; Delete the event semaphore Shutdown_The_Lab
<P><B>Syntax:</B>&nbsp; <TT>DELETE EVENT Shutdown_The_Lab</TT>
</UL>
<P>
<A NAME="IDX585"></A>
<P><H3><A NAME="Header_777">8.16.10 QUERY</A></H3>
<P>QUERY allows you to get information on a mutex or event semaphore,
such as the current owner and pending <TT>REQUESTS</TT>s. if it is
a mutex semaphore or whether the semaphore is posted or reset if it is
an event semaphore. 
<P>
<P><H4><A NAME="Header_778">Syntax</A></H4>
<PRE>
QUERY MUTEX &lt;Name&gt; | EVENT &lt;Name&gt;
</PRE>
<P><TT>MUTEX</TT> specifies the name of the mutex semaphore which you
want to query.  This option will resolve variables.
<P><TT>EVENT</TT> specifies the name of the event semaphore which you
want to query.  This option will resolve variables.
<P>
<P><H4><A NAME="Header_779">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_780">Return Codes</A></H4>
<P>All return codes are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_781">Results</A></H4>
<P>
On successful return, the result buffer will contain information about
the specified mutex or event semaphore:
<P>
<UL>
<P><LI>The result buffer for a <TT>"QUERY MUTEX &lt;Name&gt;"</TT> request will
contain a marshalled <TT>&lt;Map&#58;STAF/Service/Sem/QueryMutex&gt;</TT>
representing a mutex semaphore.
The maps are defined as follows:
<BR>
<P><B><A NAME="Table_83">Table 83. Definition of map class STAF/Service/Sem/QueryMutex</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a mutex semaphore.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">state
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">State
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>'Unowned' | 'Owned'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">owner
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Owner
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;None&gt;</TT> | <TT>&lt;Map&#58;STAF/Service/Sem/MutexOwner&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">requestList
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Pending Requests
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Sem/PendingRequest&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>If the mutex semaphore is currently unowned, "Owner" will be <TT>&lt;None&gt;</TT>.
<LI>If the mutex semaphore is currently owned, "Owner" will contain information
about the owner of the semaphore and "Pending Requests" will contain a list
of requests waiting to acquire the mutex, if any.
</OL>
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_84">Table 84. Definition of map class STAF/Service/Sem/MutexOwner</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the owner of a mutex semaphore.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handleName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">user
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">User
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Authenticator&gt;://&lt;User ID&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Interface&gt;://&lt;System Identifier&gt;[@&lt;Port&gt;]</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">requestTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Date-Time Requested
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">acquireTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Date-Time Acquired
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">gc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Perform Garbage Collection
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'Yes' | 'No'</TT>
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_85">Table 85. Definition of map class STAF/Service/Sem/PendingRequest</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a pending request which is
waiting to acquire a mutex semaphore.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handleName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">user
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">User
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Authenticator&gt;://&lt;User ID&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Interface&gt;://&lt;System Identifier&gt;[@&lt;Port&gt;]</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">requestTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Date-Time Requested
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">gc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Perform Garbage Collection
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'Yes' | 'No'</TT>
</TD></TR></TABLE>
<P>
<P><LI>The result buffer for a <TT>"QUERY EVENT &lt;Name&gt;"</TT> request will
contain a marshalled <TT>&lt;Map&#58;STAF/Service/Sem/QueryEvent&gt;</TT>
representing an event semaphore.
The maps are defined as follows:
<BR>
<P><B><A NAME="Table_86">Table 86. Definition of map class STAF/Service/Sem/QueryEvent</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents an event semaphore.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">state
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">State
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>'Posted' | 'Reset'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">lastPosted
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Last Posted
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Map&#58;STAF/Service/Sem/EventRequester&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">lastReset
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Last Reset
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Map&#58;STAF/Service/Sem/EventRequester&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">waiterList
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Waiters
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Sem/EventRequester&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
If the event semaphore is currently in a reset state, 
"Waiters" will contain a list of requests waiting for the semaphore, if any.
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_87">Table 87. Definition of map class STAF/Service/Sem/EventRequester</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a request for a event semaphore.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handleName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">user
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">User
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Authenticator&gt;://&lt;User ID&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;Interface&gt;://&lt;System Identifier&gt;[@&lt;Port&gt;]</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">timestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_782">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B>&nbsp; Query information about mutex semaphore
DataSource1.  Assume the semaphore is currently unowned.
<P><B>Syntax:</B>&nbsp; <TT>QUERY MUTEX DataSource1</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
State           : Unowned
Owner           : &lt;None&gt;
Pending Requests: []
</PRE>
<P>
<P><LI><B>Goal:</B>&nbsp; Query information about mutex semaphore
DataSource1.  Assume the semaphore is currently owned and there are
no pending requests for it.
<P><B>Syntax:</B>&nbsp; <TT>QUERY MUTEX DataSource1</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in verbose format, could look like:
<PRE>
{
  State           : Owned
  Owner           : {
    Machine                   : machine1.austin.ibm.com
    Handle Name               : STAX/Job/1
    Handle                    : 17
    User                      : none://anonymous
    Endpoint                  : tcp://machine1.austin.ibm.com@6500
    Date-Time Requested       : 20070430-23:54:41
    Date-Time Acquired        : 20070430-23:54:41
    Perform Garbage Collection: Yes
  }
  Pending Requests: []
}
</PRE>
<P>
<P><LI><B>Goal:</B>&nbsp; Query information about mutex semaphore
DataSource1.  Assume the semaphore is currently owned and there are
2 pending requests for it.
<P><B>Syntax:</B>&nbsp; <TT>QUERY MUTEX DataSource1</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in verbose format, could look like:
<PRE>
{
  State           : Owned
  Owner           : {
    Machine                   : machine1.austin.ibm.com
    Handle Name               : STAX/Job/1
    Handle                    : 17
    User                      : none://anonymous
    Endpoint                  : tcp://machine1.austin.ibm.com@6500
    Date-Time Requested       : 20070430-23:54:41
    Date-Time Acquired        : 20070430-23:54:41
    Perform Garbage Collection: Yes
  }
  Pending Requests: [
    {
      Machine                   : machine2.austin.ibm.com
      Handle Name               : STAF/Client
      Handle                    : 32
      User                      : none://anonymous
      Endpoint                  : tcp://machine2.austin.ibm.com@6500
      Date-Time Requested       : 20070430-23:56:16
      Perform Garbage Collection: No
    }
    {
      Machine                   : server1.austin.ibm.com
      Handle Name               : semTest
      Handle                    : 49
      User                      : IBM://Tester1@us.ibm.com
      Endpoint                  : tcp://server1.austin.ibm.com@6500
      Date-Time Requested       : 20070430-23:56:31
      Perform Garbage Collection: Yes
    }
  ]
}
</PRE>
<P>
<P><LI><B>Goal:</B>&nbsp; Query information about event semaphore
Server1/LAN_Started.  Assume the semaphore is currently in a posted state.
<P><B>Syntax:</B>&nbsp; <TT>QUERY EVENT Server1/LAN_Started</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in verbose format, could look like:
<PRE>
{
  State      : Posted
  Last Posted: {
    Machine    : machine1.austin.ibm.com
    Handle Name: STAF/Client
    Handle     : 20
    User       : none://anonymous
    Endpoint   : tcp://machine1.austin.ibm.com@6500
    Date-Time  : 20041026-23:59:51
  }
  Last Reset : {
    Machine    : server2.austin.ibm.com
    Handle Name: myHandle
    Handle     : 17
    User       : IBM://Tester1@us.ibm.com
    Endpoint   : tcp://server2.austin.ibm.com@6500
    Date-Time  : 20041026-23:59:15
  }
  Waiters    : []
}
</PRE>
<P>
<P><LI><B>Goal:</B>&nbsp; Query information about event semaphore
Server1/LAN_Started.  Assume the semaphore is currently in a reset state
with 2 waiters.
<P><B>Syntax:</B>&nbsp; <TT>QUERY EVENT Server1/LAN_Started</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in verbose format, could look like:
<PRE>
{
  State      : Reset
  Last Posted: {
    Machine    : machine1.austin.ibm.com
    Handle Name: STAF/Client
    Handle     : 20
    User       : none://anonymous
    Endpoint   : tcp://machine1.austin.ibm.com@6500
    Date-Time  : 20041026-23:59:51
  }
  Last Reset : {
    Machine    : server2.austin.ibm.com
    Handle Name: myHandle
    Handle     : 17
    User       : IBM://Test1@us.ibm.com
    Endpoint   : tcp://server2.austin.ibm.com@6500
    Date-Time  : 20041027-00:02:12
  }
  Waiters    : [
    {
      Machine    : server2.austin.ibm.com
      Handle Name: myHandle
      Handle     : 17
      User       : IBM://Tester1@us.ibm.com
      Endpoint   : tcp://server2.austin.ibm.com@6500
      Date-Time  : 20041027-00:02:18
    }
    {
      Machine    : machine1.austin.ibm.com
      Handle Name: STAF/Client
      Handle     : 22
      User       : none://anonymous
      Endpoint   : tcp://machine1.austin.ibm.com@6500
      Date-Time  : 20041027-00:02:15
    }
  ]
}
</PRE>
</UL>
<P>
<A NAME="IDX588"></A>
<P><H3><A NAME="Header_783">8.16.11 LIST</A></H3>
<P>LIST allows you to obtain a list of the mutex or event semaphores.
<P>
<P><H4><A NAME="Header_784">Syntax</A></H4>
<PRE>
LIST &lt;MUTEX | EVENT&gt;
</PRE>
<P><TT>MUTEX</TT> specifies that you want a list of the mutex semaphores.
<P><TT>EVENT</TT> specifies that you want a list of the event semaphores.
<P>
<P><H4><A NAME="Header_785">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_786">Return Codes</A></H4>
<P>All return codes from LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_787">Results</A></H4>
<P>On successful return, the result buffer will contain a list of the desired
mutex or event semaphores:
<P>
<UL>
<P><LI>The result buffer for a <TT>LIST MUTEX</TT> request will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Sem/MutexInfo&gt;</TT>
representing the mutex semaphores.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_88">Table 88. Definition of map class STAF/Service/Sem/MutexInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a mutex semaphore.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">state
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">State
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Unowned' | 'Owned'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">pendingRequests
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Pending Requests
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
"Pending Requests" is the number of requests waiting to acquire the mutex.
</TD></TR></TABLE>
<P>
<P><LI>The result buffer for a <TT>LIST EVENT</TT> request will contain
a marshalled <TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Sem/EventInfo&gt;</TT>
representing the event semaphores.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_89">Table 89. Definition of map class STAF/Service/Sem/EventInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents an event semaphore.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">state
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">State
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Posted' | 'Reset'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">waiters
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Waiters
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
"Waiters" is the number of waiters waiting on the event semaphore.
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_788">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B>&nbsp; Obtain a list of the of mutex semaphores.
<P><B>Syntax:</B>&nbsp; <TT>LIST MUTEX</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in table format, could look like:
<PRE>
Name              State   Pending Requests
----------------- ------- ----------------
DataSource1       Unowned 0
Printers/Printer1 Owned   2
</PRE>
<P>
<P><LI><B>Goal:</B>&nbsp; Obtain a list of the of event semaphores.
<P><B>Syntax:</B>&nbsp; <TT>LIST EVENT</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in table format, could look like:
<PRE>
Name                State  Waiters
------------------- ------ -------
Coffee/Ready        Posted 0
Server1/LAN_Started Reset  5
Shutdown_The_Lab    Reset  0
</PRE>
</UL>
<P>
<A NAME="IDX590"></A>
<HR><H2><A NAME="HDRSRVSERVICE" HREF="#ToC_789">8.17 Service Service</A></H2>
<P><H3><A NAME="Header_790">8.17.1 Description</A></H3>
<P>The SERVICE service is one of the internal STAF services.  It provides the
following commands.
<UL COMPACT>
<LI>LIST - Displays information about the services, service loaders, or
authenticators available on the machine, or requests that have been submitted
on the machine
<LI>QUERY - Displays information about a service, authenticator, or service
loader available on the machine, or about a request that has been submitted
on the machine
<LI>ADD - Add (register) a service
<LI>REMOVE - Remove (unregister) a service
<LI>FREE - Frees resources for requests that have been submitted on the 
machine
<LI>HELP &#45; Returns syntax information
</UL>
<A NAME="IDX593"></A>
<P><H3><A NAME="Header_791">8.17.2 LIST</A></H3>
<P>LIST will display information about the services, service loaders, or
authenticators available on the machine, or requests that have been
submitted on the machine.
<P><H4><A NAME="Header_792">Syntax</A></H4>
<PRE>
LIST &#91; SERVICES | SERVICELOADERS | AUTHENTICATORS |
       REQUESTS &lt;&#91;PENDING&#93; &#91;COMPLETE&#93; &#91;LONG&#93;&gt; | &#91;SUMMARY&#93; &#93;
</PRE>
<P><TT>SERVICES</TT> specifies that you want a list of services that are registered.
<P><TT>SERVICELOADERS</TT> specifies that you want a list of the service loaders
that are registered.
<P><TT>AUTHENTICATORS</TT> specifies that you want a list of the authenticators
that are registered.
<P><TT>REQUESTS</TT> specifies that you want a list of requests.
<P><TT>PENDING</TT> specifies that the request list should include pending
requests, i.e. requests which are still being processed.
<P><TT>COMPLETE</TT> specifies that the request list should include completed
requests which have not yet been <TT>FREE</TT>d.
<P><TT>LONG</TT> specifies that the request list should include more detailed
information about each request.
<P>If neither <TT>PENDING</TT> nor <TT>COMPLETE</TT> is specified the default
is <TT>PENDING</TT>.
<P><TT>SUMMARY</TT> specifies that you want summary information about requests
such as the number of active requests, the total number of requests that have
been submitted since STAFProc was started, the number of times the request number
has been reset, the request number range, and the maximum number of active requests.
<P>
<P><H4><A NAME="Header_793">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_794">Return Codes</A></H4>
<P>All return codes from LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_795">Results</A></H4>
<P>If successful, the result buffer will contain information
about the request based on the options specified: 
<UL>
<P><LI>
The result buffer for a <TT>LIST SERVICES</TT>, <TT>LIST SERVICELOADERS</TT>,
or <TT>LIST AUTHENTICATORS</TT> request will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Service/ServiceInfo&gt;</TT>
representing the services, serviceloaders, or authenticators that are
currently registered. The map is defined as follows:
<BR>
<P><B><A NAME="Table_90">Table 90. Definition of map class STAF/Service/Service/ServiceInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a service, serviceloader,
or authenticator.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">library
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Library
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'&lt;Internal&gt;'</TT>, <TT>'&lt;Delegated&gt;'</TT> or library name if external service
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">executable
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Executable
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The value for "Library" will depend on the type of service:
  <UL COMPACT>
  <LI>Internal service:  <TT>&lt;Internal&gt;</TT>
  <LI>Delegated service:  <TT>&lt;Delegated&gt;</TT>
  <LI>External service:  The name of the shared library which implements the
  service or acts as a proxy for the service.  External Java services
  and authenticators will have a library name of <TT>JSTAF</TT>.
  </UL>
<LI>For external Java services, the value for "Executable" will be the 
name of the Java jar file which implements a service, serviceloader, or authenticator.
For non-proxy services libraries (e.g. internal services, delegated services,
C++ services), the value for "Executable" will be <TT>&lt;None&gt;</TT>.
</OL>
</TD></TR></TABLE>
<P>
<P><LI>The result buffer for a <TT>LIST REQUESTS</TT> request without the
<TT>SUMMARY</TT> option specified will contain a marshalled <TT>&lt;List&gt; of
&lt;Map&#58;STAF/Service/Service/RequestInfo&gt;</TT> representing
requests that have been submitted on the machine.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_91">Table 91. Definition of map class STAF/Service/Service/RequestInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information
about a request that has been submitted.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">requestNumber
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Request#
<BR>
(Req#)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">state<SUP>3</SUP>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Status
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'Pending' | 'Complete'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">sourceMachine<SUP>1</SUP>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Source Machine
<BR>
(Source)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">sourceHandleName<SUP>1</SUP>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Source Handle Name
<BR>
(Handle Name)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">sourceHandle<SUP>1</SUP>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Source Handle
<BR>
(H#)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">startTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Start Date-Time
<BR>
(Date-Time)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">targetMachine<SUP>1</SUP>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Target Machine
<BR>
(Target)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Private data will be masked.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">rc<SUP>2</SUP>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Return Code
<BR>
(RC)
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">result<SUP>2</SUP>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<DL COMPACT>
<DD><SUP>1</SUP>  This field is only present if the <TT>LONG</TT> option is
specified in the request.
<DD><SUP>2</SUP>  This field is only present if options <TT>COMPLETE</TT> and
<TT>LONG</TT> are specified in the request.
<DD><SUP>3</SUP>  This field is only present if options <TT>COMPLETE</TT>,
<TT>PENDING</TT>, and <TT>LONG</TT> are specified in the request.
</DL>
<UL COMPACT>
<LI>The value for "Request#" is the request number.
<LI>The value for "Status" is the state of the request.  This will be either
<TT>Pending</TT> or <TT>Complete</TT>.
<LI>The values for "Source Machine", "Source Handle Name", and "Source Handle"
are the machine endpoint, handle name, and handle number of the process that
originated the request.
<LI>The value for "Start Date-Time" is the timestamp when the request started.
<LI>The value for "Target Machine" is the machine to which the request was sent.
<LI>The value for "Service" is the service to which the request was sent.
<LI>The value for "Request" is the request which was sent.
<LI>The value for "Return Code" is the return code from the request.  This will be
<TT>&lt;None&gt;</TT> if the request status is <TT>Pending</TT>.
<LI>The value for "Result" is the result buffer from the request.  This will be
<TT>&lt;None&gt;</TT> if the request status is <TT>Pending</TT>.
</UL>
</TD></TR></TABLE>
<P>
<P>
<P><LI>The result buffer for a <TT>LIST REQUESTS SUMMARY</TT> request will
contain a marshalled <TT>&lt;Map&#58;STAF/Service/Service/RequestSummary&gt;</TT>
representing summary information about requests.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_92">Table 92. Definition of map class STAF/Service/Service/RequestSummary</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents summary information
about requests.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">activeRequests
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Active Requests
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">totalRequests
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Total Requests
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">resetCount
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Reset Count
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">requestNumberRange
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Request Number Range
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">&lt;Minimum - Maximum&gt;
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">maxActiveRequests
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Maximum Active Requests
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<UL COMPACT>
<LI>The value for "Active Requests" is the number of pending and complete
(but not freed) requests.
<LI>The value for "Total Requests" is the total number of requests that
have been submitted since STAFProc was started.
<LI>The value for "Reset Count" is the number of times the request number
has been reset back to 1.
<LI>The value for "Request Number Range" is the range of values for
the request number.
<LI>The value for "Maximum Active Requests" is the maximum number of
active (pending and complete but not freed) requests.
</UL>
</TD></TR></TABLE>
<P>
</UL>
<P>
<P><H4><A NAME="Header_796">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> List all the services registered on a machine.
<P><B>Syntax:</B> <TT>LIST SERVICES</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in table format, could look like:
<PRE>
Name     Library    Executable
-------- ---------- -------------------------------------
CRON     JSTAF      C:\STAF\services\STAFCron.jar
DELAY    &lt;Internal&gt; &lt;None&gt;
DIAG     &lt;Internal&gt; &lt;None&gt;
ECHO     &lt;Internal&gt; &lt;None&gt;
EM       JSTAF      C:\STAF\services\STAFEventManager.jar
EMAIL    JSTAF      C:\STAF\services\STAFEmail.jar
EVENT    JSTAF      C:\STAF\services\STAFEvent.jar
FS       &lt;Internal&gt; &lt;None&gt;
HANDLE   &lt;Internal&gt; &lt;None&gt;
HELP     &lt;Internal&gt; &lt;None&gt;
LOG      STAFLog    &lt;None&gt;
MISC     &lt;Internal&gt; &lt;None&gt;
MONITOR  STAFMon    &lt;None&gt;
NC       JSTAF      C:\STAF\services\STAFNamedCounter.jar
PING     &lt;Internal&gt; &lt;None&gt;
PROCESS  &lt;Internal&gt; &lt;None&gt;
QUEUE    &lt;Internal&gt; &lt;None&gt;
RESPOOL  STAFPool   &lt;None&gt;
SEM      &lt;Internal&gt; &lt;None&gt;
SERVICE  &lt;Internal&gt; &lt;None&gt;
SHUTDOWN &lt;Internal&gt; &lt;None&gt;
STAX     JSTAF      C:\STAF\services\STAX.jar
TIMER    JSTAF      C:\STAF\services\STAFTimer.jar
TRACE    &lt;Internal&gt; &lt;None&gt;
TRUST    &lt;Internal&gt; &lt;None&gt;
VAR      &lt;Internal&gt; &lt;None&gt;
</PRE>
<P>
<P><LI><B>Goal:</B> List all the service loaders registered on a machine.
<P><B>Syntax:</B>  <TT>LIST SERVICELOADERS</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in table format, could look like:
<PRE>
Name               Library  Executable
------------------ -------- ----------------------------------------
STAFSERVICELOADER1 STAFDSLS &lt;None&gt;
STAFSERVICELOADER2 JSTAF    C:\STAF\services\CustomServiceLoader.jar
</PRE>
<P>
<P><LI><B>Goal:</B> List all the authenticators registered on a machine.
<P><B>Syntax:</B>  <TT>LIST AUTHENTICATORS</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in table format, could look like:
<PRE>
Name       Library Executable
---------- ------- --------------------------------------------------------
AUTHSAMPLE JSTAF   C:\STAF\services\AuthSample.jar
IBM        JSTAF   C:\STAF\services\STAFIBMIntraAuth.jar
</PRE>
<P>
<P><LI><B>Goal:</B> List all the pending requests on a machine.
<P><B>Syntax:</B> <TT>LIST REQUESTS</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in table format, could look like:
<PRE>
Request# Start Date-Time   Service Request
-------- ----------------- ------- ------------------------------------------
39       20050321-16:33:03 QUEUE   GET WAIT
63       20050321-16:33:03 QUEUE   GET WAIT 10000
102      20050321-16:34:42 QUEUE   GET WAIT 120000 TYPE ProductA/Test2/Status
165      20050321-16:34:52 DELAY   DELAY 60000
106      20050321-16:34:58 SERVICE LIST REQUESTS
</PRE>
<P>
<P><LI><B>Goal:</B> List detailed information on all the pending
requests on a machine.
<P><B>Syntax:</B> <TT>LIST REQUESTS LONG</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in table format, could look like:
<PRE>
Req# Source  Handle Name  H# Date-Time Target     Service Request
---- ------- ------------ -- --------- ---------- ------- ---------------------
39   local:/ STAF/SERVICE 11 20050321- client1.co QUEUE   GET WAIT
     /local  /eM             14:25:04  mpany.com
63   local:/ STAF/Service 16 20050321- client1.co QUEUE   GET WAIT 10000
     /local  /TimeR/Watch    14:25:04  mpany.com                              
102  local:/ ProductA/Tes 21 20050321- client1.co QUEUE   GET WAIT 120000 TYPE
     /local  t2              16:34:42  mpany.com          ProductA/Test2/Status
165  local:/ STAF/Client  27 20050321- client2    DELAY   DELAY 60000
     /local                  16:34:52                           
180  local:/ STAF/Client  34 20050321- client1.co SERVICE LIST REQUESTS LONG
     /local                  14:39:04  mpany.com
</PRE>
<P>
<P><LI><B>Goal:</B> List detailed information on all the pending and
complete requests on a machine.
<P><B>Syntax:</B> <TT>LIST REQUESTS PENDING COMPLETE LONG</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in table format, could look like:
<PRE>
Req# State   Source  Handle Name H# Date-Time Target Service Request  RC Result
---- ------- ------- ----------- -- --------- ------ ------- -------- -- ------
39   Pending local:/ STAF/SERVIC 11 20050321- client QUEUE   GET WAIT &lt;N &lt;None&gt;
             /local  E/eM           14:25:04  1.comp                  on
                                              any.co                  e&gt;
                                              m
63   Pending local:/ STAF/Servic 16 20050321- client QUEUE   GET WAIT &lt;N &lt;None&gt;
             /local  e/TimeR/Wat    14:25:04  1.comp          10000   on
                     ch                       any.co                  e&gt;
                                              m
102  Pending local:/ ProductA/Te 21 20050321- client QUEUE   GET WAIT &lt;N &lt;None&gt;
             /local  st2            16:34:42  1.comp         120000 T on
                                              any.co         YPE Prod e&gt;
                                              m              uctA/Tes
                                                             t2/Statu
                                                             s
165  Pending local:/ STAF/Client 27 20050321- client DELAY   DELAY 60 &lt;N &lt;None&gt;
             /local                 16:34:52  2              000      on
                                                                      e&gt;
176  Complet local:/ TestA       36 20050321- client MISC    VERSION  0  3.0.0
     e       /local                 13:30:14  1.comp
                                              any.co
                                              m                      
180  Pending local:/ STAF/Client 38 20050321- client SERVICE LIST REQ &lt;N &lt;None&gt;
             /local                 13:30:16  1.comp         UESTS PE on
                                              any.co         NDING CO e&gt;
                                              m              MPLETE L
                                                             ONG
</PRE>
<P>
<P><LI><B>Goal:</B> List detailed information on all the complete requests on a machine.
<P><B>Syntax:</B> <TT>LIST REQUESTS COMPLETE LONG</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in table format, could look like:
<PRE>
Req# Source  Handle Name H# Date-Time Target     Service Request  RC Result
---- ------- ----------- -- --------- ---------- ------- -------- -- ------
176  local:/ TestA       36 20050321- client1.co MISC    VERSION  0  3.0.0
     /local                 13:30:14  mpany.com
</PRE>
<P>
<P><LI><B>Goal:</B> List summary information about requests.
<P><B>Syntax:</B> <TT>LIST REQUESTS SUMMARY</TT>
<P><B>Results:</B>  If the request is issued from the
command line, the result, in default form, could look like:
<PRE>
Active Requests        : 12
Total Requests         : 24127
Reset Count            : 0
Request Number Range   : 1 - 2147483647
Maximum Active Requests: 2147483647
</PRE>
</UL>
<A NAME="IDX595"></A>
<P><H3><A NAME="Header_797">8.17.3 QUERY</A></H3>
<P>QUERY will display information about a service, authenticator, or service
loader available on the machine, or about a request that has been submitted
on the machine.
<P><H4><A NAME="Header_798">Syntax</A></H4>
<PRE>
QUERY SERVICE &lt;Service Name&gt; | SERVICELOADER &lt;ServiceLoader Name&gt; |
      AUTHENTICATOR &lt;Authenticator Name&gt; | REQUEST &lt;Request Number&gt;
</PRE>
<P><TT>SERVICE</TT> specifies the name of the service to be queried.
<P><TT>SERVICELOADER</TT> specifies the name of the service loader
to be queried.
<P><TT>AUTHENTICATOR</TT> specifies the name of the authenticator service
to be queried.
<P><TT>REQUEST</TT> specifies the number of the request to be queried.
<P><H4><A NAME="Header_799">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_800">Return Codes</A></H4>
<P>All return codes from QUERY are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_801">Results</A></H4>
<P>
If successful, the result buffer will contain the following based on
the request:
<UL>
<P><LI>The result buffer for a <TT>QUERY SERVICE</TT>,
<TT>QUERY SERVICELOADER</TT>, or <TT>QUERY AUTHENTICATOR</TT> request
will contain a marshalled <TT>&lt;Map&#58;STAF/Service/Service/QueryService&gt;</TT>
representing the specified service, service loader, or authenticator.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_93">Table 93. Definition of map class STAF/Service/Service/QueryService</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a service, service
loader, or authenticator.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">library
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Library
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'&lt;Internal&gt;'</TT>, <TT>'&lt;Delegated&gt;'</TT> or library name if external service
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">executable
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Executable
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">options
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Options
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">List of <TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">parameters
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Parameters
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The value for "Name" is the name of the service, service
loader, or authenticator.
<LI>The value for "Library" will depend on the type of service:
  <UL COMPACT>
  <LI>Internal service:  <TT>&lt;Internal&gt;</TT>
  <LI>Delegated service:  <TT>&lt;Delegated&gt;</TT>
  <LI>External service:  The name of the shared library which implements the
  service or acts as a proxy for the service.  External Java services
  and authenticators will have a library name of <TT>JSTAF</TT>.
  </UL>
<LI>For external Java services, the value for "Executable" will be the 
name of the Java jar file which implements a service, serviceloader, or authenticator.
For non-proxy services libraries (e.g. internal services, delegated services,
C++ services), the value for "Executable" will be <TT>&lt;None&gt;</TT>.
<LI>The value for "Options" is a list of the options specified when
registering the service.
<LI>The value for "Parameters" is a string containing the parameters
specified when registering the service or <TT>&lt;None&gt;</TT> if no parameters
were specified.
</OL>
</TD></TR></TABLE>
<P>
<P><LI>The result buffer for a <TT>QUERY REQUEST</TT> request will contain
a marshalled <TT>&lt;Map&#58;STAF/Service/Service/QueryRequest&gt;</TT>
representing the specified request.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_94">Table 94. Definition of map class STAF/Service/Service/QueryRequest</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a request that has been submitted.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">requestNumber
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Request#
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">state
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Request Status
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'Pending' | 'Complete'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">sourceMachine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Source Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">sourceHandleName
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Source Handle Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">sourceHandle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Source Handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">startTimestamp
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Start Date-Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>&lt;YYYYMMDD-HH&#58;MM&#58;SS&gt;</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">targetMachine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Target Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Request
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Return Code
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The value for "Request#" is the request number.
<LI>The value for "Request Status" is the state of the request.  This will be either
<TT>Pending</TT> or <TT>Complete</TT>.
<LI>The values for "Source Machine", "Source Handle Name", and "Source Handle" are the
machine endpoint, handle name, and handle number of the process that originated
the request.
<LI>The value for "Start Date-Time" is the timestamp when the request started.
<LI>The value for "Target Machine" is the machine to which the request was sent, i.e. the
target machine.
<LI>The value for "Service" is the service to which the request was sent.
<LI>The value for "Request" is the request which was sent.
<LI>The value for "Return Code" is the return code from the request.  This will be
<TT>&lt;None&gt;</TT> if the request status is <TT>Pending</TT>.
<LI>The value for "Result" is the result buffer from the request.  This will be
<TT>&lt;None&gt;</TT> if the request status is <TT>Pending</TT>.
</OL>
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_802">Examples</A></H4>
<P>
<UL COMPACT>
<LI><B>Goal:</B> Query the information for the LOG service (a C++ service).
<P><B>Syntax:</B>  <TT>QUERY SERVICE LOG</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
{
  Name      : LOG
  Library   : STAFLog
  Executable: &lt;None&gt;
  Options   : []
  Parameters: DEFAULTMAXQUERYRECORDS 50
}
</PRE>
<P>
<LI><B>Goal:</B> Query the information for the STAX service (a Java service).
<P><B>Syntax:</B>  <TT>QUERY SERVICE STAX</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
{
  Name      : STAX
  Library   : JSTAF
  Executable: C:\STAF\services\stax\STAX.jar
  Options   : [
    JVMName=STAX
    J2=-Xmx512m
  ]
  Parameters: EXTENSIONXMLFILE C:/STAF/services/stax/extensions.xml
}
</PRE>
<P>
<LI><B>Goal:</B> Query the information for the authenticator service
named AuthSample.
<P><B>Syntax:</B>  <TT>QUERY AUTHENTICATOR AuthSample</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
{
  Name      : AUTHSAMPLE
  Library   : JSTAF
  Executable: C:\STAF\authenticators\AuthSample.jar
  Options   : [
    JVMName=Auth
  ]
  Parameters: USERPROPERTIESFILE C:/STAF/authenticators/authsample.properties
}
</PRE>
<P>
<LI><B>Goal:</B> Query the information for the service loader service
names STAFServiceLoader1.
<P><B>Syntax:</B>  <TT>QUERY SERVICELOADER STAFServiceLoader1</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
{
  Name      : STAFSERVICELOADER1
  Library   : STAFDSLS
  Executable: &lt;None&gt;
  Options   : []
  Parameters: &lt;None&gt;
}
</PRE>
<P>
<LI><B>Goal:</B> Query the information for request number 34.
<P><B>Syntax:</B>  <TT>QUERY REQUEST 34</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
Request Number    : 34
Request Status    : Pending
Source Machine    : local://local
Source Handle Name: STAF/SERVICE/EM
Source Handle     : 10
Start Date-Time   : 20050321-19:02:28
Target Machine    : server1.company.com
Service           : QUEUE
Request           : GET WAIT
Return Code       : &lt;None&gt;
Result            : &lt;None&gt;
</PRE>
</UL>
<A NAME="IDX598"></A>
<P><H3><A NAME="Header_803">8.17.4 ADD</A></H3>
<P>ADD will add (register and initialize) the specified external service and make it
available on the machine.
<P><H4><A NAME="Header_804">Syntax</A></H4>
<PRE>
ADD SERVICE &lt;Service Name&gt; LIBRARY &lt;Library Name&gt; &#91;EXECUTE &lt;Executable&gt;&#93;
    &#91;OPTION &lt;Name&#91;=Value&#93;&gt;&#93;... &#91;PARMS &lt;Parameters&gt;&#93;
</PRE>
<P><TT>SERVICE</TT> specifies the name by which this service will be known on this machine. 
<P><TT>LIBRARY</TT> specifies the name of the shared library / DLL which implements the
service or acts as a proxy for the service. See the information for each
external service to determine the appropriate value for this option. 
<P><TT>EXECUTE</TT> is used by service proxy libraries / DLLs to specify what the proxy
library should execute. For example, this might be the name of the Java jar file
which actually implements the service. This option has no significance for non-proxy service
libraries. See section <A HREF="#HDRJVMCFG">4.4.2, "JSTAF service proxy library"</A> for information
regarding the JSTAF service proxy library.
Otherwise, see the documentation provided by the service proxy library.
<P><TT>OPTION</TT> specifies a configuration option that will be passed on to the service
library / DLL. This is typically used by service proxy libraries to further control the
interface to the actual service implementation. You may specify multiple OPTIONs for a given
service. See section <A HREF="#HDRJVMCFG">4.4.2, "JSTAF service proxy library"</A> for acceptable options for
the JSTAF service proxy library.
Otherwise, see the documentation provided with the service (proxy) library. 
<P><TT>PARMS</TT> specifies optional parameters that will be passed to the service during
initialization. 
<P><H4><A NAME="Header_805">Security</A></H4>
<P>This command requires trust level 5.
<P><H4><A NAME="Header_806">Return Codes</A></H4>
<P>All return codes from ADD are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_807">Results</A></H4>
<P>On successful return, the result buffer will contain nothing. 
<P><H4><A NAME="Header_808">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Add the Monitor service, an external C++ service.
<P><B>Syntax:</B>&nbsp; <TT>ADD SERVICE Monitor LIBRARY STAFMon</TT>
<P>
<P><LI><B>Goal:</B> Add the STAX service, an external Java service, specifying a parameter.
<P><B>Syntax:</B>&nbsp; <TT>ADD SERVICE STAX LIBRARY JSTAF EXECUTE C:\STAF\services\STAX.jar PARMS "NUMTHREADS 8"</TT>
</UL>
<A NAME="IDX601"></A>
<P><H3><A NAME="Header_809">8.17.5 REMOVE</A></H3>
<P>REMOVE will remove (unregister and terminate) the specified external service,
 making it no longer available on the machine.
<P>
<P><B>Note: </B>If pending requests for the service exist, it may take up to a minute
or so after the REMOVE request has completed in order for the service to
complete its termination process.  This can be especially true for a service
that is registered using a service proxy library such as JSTAF which is used
when registering Java services as it may take another minute or so for the JVM
that this service was running in to be terminated (assuming that the Java
service being removed is the only Java service running in this JVM).
<P>
<P><H4><A NAME="Header_810">Syntax</A></H4>
<PRE>
REMOVE SERVICE &lt;Service Name&gt;
</PRE>
<P><TT>SERVICE</TT> specifies the name of the service to remove. 
<P><H4><A NAME="Header_811">Security</A></H4>
<P>This command requires trust level 5.
<P><H4><A NAME="Header_812">Return Codes</A></H4>
<P>All return codes from REMOVE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_813">Results</A></H4>
<P>On successful return, the result buffer will contain nothing.
<P><H4><A NAME="Header_814">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Remove the Event service.
<P><B>Syntax:</B>&nbsp; <TT>REMOVE SERVICE Event</TT>
</UL>
<A NAME="IDX603"></A>
<P><H3><A NAME="HDRSRVREQF">8.17.6 FREE</A></H3>
<P>FREE returns the results of a completed request that was submitted using
the kSTAFReqQueue or kSTAFReqQueueRetain options (see <A HREF="#HDRAPISS2">6.2.5, "STAFSubmit2"</A> for
more information).  This command also removes the request from the request list.
<P>
<P><H4><A NAME="Header_816">Syntax</A></H4>
<PRE>
FREE REQUEST &lt;Request Number&gt; &#91;FORCE&#93;
</PRE>
<P><TT>REQUEST</TT> specifies which request should be freed.
<P><TT>FORCE</TT> must be specified if any process other than the originating
process tries to <TT>FREE</TT> the request's results.
<P>
<P><H4><A NAME="Header_817">Security</A></H4>
<P>This command requires trust level 5.
<P>
<P><H4><A NAME="Header_818">Return Codes</A></H4>
<P>All return codes from FREE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_819">Results</A></H4>
<P>
If successful, the result buffer for a <TT>FREE</TT> request will contain
a marshalled <TT>&lt;Map&#58;STAF/Service/Service/FreeRequestInfo&gt;</TT>
representing the results of the completed request.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_95">Table 95. Definition of map class STAF/Service/Service/QueryRequest</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the results of a completed request.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Return Code
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The value for "Return Code" is the return code from the request.
<LI>The value for "Result" is the result buffer from the request.
</OL>
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_820">Examples</A></H4>
<P>
<UL COMPACT>
<LI><B>Goal:</B> Free request 16.  Let's assume this was a <TT>VERSION</TT>
request to the <TT>MISC</TT> service.
<P><B>Syntax:</B>  <TT>FREE REQUEST 16</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in default format, could look like:
<PRE>
Return Code: 0
Result     : 3.0.0
</PRE>
</UL>
<P>
<A NAME="IDX604"></A>
<A NAME="IDX606"></A>
<HR><H2><A NAME="HDRSHUTDS" HREF="#ToC_821">8.18 Shutdown Service</A></H2>
<P><H3><A NAME="Header_822">8.18.1 Description</A></H3>
<P>The SHUTDOWN service is an internal STAF service.  It provides the
following commands.
<UL COMPACT>
<LI>SHUTDOWN - Shutdown the STAF Process
<LI>NOTIFY REGISTER - Register for shutdown notification
<LI>NOTIFY UNREGISTER - Unregister for shutdown notification
<LI>NOTIFY LIST - Display the list of machines/processes to receive shutdown
notifications.
<LI>HELP &#45; Returns syntax information
</UL>
<A NAME="IDX609"></A>
<P><H3><A NAME="Header_823">8.18.2 SHUTDOWN</A></H3>
<P>SHUTDOWN, as the name implies, submits a request to shut down the STAFProc
program.
<P><B>Note: </B>A SHUTDOWN request returns before STAFProc completes shutting down.
It may take up to a minute or so after a SHUTDOWN request has returned for
STAFProc to finish shutting down all of its registered services.
<P><H4><A NAME="Header_824">Syntax</A></H4>
<PRE>
SHUTDOWN
</PRE>
<P><H4><A NAME="Header_825">Security</A></H4>
<P>This command requires trust level 5.
<P><H4><A NAME="Header_826">Return Codes</A></H4>
<P>All return codes from SHUTDOWN are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_827">Results</A></H4>
<P>The result buffer will contain no data on return from a SHUTDOWN command.
<P><H4><A NAME="Header_828">Command Line Example</A></H4>
<P>Goal&#58; Shutdown STAFProc on the local system.
<PRE>
STAF local SHUTDOWN SHUTDOWN
</PRE>
<A NAME="IDX611"></A>
<A NAME="IDX614"></A>
<A NAME="IDX616"></A>
<P><H3><A NAME="Header_829">8.18.3 NOTIFY REGISTER/UNREGISTER</A></H3>
<P>NOTIFY REGISTER/UNREGISTER allow you to either register or unregister to
receive a notification when the STAF Process is SHUTDOWN.
<P><H4><A NAME="Header_830">Syntax</A></H4>
<PRE>
NOTIFY &lt;REGISTER | UNREGISTER&gt; &#91;MACHINE &lt;Machine&gt;&#93;  &#91;PRIORITY &lt;Priority&gt;&#93;
       &#91;HANDLE &lt;Handle&gt; | NAME &lt;Name&gt;&#93;
</PRE>
<P><TT>REGISTER</TT> indicates you want to register a shutdown notification.
The type of the notification message will be <TT>STAF/Shutdown</TT> with a blank message.
<P><TT>UNREGISTER</TT> indicates you want to unregister a shutdown
notification
<P><TT>MACHINE</TT> specifies the machine to which the notification should
be sent.  The default is the machine submitting the request. This option will resolve variables.
<P><TT>PRIORITY</TT> specifies the priority of the notification message.
The default is 5. This option will resolve variables.
<P><TT>HANDLE</TT> specifies the handle to which the notification should be
sent.  The default is the handle of the process submitting the request.
This option will resolve variables.
<P><TT>NAME</TT> specifies the registered name of the process(es) to which
the notification should be sent. This option will resolve variables.
<P><H4><A NAME="Header_831">Security</A></H4>
<P>These commands require trust level 3.
<P><H4><A NAME="Header_832">Return Codes</A></H4>
<P>All return codes from NOTIFY REGISTER/UNREGISTER are documented in
<A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_833">Results</A></H4>
<P>The result buffer will contain no data on return from a NOTIFY
REGISTER/UNREGISTER command.
<P><H4><A NAME="Header_834">Examples</A></H4>
<P>Goal&#58; Register the current process for a priority 3 shutdown
notification.
<PRE>
NOTIFY REGISTER PRIORITY 3
</PRE>
<P>Goal&#58; Register to have a shutdown notification sent to all
processes with registered name ShutdownCatcher on machine EventSrv1.
<PRE>
NOTIFY REGISTER MACHINE EventSrv1 NAME ShutdownCatcher
</PRE>
<P>Goal&#58; Unregister the shutdown notification for handle 43.
<PRE>
NOTIFY UNREGISTER HANDLE 43
</PRE>
<A NAME="IDX619"></A>
<P><H3><A NAME="Header_835">8.18.4 NOTIFY LIST</A></H3>
<P>NOTIFY LIST allows you to view the shutdown notification list.
<P><H4><A NAME="Header_836">Syntax</A></H4>
<PRE>
NOTIFY LIST
</PRE>
<P><H4><A NAME="Header_837">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_838">Return Codes</A></H4>
<P>All return codes from NOTIFY LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_839">Results</A></H4>
<P>
On successful return, the result buffer for a <TT>NOTIFY LIST</TT>
request will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Shutdown/Notifiee&gt;</TT>
representing a list of all the registered notifiees.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_96">Table 96. Definition of map class STAF/Service/Shutdown/Notifiee</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a registered shutdown notifiee.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="43%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">priority
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Priority
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="43%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%"><TT>'Stdout' | 'Stderr'</TT> or a file name
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Machine
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="43%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">notifyBy
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Notify By
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="43%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%"><TT>'Name' | 'Handle'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">notifiee
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Notifiee
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="43%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%"><BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
If the "Notify By" value is 'Name', the notifiee will be notified by handle name
and the "Notifiee" value will be the handle name.
Otherwise, if the "Notify By" value is 'Handle', the notifiee will be 
notified by handle and the "Notifiee" value will be the handle number.
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_840">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal&#58;</B> Retrieve the list of shutdown notifiees.
<P><B>Request&#58;</B>&nbsp; <TT>NOTIFY LIST</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in table format, could look like:
<PRE>
Priority Machine                Notify By Notifiee
-------- ---------------------- --------- ---------------
5        server1.austin.ibm.com Name      ShutdownCatcher
3        client2.austin.ibm.com Handle    18
</PRE>
</UL>
<P>
<A NAME="IDX620"></A>
<A NAME="IDX622"></A>
<HR><H2><A NAME="HDRTRACESRV" HREF="#ToC_841">8.19 Trace Service</A></H2>
<P><H3><A NAME="Header_842">8.19.1 Description</A></H3>
<P>The TRACE service is one of the internal STAF services.  It provides the following
trace commands.
<UL COMPACT>
<LI>ENABLE - Allows you to specify trace points and STAF service(s) to be enabled for tracing.
<LI>DISABLE - Allows you to specify trace points and STAF service(s) to be disabled for tracing.
<LI>LIST - Returns the current settings for the trace service
<LI>PURGE - Allows you to remove tracing information for services that are not registered
<LI>SET - Allows you to set the destination for the tracing
information, the default tracing state for new services, or the maximum size
(in characters) of the service result string to write to the trace output when
the ServiceResult tracepoint is enabled.
<LI>HELP &#45; Returns syntax information
</UL>
<P>The purpose of the Trace service is to allow you to control the trace messages
recorded for STAF services. For example, if you are experiencing a problem with a
STAF service or a request to a STAF service, you can specify various STAF trace
points and/or STAF service(s) to be enabled for tracing to record additional trace
messages which can help you resolve the problem.
<P><B>Note: </B>If you enable one or more of the "service" tracepoints (e.g. ServiceRequest,
ServiceResult, ServiceError, ServiceAccessDenied, or RemoteRequests), these trace
messages will only be reported for the services you have enabled for tracing.
<P><H4><A NAME="Header_843">Format of Trace Messages</A></H4>
<P>The format of each trace message is the following
<PRE>
&lt;Timestamp&gt;;&lt;Thread&gt;;&lt;Trace Point&gt;;&lt;Message&gt;
</PRE>
<P>where&#58;
<P><TT>&lt;Timestamp&gt;</TT> is the date/time of the message.
<P><TT>&lt;Thread&gt;</TT> is the thread on which the message originated.
<P><TT>&lt;Trace Point&gt;</TT> is the hexadecimal representation of the message's
trace point.  See table <A HREF="#HDRTRACEPOINTREF">8.19.2, "Trace Points Reference"</A> for a list of trace points.
<P><TT>&lt;Message&gt;</TT> is the actual trace message. Private data will be masked.
<P><H4><A NAME="Header_844">Examples of Trace Messages</A></H4>
<P>Here's an example of a <TT>ServiceManagement</TT> trace message:
<PRE>
20050811-16&#58;20&#58;50;1;00000010;Service HELP: Initializing
</PRE>
<P>Here's an example of a <TT>Warning</TT> trace message:
<PRE>
20050811-10&#58;10&#58;50;4836;00000400;STAFConnectionManager&#58;&#58;makeConnection - Attempt 
#1 of 2 (Delay 41 milliseconds), RC: 16, Result: STAFConnectionProviderConnect: 
Timed out connecting to endpoint: select() timeout: 22, Endpoint: client1
</PRE>
<P>Here's an example of <TT>ServiceRequest</TT> and <TT>ServiceResult</TT> trace messages:
<PRE>
20050811-10&#58;33&#58;54;4836;00000001;PROCESS Service Request - Client: local://local,
 Handle: 30, Process: STAF/Client, Request: start command date returnstdout wait
 
20050811-10&#58;33&#58;54;4836;00000002;PROCESS Service Result (0) - Client: local://loc
al, Handle: 30, Process: STAF/Client, Request: start command date returnstdout w
ait, Result: {
  Return Code: 0
  Key        : &lt;None&gt;
  Files      : [
    {
      Return Code: 0
      Data       : Thu Aug 11 10:33:54 CDT 2005
 
    }
  ]
}
</PRE>
<P>
<P><H3><A NAME="HDRTRACEPOINTREF">8.19.2 Trace Points Reference</A></H3>
<P>The following are the valid trace points along with their hexadecimal representation
and their descriptions.
The hexadecimal representation of a trace point is logged in each trace message.
Trace points are not case sensitive.
<A NAME="IDX624"></A>
<BR>
<P><B><A NAME="TBLTRCHEX">Table 97. Trace point hexadecimal representation</A></B><BR>
<TABLE  BORDER>
<P>
<TR>
<TH ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">Hex
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="13%">Trace point
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">Description
</TH></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">00000001
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%"><TT>ServiceRequest</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">The trace point which causes a trace message to be generated for every
incoming service request before it is processed by the service.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">00000002
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%"><TT>ServiceResult</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">The trace point which causes a trace message to be generated for every
incoming service request after it is processed by the service.
Note that the trace message will include the return code and result for the
service request. 
This tracepoint overrides the <TT>ServiceComplete</TT>,
<TT>ServiceError</TT> and <TT>ServiceAccessDenied</TT> tracepoints.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">00000004
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%"><TT>ServiceError</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">The trace point which causes a trace message to
be generated for every incoming service request which results in a non-zero
error code.  Note that the trace message will include the return code and
result for the service request.
This tracepoint overrides the <TT>ServiceAccessDenied</TT> tracepoint.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">00000008
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%"><TT>ServiceAccessDenied</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">The trace point which causes a trace
message to be generated for every incoming service request which results in an
"Insufficient Trust Level" (aka "Access Denied") error code.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">00000010
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%"><TT>ServiceManagement</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">The trace point which causes a trace message to be generated for
service management operations such as service initialization and termination.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">00000020
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%"><TT>RemoteRequests</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">The trace point which enables trace message to be generated for
requests destined for other machines.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">00000100
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%"><TT>Error</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">The trace point which causes a trace message to be generated for error
conditions that STAF detects, such as broken communication connections and
fatal STAF Service errors.  The <TT>Error</TT> trace point is turned on
by default.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">00000200
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%"><TT>Registration</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">The trace point which causes a trace message to be generated for
every registration or unregistration done by a process.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">00000400
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%"><TT>Warning</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">The trace point which causes a trace message to be generated for
warning conditions that STAF detects.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">00000800
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%"><TT>Info</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">The trace point which causes a trace message to be generated for
information conditions that STAF detects.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">00001000
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%"><TT>Deprecated</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">The trace point which causes a trace message to be generated for
deprecated options that STAF detects.
A deprecated option is not recommended for use, generally due to improvements,
and a replacement option is usually given. Deprecated options may be removed in
future implementations. The <TT>Deprecated</TT> trace point is turned on by default.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">00002000
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%"><TT>Debug</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">The trace point which causes a trace message to be generated for
debug conditions that STAF detects.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="13%">00004000
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="13%"><TT>ServiceComplete</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="75%">The trace point which causes a trace message to be generated for every
incoming service request after it is processed by the service.
Note that the trace message will include the return code and result length
for the service request, but not the result data. 
This tracepoint overrides the <TT>ServiceError</TT> and
<TT>ServiceAccessDenied</TT> tracepoints.
</TD></TR></TABLE>
<A NAME="IDX627"></A>
<A NAME="IDX629"></A>
<P><H3><A NAME="HDRTRACESRVENABLE">8.19.3 Enable</A></H3>
<P>ENABLE allows you to enable trace points and STAF services for tracing.
See table <A HREF="#HDRTRACEPOINTREF">8.19.2, "Trace Points Reference"</A> for a list of valid trace points.
<P><B>Note: </B>You can enable services that aren't currently registered and they will begin
tracing when they are registered with STAF.
<P>
<P><H4><A NAME="Header_847">Syntax</A></H4>
<PRE>
ENABLE ALL  [ TRACEPOINTS | SERVICES ]
ENABLE TRACEPOINTS &lt;Trace point list&gt; | SERVICES &lt;Service list&gt;
ENABLE TRACEPOINT &lt;Trace point&gt; [ TRACEPOINT &lt;Trace point&gt; ]...
ENABLE SERVICE &lt;Service&gt; [ SERVICE &lt;Service&gt; ]...
</PRE>
<P><TT>ALL</TT> indicates to enable tracing for all trace points and/or services
<P><TT>TRACEPOINTS</TT> indicates a list of trace points to be enabled for tracing.
The trace points in the list should be separated by spaces.  This option will resolve variables.
<P><TT>SERVICES</TT> indicates a list of services to be enabled for tracing.
The services in the list should be separated by spaces.  This option will resolve variables.
<P><TT>TRACEPOINT</TT> indicates which trace point should be enabled for tracing. This option will resolve variables.
<P><TT>SERVICE</TT> indicates which service should be enabled for tracing. This option will resolve variables.
<P><H4><A NAME="Header_848">Security</A></H4>
<P>This command requires trust level 5.
<P><H4><A NAME="Header_849">Return Codes</A></H4>
<P>All return codes from ENABLE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_850">Results</A></H4>
<P>For <TT>ENABLE</TT> the result buffer will be empty if there are no errors
<P><H4><A NAME="Header_851">Examples</A></H4>
<UL>
<P><LI><B>Goal&#58;</B> Enable the service request, service result, and service management trace points
<P><B>Syntax&#58;</B> <TT>ENABLE TRACEPOINTS "ServiceRequest ServiceResult ServiceManagement"</TT>
<P><LI><B>Goal&#58;</B> Enable the error and warning trace points
<P><B>Syntax&#58;</B> <TT>ENABLE TRACEPOINTS "Error Warning"</TT>
<P><LI><B>Goal&#58;</B> Enable all trace points
<P><B>Syntax&#58;</B> <TT>ENABLE ALL TRACEPOINTS</TT>
<P><LI><B>Goal&#58;</B> Enable tracing for remote requests
<P><B>Syntax&#58;</B> <TT>ENABLE TRACEPOINT RemoteRequests</TT>
<P><LI><B>Goal&#58;</B> Enable tracing only for the PROCESS and QUEUE services
<P><B>Syntax&#58;</B> <TT>ENABLE SERVICES "PROCESS QUEUE"</TT>
<P><LI><B>Goal&#58;</B> Enable tracing for all services
<P><B>Syntax&#58;</B> <TT>ENABLE ALL SERVICES</TT>
<P><LI><B>Goal&#58;</B> Enable tracing for all services and tracepoints
<P><B>Syntax&#58;</B> <TT>ENABLE ALL</TT>
<P><LI><B>Goal&#58;</B> Enable tracing for the VAR service
<P><B>Syntax&#58;</B> <TT>ENABLE SERVICE VAR</TT>
<P><LI><B>Goal&#58;</B> Enable tracing for the SERVICE service
<P><B>Syntax&#58;</B> <TT>ENABLE SERVICE &#58;7&#58;SERVICE</TT>
</UL>
<A NAME="IDX632"></A>
<A NAME="IDX634"></A>
<P><H3><A NAME="HDRTRACESRVDISABLE">8.19.4 Disable</A></H3>
<P>DISABLE allows you to disable trace points and STAF services for tracing.
See table <A HREF="#HDRTRACEPOINTREF">8.19.2, "Trace Points Reference"</A> for a list of valid trace points.
<P><H4><A NAME="Header_853">Syntax</A></H4>
<PRE>
DISABLE ALL  [ TRACEPOINTS | SERVICES ]
DISABLE TRACEPOINTS &lt;Trace point list&gt; | SERVICES &lt;Service list&gt;
DISABLE TRACEPOINT &lt;Trace point&gt; [ TRACEPOINT &lt;Trace point&gt; ]...
DISABLE SERVICE &lt;Service&gt; [ SERVICE &lt;Service&gt; ]...
</PRE>
<P><TT>ALL</TT> indicates to disable tracing for all trace points and/or services
<P><TT>TRACEPOINTS</TT> indicates a list of trace points to be disabled for tracing.
The trace points in the list should be separated by spaces.  This option will resolve variables.
<P><TT>SERVICES</TT> indicates a list of services to be disabled for tracing.
The services in the list should be separated by spaces.  This option will resolve variables.
<P><TT>TRACEPOINT</TT> indicates which trace point should be disabled for tracing. This option will resolve variables.
<P><TT>SERVICE</TT> indicates which service should be disabled for tracing. This option will resolve variables.
<P><H4><A NAME="Header_854">Security</A></H4>
<P>This command requires trust level 5.
<P><H4><A NAME="Header_855">Return Codes</A></H4>
<P>All return codes from DISABLE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_856">Results</A></H4>
<P>For <TT>DISABLE</TT> the result buffer will be empty if there are no errors
<P><H4><A NAME="Header_857">Examples</A></H4>
<UL>
<P><LI><B>Goal&#58;</B> Disable the service access denied and error trace points
<P><B>Syntax&#58;</B> <TT>DISABLE TRACEPOINTS "ServiceAccessDenied Error"</TT>
<P><LI><B>Goal&#58;</B> Disable the service result and error trace points
<P><B>Syntax&#58;</B> <TT>DISABLE TRACEPOINTS "ServiceResult Error"</TT>
<P><LI><B>Goal&#58;</B> Disable all trace points
<P><B>Syntax&#58;</B> <TT>DISABLE ALL TRACEPOINTS</TT>
<P><LI><B>Goal&#58;</B> Disable tracing for remote requests
<P><B>Syntax&#58;</B> <TT>DISABLE TRACEPOINT RemoteRequests</TT>
<P><LI><B>Goal&#58;</B> Disable tracing only for the PROCESS and QUEUE services
<P><B>Syntax&#58;</B> <TT>DISABLE SERVICES "PROCESS QUEUE"</TT>
<P><LI><B>Goal&#58;</B> DISABLE tracing for all services
<P><B>Syntax&#58;</B> <TT>DISABLE ALL SERVICES</TT>
<P><LI><B>Goal&#58;</B> Disable tracing for all services and tracepoints
<P><B>Syntax&#58;</B> <TT>DISABLE ALL</TT>
<P><LI><B>Goal&#58;</B> Disable tracing for the VAR service
<P><B>Syntax&#58;</B> <TT>DISABLE SERVICE VAR</TT>
<P><LI><B>Goal&#58;</B> Disable tracing for the SERVICE service
<P><B>Syntax&#58;</B> <TT>DISABLE SERVICE &#58;7&#58;SERVICE</TT>
</UL>
<A NAME="IDX637"></A>
<A NAME="IDX639"></A>
<P><H3><A NAME="HDRTRACESRVPURGE">8.19.5 Purge</A></H3>
<P><TT>PURGE</TT> removes all unregistered services from the service list
<P><H4><A NAME="Header_859">Syntax</A></H4>
<PRE>
PURGE
</PRE>
<P><H4><A NAME="Header_860">Security</A></H4>
<P>This command requires trust level 5.
<P><H4><A NAME="Header_861">Return Codes</A></H4>
<P>All return codes from PURGE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_862">Results</A></H4>
<P>For <TT>PURGE</TT> the result buffer will be empty if there are no errors.
<P><H4><A NAME="Header_863">Examples</A></H4>
<UL>
<P><LI><B>Goal&#58;</B> Remove extra services from the trace list
<P><B>Syntax&#58;</B> <TT>PURGE</TT>
</UL>
<A NAME="IDX642"></A>
<A NAME="IDX644"></A>
<P><H3><A NAME="HDRTRACESRVLIST">8.19.6 List</A></H3>
<P><TT>LIST</TT> Returns a list of current settings including trace
destination and default service state, and a list of the current tracing
statuses for all tracepoints and services
<P><H4><A NAME="Header_865">Syntax</A></H4>
<PRE>
LIST &#91;SETTINGS&#93;
</PRE>
<P><H4><A NAME="Header_866">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_867">Return Codes</A></H4>
<P>All return codes from LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_868">Results</A></H4>
<P>
On successful return, the result buffer for a <TT>LIST</TT>
request will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Trace/TraceInfo&gt;</TT>
representing the current trace settings.
The maps are defined as follows:
<BR>
<P><B><A NAME="Table_98">Table 98. Definition of map class STAF/Service/Trace/TraceInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the current trace settings.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="43%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">tracingTo
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Tracing To
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="43%"><TT>&lt;String&gt;</TT> | <TT>&lt;List&gt; of &lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">fileMode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">File Mode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="43%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%"><TT>'Replace' | 'Append'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">defaultServiceState
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Default Service State
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="43%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">maxServiceResultSize
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Maximum Service Result Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="43%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">tracePoints
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Trace Points
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="43%"><TT>&lt;Map&#58;STAF/Service/Trace/Tracepoint&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">services
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Services
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="43%"><TT>&lt;Map&#58;STAF/Service/Trace/Service&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>"Tracing To" indicates the current trace output destination.
If there is only one trace output destination, it will be set to either
<TT>'Stdout'</TT>, <TT>'Stderr'</TT>, or the file name.
If there is more than one trace output destination, it will be set to
a marshalled <TT>&lt;List&gt; of &lt;String&gt;</TT> with the first entry containing
<TT>'Stdout'</TT> or <TT>'Stderr'</TT> and the second entry containing
the file name.
<LI>
If the current trace output destination is set to a file, "File Mode"
indicates whether the file will be replaced or appended to.  "File Mode"
will be set to &lt;None&gt; if the trace output destination is Stdout or Stderr.
</OL>
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_99">Table 99. Definition of map class STAF/Service/Trace/Tracepoint</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the tracepoints and their
trace states.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">INFO
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Info
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">WARNING
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Warning
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">ERROR
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">SERVICEREQUEST
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">ServiceRequest
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">SERVICERESULT
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">ServiceResult
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">SERVICEERROR
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">ServiceError
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">SERVICEACCESSDENIED
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">ServiceAccessDenied
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">REMOTEREQUESTS
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">RemoteRequests
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">REGISTRATION
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Registration
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">DEPRECATED
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Deprecated
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">DEBUG
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Debug
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR></TABLE>
<BR>
<P><B><A NAME="Table_100">Table 100. Definition of map class STAF/Service/Trace/Service</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the services and their
trace states.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="40%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;ServiceName&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;ServiceName&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="40%"><TT>'Enabled' | 'Disabled'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
This map is dynamically generated at the time of the <TT>LIST</TT> request
based on the services in the trace status list at that time.  It's keys
will be the names of the internal services plus any external services that
have been registered and any other services for which tracing has been
explicitly set.
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_869">Examples</A></H4>
<UL>
<P><LI><B>Goal&#58;</B> Display the current tracing information
<P><B>Syntax&#58;</B> <TT>LIST</TT> &nbsp;or&nbsp; <TT>LIST SETTINGS</TT>
<P><B>Results:</B>  If the request is issued from the command line,
the result, in verbose format, could look like:
<P>
<PRE>
{
  Tracing To                 : Stdout
  File Mode                  : &lt;None&gt;
  Default Service State      : Enabled
  Maximum Service Result Size: 0
  Trace Points               : {
    Info               : Disabled
    Warning            : Enabled
    Error              : Enabled
    ServiceRequest     : Disabled
    ServiceResult      : Disabled
    ServiceError       : Disabled
    ServiceAccessDenied: Disabled
    RemoteRequests     : Disabled
    Registration       : Disabled
    Deprecated         : Enabled
    Debug              : Disabled
  }
  Services                   : {
    DELAY   : Enabled
    DIAG    : Disabled
    ECHO    : Enabled
    EMAIL   : Enabled
    EVENT   : Enabled
    FS      : Enabled
    HANDLE  : Enabled
    HELP    : Disabled
    LOG     : Enabled
    MONITOR : Enabled
    MISC    : Enabled
    PING    : Enabled
    PROCESS : Enabled
    QUEUE   : Enabled
    SEM     : Enabled
    SERVICE : Enabled
    SHUTDOWN: Enabled
    STAX    : Enabled
    TRACE   : Enabled
    TRUST   : Enabled
    VAR     : Enabled
  }
}
</PRE>
</UL>
<A NAME="IDX647"></A>
<A NAME="IDX649"></A>
<P><H3><A NAME="HDRTRACESRVSET">8.19.7 Set</A></H3>
<P> Allows you to set the destination for the tracing
information, the default tracing state for new services, or the maximum size
(in characters) of the service result string to write to the trace output when
the ServiceResult tracepoint is enabled.
<P><H4><A NAME="Header_871">Syntax</A></H4>
<PRE>
SET DESTINATION TO &lt; [STDOUT | STDERR] [FILE &lt;File name&gt; [APPEND]] &gt;
SET DEFAULTSERVICESTATE &lt; Enabled | Disabled &gt;
SET MAXSERVICERESULTSIZE &lt;Number&gt;[k|m]
</PRE>
<P><TT>DESTINATION TO</TT> indicates to set the destination for the tracing
information.  Note that you must specify at least one of <TT>STDOUT</TT>,
<TT>STDERR</TT>, or <TT>FILE</TT>.  You can specify both
<TT>STDOUT</TT> and <TT>FILE</TT> or both <TT>STDERR</TT> and
<TT>FILE</TT>.
<P><TT>STDOUT</TT> indicates that trace messages should be sent to the
standard output device (Stdout).  Note that you can specify that trace
messages should be sent to both Stdout and a file.
<P><TT>STDERR</TT> indicates that trace messages should be sent to the
standard error device (Stderr).  Note that you can specify that trace
messages should be sent to both Stderr and a file.
<P><TT>FILE</TT> indicates that trace messages should be sent to the
indicated file.  Note that the path to the file must already exist. This option will resolve variables.
<P><TT>APPEND</TT> indicates that destination trace file will be appended
to if it exists.  If this option is not specified, the destination trace file
will be replaced if it exists.  This option can only be specified if the
<TT>FILE</TT> option was specified.
<P><TT>DEFAULTSERVICESTATE</TT> sets the default tracing state for services that have not yet
registered with STAF.  The default tracing state for services is enabled.  This option will resolve variables.
<P><TT>MAXSERVICERESULTSIZE</TT> specifies the maximum size (in characters)
 of the service result string to write to the trace output when
 the ServiceResult tracepoint is enabled.  If not specified, the
 default is 0 (which indicates to write the entire service result
 string to the trace output).  This value may be expressed in bytes, kilobytes,
 or megabytes. Its format is &lt;Number&gt;[k|m] where &lt;Number&gt; is an integer &gt;= 0 and
 indicates bytes unless one of the following case-insensitive suffixes is
 specified: k (for kilobytes) or m (for megabytes). The calculated value cannot
 exceed 4294967295 bytes. Examples of valid values include 100000, 500k, or 5m. 
<P><H4><A NAME="Header_872">Security</A></H4>
<P>This command requires trust level 5.
<P><H4><A NAME="Header_873">Return Codes</A></H4>
<P>All return codes from SET are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_874">Results</A></H4>
<P>For <TT>SET</TT> the result buffer will be empty
<P><H4><A NAME="Header_875">Examples</A></H4>
<UL>
<P><LI><B>Goal&#58;</B> Send trace output to the standard error device
<P><B>Syntax&#58;</B> <TT>SET DESTINATION TO STDERR</TT>
<P><LI><B>Goal&#58;</B> Send trace output to the file STAF.trc (which will
be replaced if it already exists) in the bin directory
under {STAF/Config/STAFRoot}
<P><B>Syntax&#58;</B> <TT>SET DESTINATION TO FILE {STAF/Config/STAFRoot}/bin/STAF.trc</TT>
<P><LI><B>Goal&#58;</B> Send trace output to the file STAF.trc (which will
be appended to if it already exists) in the bin directory
under {STAF/Config/STAFRoot}
<P><B>Syntax&#58;</B> <TT>SET DESTINATION TO FILE {STAF/Config/STAFRoot}/bin/STAF.trc APPEND</TT>
<P><LI><B>Goal&#58;</B> Send trace output to the standard output device and to file STAF.trc (which will
be replaced if it already exists) in the bin directory
under {STAF/Config/STAFRoot}
<P><B>Syntax&#58;</B> <TT>SET DESTINATION TO STDOUT FILE {STAF/Config/STAFRoot}/bin/STAF.trc</TT>
<P><LI><B>Goal&#58;</B> Set default tracing state to 'Enabled' for new services;
<P><B>Syntax&#58;</B> <TT>SET DEFAULTSERVICESTATE Enabled</TT>
<P><LI><B>Goal&#58;</B> Set the maximum size of the service result string to
write to the trace output when the ServiceResult tracepoint is enabled
to 5k characaters:
<P><B>Syntax&#58;</B> <TT>SET MAXSERVICERESULTSIZE 5k</TT>
</UL>
<P>
<A NAME="IDX650"></A>
<A NAME="IDX652"></A>
<HR><H2><A NAME="HDRTRUSTSRV" HREF="#ToC_876">8.20 Trust Service</A></H2>
<P><H3><A NAME="Header_877">8.20.1 Description</A></H3>
<P>The TRUST Service is one of the internal STAF services.  It allows you to
query and set the trust entries.  It provides the
following commands.
<UL COMPACT>
<LI>SET - Sets the trust level for a specific machine or user or a default trust level
<LI>GET - Retrieves the effective trust level for a given machine or user
<LI>LIST - Retrieves the default trust level and a list of the explicit
trust entries for machines and users
<LI>DELETE - Deletes a given trust entry for a machine or user
<LI>HELP &#45; Returns syntax information
</UL>
<A NAME="IDX655"></A>
<P><H3><A NAME="Header_878">8.20.2 SET</A></H3>
<P>SET will set the default trust level or the trust level for a specific
machine or user.
<P><H4><A NAME="Header_879">Syntax</A></H4>
<PRE>
SET &lt;MACHINE &lt;Machine&gt; | USER &lt;User&gt; | DEFAULT&gt; LEVEL &lt;Level&gt;
</PRE>
<P><TT>MACHINE</TT> indicates a machine for which to set a trust level.
This option will resolve variables.
The format for &lt;Machine&gt; is:
<PRE>
  &#91;&lt;Interface&gt;&#58;//&#93;&lt;System Identifier&gt;
</PRE>
where:
<UL COMPACT>
<LI><TT>&lt;Interface&gt;</TT> is the name of the network interface.
It is case-insensitive.
If the name of a network interface is not specified, wildcard '*' is
substituted which will match any network interface name.
<LI><TT>&lt;System Identifier&gt;</TT> is a valid network identifier for the network
interface.  It is case-insensitive.
Logical or physical identifiers may be specified for the system
identifier.  Physical identifiers are the lowest-level identifier
available via the specified network interface.  Logical identifiers are more
human readable identifiers that ultimately map to physical identifiers.
For example, for a TCP/IP interface, the physical identifier for a
machine is the IP address, while the logical identifier for a machine
is the hostname.
</UL>
<P>Note that you can specify match patterns (e.g. wild cards) in the
interface and the system identifier.  These patterns recognize two
special characters, '*' and '?', where '*' matches a string of
characters (including an empty string) and '?' matches any single
character (the empty string does not match).
<P>Note that if you specify the hostname in a trust specification
for a TCP/IP interface, you must specify the long host name
(and/or wildcards).
<P>Note that if you specify a port (e.g. @6500) at the end of the
system identifier, it will be removed.
<P>Requests coming from the local system will now appear as though
they came from an interface named "local" and a system identifier
of "local".  This allows you to specify a trust level for local
requests.  (In STAF V2.x, local requests were automatically granted
a trust level of 5.)
<P>
<TT>USER</TT> indicates a user for which to set a trust level.
This option will resolve variables.
The format for &lt;User&gt; is:
<PRE>
  &#91;&lt;Authenticator&gt;&#58;//&#93;&lt;User Identifier&gt;
</PRE>
where:
<UL COMPACT>
<LI><TT>&lt;Authenticator&gt;</TT> is the name of the authenticator.
It is case-insensitive.  If an authenticator is not specified, the default
authenticator is used.
<LI><TT>&lt;User Identifier&gt;</TT> is a valid user identifier for the authenticator.
It is case sensitive.
</UL>
<P>Note that you can specify match patterns in the authenticator name
and the user identifier.  These patterns recognize two special characters,
'*' and '?', where '*' matches a string of characters (including an
empty string) and '?' matches any single character (the empty string
does not match).
<P>
<TT>DEFAULT</TT> specifies that you want to set the default trust level.
<P>
<TT>LEVEL</TT> specifies the level of trust you wish to set.
This option will resolve variables.
<P>
<P><H4><A NAME="Header_880">Notes:</A></H4>
<OL COMPACT TYPE=1>
<LI>If multiple trust specifications match the same user,
STAF will rank the matching specifications as documented in
section <A HREF="#HDRUSERTRUSTMATCHING">"How to determine Effective Trust for a User"</A> and use the match with 
the highest (i.e. lowest numbered) rank.  If multiple trust
specifications match within the same rank, the lowest matching trust
level will be used.
<LI>If multiple trust specifications match the same system,
STAF will rank the matching specifications as documented in
section <A HREF="#HDRMACHINETRUSTMATCHING">"How to determine Effective Trust for a Machine"</A> and use the match with
the highest (i.e. lowest numbered) rank.  If multiple trust
specifications match within the same rank, the lowest matching trust
level will be used.
<LI>User trust specifications override machine trust specifications.
</OL>
<P>
<P><H4><A NAME="Header_881">Security</A></H4>
<P>This command requires trust level 5.
<P><H4><A NAME="Header_882">Return Codes</A></H4>
<P>All return codes from SET are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_883">Results</A></H4>
<P>The result buffer will contain no data on return from a SET command.
<P><H4><A NAME="Header_884">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Set the trust level for local requests to 5. 
<P><B>Syntax:</B>&nbsp; <TT>SET MACHINE local&#58;//local LEVEL 5</TT>
<P>
<P><LI><B>Goal:</B> Set the default trust level to 1.
<P><B>Syntax:</B>&nbsp; <TT>SET DEFAULT LEVEL 1</TT>
<P>
<P><LI><B>Goal:</B> Set the trust level to 5 for machine
*&#58;//client1.austin.ibm.com (e.g. a machine with host name
client1.austin.ibm.com using any network interface).
<P><B>Syntax:</B>&nbsp; <TT>SET MACHINE client1.austin.ibm.com LEVEL 5</TT>
<P>
<P><LI><B>Goal:</B> Set the trust level to 5 for machine *&#58;//93.224.16
(e.g. a machine with IP address 9.3.224.16 using any network interface).
<P><B>Syntax:</B>&nbsp; <TT>SET MACHINE 9.3.224.16 LEVEL 5</TT>
<P>
<P><LI><B>Goal:</B> Set the trust level to 4 for machine tcp&#58;mysystem.site.com
(e.g. a machine with host name mysystem.site.com using network interface tcp).
<P><B>Syntax:</B>&nbsp; <TT>SET MACHINE tcp&#58;//mysystem.site.com LEVEL 4</TT>
<P>
<P><LI><B>Goal:</B> Set the trust level to 0 for machine
*&#58;//badguy.austin.ibm.com (e.g. a machine with host name
badguy.austin.ibm.com using any network interface).
<P><B>Syntax:</B>&nbsp; <TT>SET MACHINE badguy.austin.ibm.com LEVEL 0</TT>
<P>
<P><LI><B>Goal:</B> Set the trust level to 3 for a group of machines
using network interface tcp2 and with IP addresses that begin
with "9.3.224.".
<P><B>Syntax:</B>&nbsp; <TT>SET MACHINE tcp2&#58;//9.3.224.* LEVEL 3</TT>
<P>
<P><LI><B>Goal:</B> Set the trust level to 2 for a group of machines
with host names that end with ".austin.ibm.com" using any network interface.
<P><B>Syntax:</B>&nbsp; <TT>SET MACHINE *.austin.ibm.com LEVEL 2</TT>
<P>
<P><LI><B>Goal:</B> Set the trust level to 2 for a group of machines
using a network interface that begins with tcp and with host names
that end with ".site.com".
<P><B>Syntax:</B>&nbsp; <TT>SET MACHINE tcp*&#58;//*.site.com LEVEL 2</TT>
<P>
<P><LI><B>Goal:</B> Set the trust level to 5 for a user whose
user identifier is John@company.com and uses the default authenticator.
<P><B>Syntax:</B>&nbsp; <TT>SET USER John@company.com LEVEL 5</TT>
<P>
<P><LI><B>Goal:</B> Set the trust level to 0 for a user whose
user identifier is badguy@company.com and uses the default authenticator.
<P><B>Syntax:</B>&nbsp; <TT>SET USER badguy@company.com LEVEL 0</TT>
<P>
<P><LI><B>Goal:</B> Set the trust level to 3 for a group of users
whose user identifiers end with "@company.com" and which use the
default authenticator.
<P><B>Syntax:</B>&nbsp; <TT>SET USER *@company.com LEVEL 3</TT>
<P>
<P><LI><B>Goal:</B> Set the trust level to 4 for a group of users
using an authenticator named SampleAuth and whose user identifiers end
with "@company.com".
<P><B>Syntax:</B>&nbsp; <TT>SET USER SampleAuth&#58;//*@company.com LEVEL 4</TT>
<P>
<P><LI><B>Goal:</B> Set the trust level to 1 for a group of users
using any authenticator (indicated by wildcard *) and any
user name (indicated by wildcard *).
<P><B>Syntax:</B>&nbsp; <TT>SET USER *&#58;//* LEVEL 1</TT>
</UL>
<A NAME="IDX658"></A>
<P><H3><A NAME="Header_885">8.20.3 GET</A></H3>
<P>GET will return the effective trust level of a specific machine
and, optionally, for a specific user.
<P><H4><A NAME="Header_886">Syntax</A></H4>
<PRE>
GET MACHINE &lt;Machine&gt; &#91;USER &lt;User&gt;&#93;
</PRE>
<P><TT>MACHINE</TT> specifies the machine for which to return the
effective trust level.
This option will resolve variables.
The format for &lt;Machine&gt; is:
<PRE>
  &#91;&lt;Interface&gt;&#58;//&#93;&lt;System Identifier&gt;
</PRE>
where:
<UL COMPACT>
<LI><TT>&lt;Interface&gt;</TT> is the name of the network interface.
It is case-insensitive.
If the name of a network interface is not specified, the default interface
is used.
<LI><TT>&lt;System Identifier&gt;</TT> is a valid network identifier for the network
interface.  It is case-insensitive.
Logical or physical identifiers may be specified for the system
identifier.  Physical identifiers are the lowest-level identifier
available via the specified network interface.  Logical identifiers are more
human readable identifiers that ultimately map to physical identifiers.
For example, for a TCP/IP interface, the physical identifier for a
machine is the IP address, while the logical identifier for a machine
is the hostname.
</UL>
<P>
Wildcard patterns, '*' and '?', should not be specified.
If a port is included (e.g. @6500) at the end of the machine
value, it will be removed.
<P>
If the machine has a matching <TT>MACHINE</TT> trust entry,
the effective trust level is the level specified in the
<TT>MACHINE</TT> trust entry.  Otherwise, the effective trust
level is the default trust level.
<P><TT>USER</TT> specifies the user for which to return the effective
trust level.
This option will resolve variables.
The format for &lt;User&gt; is:
<PRE>
  &#91;&lt;Authenticator&gt;&#58;//&#93;&lt;User Identifier&gt;
</PRE>
where:
<UL COMPACT>
<LI><TT>&lt;Authenticator&gt;</TT> is the name of the authenticator.
It is case-insensitive.  If an authenticator is not specified, the default
authenticator is used.
<LI><TT>&lt;User Identifier&gt;</TT> is a valid user identifier for the authenticator.
It is case sensitive.
</UL>
<P>
Wildcard patterns, '*' and '?', cannot be specified.
<P>If the user has a matching <TT>USER</TT> trust entry,
the effective trust level is the level specified in the 
<TT>USER</TT> trust entry.  Otherwise, if the machine has a
matching <TT>MACHINE</TT> trust entry, the effective trust
level is the level specified in the <TT>MACHINE</TT> trust
entry.  Otherwise, the effective trust level is the default
trust level.
<P><H4><A NAME="Header_887">Notes:</A></H4>
<OL COMPACT TYPE=1>
<LI>If multiple trust specifications match the same user,
STAF will rank the matching specifications as documented in
section <A HREF="#HDRUSERTRUSTMATCHING">"How to determine Effective Trust for a User"</A> and use the match with 
the highest (i.e. lowest numbered) rank.  If multiple trust
specifications match within the same rank, the lowest matching trust
level will be used.
<LI>If multiple trust specifications match the same system,
STAF will rank the matching specifications as documented in
section <A HREF="#HDRMACHINETRUSTMATCHING">"How to determine Effective Trust for a Machine"</A> and use the match with
the highest (i.e. lowest numbered) rank.  If multiple trust
specifications match within the same rank, the lowest matching trust
level will be used.
<LI>User trust specifications override machine trust specifications.
</OL>
<P>
<P><H4><A NAME="Header_888">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_889">Return Codes</A></H4>
<P>All return codes from GET are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_890">Results</A></H4>
<P>The result buffer will contain the effective trust level of the given
machine.
<P>
<P><H4><A NAME="Header_891">Examples</A></H4>
<P>For the following examples, assume the trust entries for machines and
users are as follows with tcp as the default network interface and SampleAuth as
the default authenticator:
<PRE>
Type    Entry                         Trust Level
------- ----------------------------- -----------
Default &lt;None&gt;                        1
Machine *&#58;//*.austin.ibm.com          2
Machine *&#58;//client1.austin.ibm.com    5
Machine *&#58;//client3.austin.ibm.com    3
Machine local&#58;//local                 5
Machine tcp&#58;//client2.austin.ibm.com  0
User    SampleAuth&#58;//*@company.com    3
User    SampleAuth&#58;//Jane@company.com 4
User    SampleAuth&#58;//John@company.com 5
</PRE>
<P>
<P>Here are some <TT>GET</TT> requests and their results:
<P>
<PRE>
Request:  GET MACHINE client1.austin.ibm.com
Result :  5
</PRE>
<P>
<PRE>
Request:  GET MACHINE tcp&#58;//client2.austin.ibm.com
Result :  0
</PRE>
<P>
<PRE>
Request:  GET MACHINE client3.austin.ibm.com
Result :  3
</PRE>
<P>
<PRE>
Request:  GET MACHINE client4.austin.ibm.com
Result    2
</PRE>
<P>
<PRE>
Request:  GET MACHINE server1.raleigh.ibm.com
Result:   1
</PRE>
<P>
<PRE>
Request:  GET USER John@company.com MACHINE client3.austin.ibm.com
Result :  5
</PRE>
<P>
<PRE>
Request:  GET USER SampleAuth&#58;//Jane@company.com MACHINE client1.austin.ibm.com
Result :  4
</PRE>
<P>
<PRE>
Request:  GET USER Henry@company.com MACHINE client1.austin.ibm.com
Result :  3
</PRE>
<P>
<PRE>
Request:  GET USER Sally@mybusiness.com MACHINE client1.austin.ibm.com
Result :  5
</PRE>
<P>
<PRE>
Request:  GET USER Sally@mybusiness.com MACHINE server1.raleigh.ibm.com
Result :  1
</PRE>
<A NAME="IDX661"></A>
<P><H3><A NAME="Header_892">8.20.4 LIST</A></H3>
<P>LIST will return the default trust level and a list of the trust entries
for machines and users.
<P>
<P><H4><A NAME="Header_893">Syntax</A></H4>
<PRE>
LIST
</PRE>
<P>
<P><H4><A NAME="Header_894">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_895">Return Codes</A></H4>
<P>All return codes from LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_896">Results</A></H4>
<P>
The result buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Trust/Entry&gt;</TT>, representing
all the trust entries.  The first trust entry in the list will be for
the default trust entry, followed by trust entries for machines,
and then followed by trust entries for users.
The map is defined as follows:
<BR>
<P><B><A NAME="Table_101">Table 101. Definition of map class STAF/Service/Trust/Entry</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a trust entry.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Type
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>'Default' | 'Machine' | 'User'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">entry
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Entry
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT> | <TT>&lt;None&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>&lt;Machine Spec&gt; | &lt;User Spec)</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">trustLevel
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Trust Level
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%"><TT>'0' - '5'</TT>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The value for "Entry" will be <TT>&lt;None&gt;</TT> for the default trust entry.
<LI>Each trust entry for a machine, aka <TT>&lt;Machine Spec&gt;</TT>, has
the following format:
<BR>
<TT>&lt;Interface&gt;&#58;//&lt;System Identifier&gt;</TT>
<LI>Each trust entry for a user, aka <TT>&lt;User Spec&gt;</TT>, has the
following format:
<BR>
<TT>&lt;Authenticator&gt;&#58;//&lt;User Identifier&gt;</TT>
</OL>
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_897">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Retrieve the list of all trust entries.
<P><B>Syntax:</B>&nbsp; <TT>LIST</TT>
<P><B>Result:</B>  If the request is submitted from the command line,
the result, in table format, could look like:
<PRE>
Type    Entry                         Trust Level
------- ----------------------------- -----------
Default &lt;None&gt;                        1
Machine *&#58;//*.austin.ibm.com          2
Machine *&#58;//9.31.73.14*               3
Machine *&#58;//9.31.73.147               5
Machine *&#58;//client1.austin.ibm.com    5
Machine *&#58;//client3.austin.ibm.com    3
Machine local&#58;//local                 5
Machine tcp&#58;//client2.austin.ibm.com  0
User    SampleAuth&#58;//*@company.com    3
User    SampleAuth&#58;//Jane@company.com 4
User    SampleAuth&#58;//John@company.com 5
</PRE>
</UL>
<A NAME="IDX664"></A>
<P><H3><A NAME="Header_898">8.20.5 DELETE</A></H3>
<P>DELETE will remove the explicit trust entry for the specified machine
or user.
<P><H4><A NAME="Header_899">Syntax</A></H4>
<PRE>
DELETE MACHINE &lt;Machine&gt; | USER &lt;User&gt;
</PRE>
<P><TT>MACHINE</TT> specifies the machine for which you wish to delete the
specific trust entry.
This option will resolve variables.
The format for &lt;Machine&gt; is:
<PRE>
  &#91;&lt;Interface&gt;&#58;//&#93;&lt;System Identifier&gt;
</PRE>
where:
<UL COMPACT>
<LI><TT>&lt;Interface&gt;</TT> is the name of the network interface.
It is case-insensitive.
If the name of a network interface is not specified, wildcard '*' is
substituted.
<LI><TT>&lt;System Identifier&gt;</TT> is a valid network identifier for the network
interface.  It is case-insensitive.
</UL>
<P>
If a port is included (e.g. @6500) at the end of the machine
value, it will be removed.
<P>
<TT>USER</TT> specifies the user for which you wish to delete the
specific trust entry.
This option will resolve variables.
The format for &lt;User&gt; is:
<PRE>
  &#91;&lt;Authenticator&gt;&#58;//&#93;&lt;User Identifier&gt;
</PRE>
where:
<UL COMPACT>
<LI><TT>&lt;Authenticator&gt;</TT> is the name of the authenticator.
It is case-insensitive.  If an authenticator is not specified, the default
authenticator is used.
<LI><TT>&lt;User Identifier&gt;</TT> is a valid user identifier for the authenticator.
It is case sensitive.
</UL>
<P>
<P><H4><A NAME="Header_900">Security</A></H4>
<P>This command requires trust level 5.
<P>
<P><H4><A NAME="Header_901">Return Codes</A></H4>
<P>All return codes from DELETE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_902">Results</A></H4>
<P>The result buffer will contain no data on return from a DELETE command.
<P>
<P><H4><A NAME="Header_903">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Delete the trust entry for machine *&#58;//client1.austin.ibm.com
<P><B>Syntax:</B>&nbsp; <TT>DELETE MACHINE client1.austin.ibm.com</TT>
<P>
<P><LI><B>Goal:</B> Delete the trust entry for machine tcp&#58;//mysystem.site.com.
<P><B>Syntax:</B>&nbsp; <TT>DELETE MACHINE tcp&#58;//mysystem.site.com</TT>
<P>
<P><LI><B>Goal:</B> Delete the trust entry for machine *&#58;//9.3.224.82
<P><B>Syntax:</B>&nbsp; <TT>DELETE MACHINE 9.3.224.82</TT>
<P>
<P><LI><B>Goal:</B> Delete the trust entry for machine *&#58;//*.austin.ibm.com
<P><B>Syntax:</B>&nbsp; <TT>DELETE MACHINE *.austin.ibm.com</TT>
<P>
<P><LI><B>Goal:</B> Delete the trust entry for user SampleAuth&#58;//John@company.com
(assuming SampleAuth is the default authenticator).
<P><B>Syntax:</B>&nbsp; <TT>DELETE USER John@company.com</TT>
<P>
<P><LI><B>Goal:</B> Delete the trust entry for user "SampleAuth&#58;//*@company.com"
(assuming SampleAuth is the default authenticator).
<P><B>Syntax:</B>&nbsp; <TT>DELETE USER *@company.com</TT>
<P>
<P><LI><B>Goal:</B> Delete the trust entry for user "Auth2&#58;//Mary"
<P><B>Syntax:</B>&nbsp; <TT>DELETE USER Auth2&#58;//Mary</TT>
<P>
<P><LI><B>Goal:</B> Delete the trust entry for user "*&#58;//*"
<P><B>Syntax:</B>&nbsp; <TT>DELETE USER *&#58;//*</TT>
</UL>
<P>
<A NAME="IDX665"></A>
<A NAME="IDX667"></A>
<HR><H2><A NAME="HDRVARSERVICE" HREF="#ToC_904">8.21 Variable (VAR) Service</A></H2>
<P><H3><A NAME="Header_905">8.21.1 Description</A></H3>
<P>The Variable Service, called VAR, is one of the internal STAF services.  It
allows you to manage the system, shared, and per-process variable pools.  It provides
the following commands.
<UL COMPACT>
<LI>SET - Sets the value of one or more variables
<LI>GET - Retrieves the value of a given variable
<LI>LIST - Retrieves a list of all the variables and their associated values for
a given variable pool
<LI>RESOLVE - Resolves the values of all variables in one or more strings
<LI>DELETE - Deletes one or more variables
<LI>HELP &#45; Returns syntax information
</UL>
<A NAME="IDX670"></A>
<P><H3><A NAME="Header_906">8.21.2 SET</A></H3>
<P>SET will set a variable to a certain value.  The variable is created if it
does not exist.
<P>Note that you may SET multiple variables with a single request.
<P><H4><A NAME="Header_907">Syntax</A></H4>
<PRE>
SET &#91;SYSTEM | SHARED | HANDLE &lt;Handle&gt;&#93; &#91;FAILIFEXISTS&#93;
    VAR &lt;Name=Value&gt; &#91;VAR &lt;Name=Value&gt;&#93;...
</PRE>
<P><TT>SYSTEM</TT> specifies that you want to set the value of the variable
in the system variable pool.
<P><TT>SHARED</TT> specifies that you want to set the value of the variable
in the shared variable pool.
<P><TT>HANDLE</TT> indicates that you want to set the value of the variable
in the variable pool associated with the specified handle.
<P>If options <TT>SYSTEM</TT>, <TT>SHARED</TT>, and <TT>HANDLE</TT> are
not specified, the variable will be set in the variable pool associated with the
handle of the process that submitted the request unless the request came from another
machine, in which case the variable will be set in the system variable pool.
<P><TT>FAILIFEXISTS</TT> specifies that the set request should fail with
return code 49 (Already Exists) if the variable already exists in the specified
variable pool and its current value will be returned in the result.
If this option is not specified and the variable already exists, the variable's
value will be updated.
<P><TT>VAR</TT> specifies the name of a variable and the value to which it
should be set.  Its format must be Name=Value.  You can specify this option
multiple times to set multiple variables.
<P>
<P><H4><A NAME="Header_908">Security</A></H4>
<P>This command requires trust level 3.
<P>
<P><H4><A NAME="Header_909">Return Codes</A></H4>
<P>All return codes from SET are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>If multiple variables are set via a single SET request and all variables
were set successfully, the return code will be 0.  If one or more variables
were not set successfully, the return code will be set to the return code
of the first variable that could not be set successfully.  Note that all
variables specified will be attempted to be set.
<P>
<P><H4><A NAME="Header_910">Results</A></H4>
<P>
If successful, the result buffer will contain no data.
<P>
If the request failed, the result buffer's contents are based on whether
the <TT>VAR</TT> option was specified once or multiple times as follows:
<UL>
<P><LI>If only one variable is specified to be set:
<UL COMPACT>
<LI>If the request failed because the <TT>FAILIFEXISTS</TT> option
was specified and the variable already exists, the return code will be 49
(Already Exists) and the result buffer will contain the variable's value.
<LI>If the request failed for another reason, the result buffer may contain
additional information about the error.
</UL>
<P>
<P><LI>If multiple variables are specified to be set:
<UL COMPACT>
<LI>If the request failed before it was able to set any variables (e.g. due
to a request syntax error, insufficient trust, etc), the result buffer may
contain additional information about the error.
<LI>Otherwise, the result buffer will contain a marshalled <TT>&lt;List&gt; of
&lt;Map&#58;STAF/Service/Var/ErrorInfo&gt;</TT> representing a list of the
variable names and whether they were successfully set or not.  The entries
in the list will be in the same order that the variables to be set are
specified.  The map is defined as follows: 
<BR>
<P><B><A NAME="Table_102">Table 102. Definition of map class STAF/Service/Var/ErrorInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information on whether
a variable was successfully set.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">RC
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<P>If a variable is set successfully, its "RC" value will be '0' and its
"Result" will be blank.  If a variable is not set successfully because the
<TT>FAILIFEXISTS</TT> option was specified and the variable already exists,
its "RC" value will be '49' (Already Exists) and its "Result" will contain
the variable's value.  Otherwise, if another error occurred setting the
variable, its "RC" value will contain the error return code and its "Result"
may contain additional information about the error,
</TD></TR></TABLE>
</UL>
</UL>
<P>
<P><H4><A NAME="Header_911">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Set the system WebServer variable to testsrv1.test.austin.ibm.com
<BR>
<B>Request:</B>&nbsp; <TT>SET SYSTEM VAR WebServer=testsrv1.test.austin.ibm.com</TT>
<P>
<P><LI><B>Goal:</B> Set the shared TestDirectory variable to /tests
<BR>
<B>Request:</B>&nbsp; <TT>SET SHARED VAR TestDirectory=/tests</TT>
<P>
<P><LI><B>Goal:</B> In the process local variable pool, set variable "Good String"
to "Command completed successfully", and set variable "Bad String" to "SYS3175"
<BR>
<B>Request:</B>&nbsp; <TT>SET VAR &#58;42&#58;Good String=Command completed successfully VAR "Bad String=SYS3175"</TT>
<P>
<P><LI><B>Goal:</B> Set the variable STAF/Service/Log/Mask to "FATAL ERROR
WARNING" in the variable pool associated with handle 37
<BR>
<B>Request:</B>&nbsp; <TT>SET HANDLE 37 VAR "STAF/Service/Log/Mask=FATAL ERROR WARNING"</TT>
<P>
<P><LI><B>Goal:</B> Set system variable MyApp/Done to "Yes" only if the variable
does not already exist.
<BR>
<B>Request:</B>&nbsp; <TT>SET SYSTEM FAILIFEXISTS VAR MyApp/Done=Yes</TT>
<P>
<P><LI><B>Goal:</B> Set multiple variables, MyApp/Build#=1099 and MyApp/Version=3.1.0,
in the system variable pool
<BR>
<B>Request:</B>&nbsp; <TT>SET SYSTEM VAR MyApp/Build#=1099 VAR MyApp/Version=3.1.0</TT>
</UL>
<A NAME="IDX673"></A>
<P><H3><A NAME="Header_912">8.21.3 GET</A></H3>
<P>GET will retrieve the value of a variable.
<P>
<P><B>Note: </B>You almost never want to use the GET command.  Instead, you should use
RESOLVE to retrieve the value of a variable.
<P><H4><A NAME="Header_913">Syntax</A></H4>
<PRE>
GET &#91;SYSTEM | SHARED | HANDLE &lt;Handle&gt;&#93; VAR &lt;Name&gt;
</PRE>
<P><TT>SYSTEM</TT> specifies that you want to get the value of the variable
from the system variable pool.
<P><TT>SHARED</TT> specifies that you want to get the value of the variable
from the shared variable pool.
<P><TT>HANDLE</TT> indicates that you want to get the value of the variable
from the variable pool associated with the specified handle.
<P>If options <TT>SYSTEM</TT>, <TT>SHARED</TT>, and <TT>HANDLE</TT> are
not specified, the value of the variable will be retrieved from the variable
pool associated with the handle of the process that submitted the request
unless the request came from another machine, in which case the variable will
be retrieved from the system variable pool.
<P><TT>VAR</TT> specifies the name of the variable whose value you want to get.
<P><H4><A NAME="Header_914">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_915">Return Codes</A></H4>
<P>All return codes from GET are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_916">Results</A></H4>
<P>The result buffer will contain the value of the variable.
<P><H4><A NAME="Header_917">Examples</A></H4>
<P>
<UL>
<P><LI>Goal&#58; Get the value of the variable WebServer from the system
variable pool
<BR>
<B>Request:</B>&nbsp; <TT>GET SYSTEM VAR WebServer</TT>
<P>
<P><LI>Goal&#58; Get the value of the varible TestDirectory from the shared
variable pool
<BR>
<B>Request:</B>&nbsp; <TT>GET SHARED VAR TestDirectory</TT>
<P>
<P><LI>Goal&#58; Get the value of the variable "Good String" from the process
local variable pool
<BR>
<B>Request:</B>&nbsp; <TT>GET VAR "Good String"</TT>
<P>
<P><LI>Goal&#58; Get the value of the variable ConfigData from the variable pool
associated with handle 59
<BR>
<B>Request:</B>&nbsp; <TT>GET HANDLE 59 VAR ConfigData</TT>
</UL>
<A NAME="IDX676"></A>
<P><H3><A NAME="Header_918">8.21.4 LIST</A></H3>
<P>LIST will return a list of all variables and their values.
<P><H4><A NAME="Header_919">Syntax</A></H4>
<PRE>
LIST &#91;SYSTEM | SHARED | HANDLE &lt;Handle&gt; | ASHANDLE &lt;Handle&gt; | REQUEST &#91;&lt;Number&gt;&#93;&#93;
</PRE>
<P><TT>SYSTEM</TT> specifies that you want the list of variables from the
system variable pool only.
<P><TT>SHARED</TT> specifies that you want the list of variables from the
shared variable pool only.
<P><TT>HANDLE</TT> specifies that you want the list of variables from the 
handle variable pool only.
<P><TT>ASHANDLE</TT> indicates that you want the list of a merged set of 
variables from the specified handle's variable pool, its system's shared 
variable pool, and its system's system variable pool. Variables in a pool 
earlier in the list override variables in a pool later in the list.
<P><TT>REQUEST</TT> with a request number indicates that you want a list of a merged set 
of variables which will use variables from the originating handle's pool associated with the 
request number, the originating system's shared pool, the local system's shared pool, and the 
local system's system pool if the request came from remote; otherwise, will use the originating 
handle's pool associated with the request number, the local system's shared pool, and the local 
system's system pool if the request came from local. Variables in a pool earlier in the list 
override variables in a pool later in the list. 
<P>If a LIST REQUEST request is made without specifying a request number, the list is 
constructed in the context of the LIST REQUEST request, itself.
<P>If a LIST request is made without specifying <TT>SYSTEM</TT>, <TT>SHARED</TT>, 
<TT>HANDLE</TT>, <TT>ASHANDLE</TT>, and <TT>REQUEST</TT>, the behavior will be 
identical to a LIST REQUEST request being made with no request number specified.
<P><H4><A NAME="Header_920">Security</A></H4>
<P>This command requires trust level 2.
<P><H4><A NAME="Header_921">Return Codes</A></H4>
<P>All return codes from LIST are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P><H4><A NAME="Header_922">Results</A></H4>
<P>The result buffer will contain a marshalled
<TT>&lt;Map&#58;STAF/Service/Var/VarInfo&gt;</TT> with an entry for each variable.
The map is defined as follows: 
<BR>
<P><B><A NAME="Table_103">Table 103. Definition of map class STAF/Service/Var/VarInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents the variables.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">&lt;Variable Name&gt;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">&lt;Variable Name&gt;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
This map is dynamically generated with the key being a variable name and the
value being the value for the variable.
</TD></TR></TABLE>
<P>
If the request is submitted from the command line, the result,  
in default format, could look like:
<PRE>
Bad String                      : SYS3175
Good String                     : Command completed successfully
STAF/Config/BootDrive           : C:
STAF/Config/CodePage            : IBM-437
STAF/Config/ConfigFile          : C:\staf\bin\STAF.cfg
STAF/Config/DefaultAuthenticator: AuthSample
STAF/Config/DefaultInterface    : tcp
STAF/Config/InstanceName        : STAF
STAF/Config/Machine             : client1.company.com
STAF/Config/MachineNickname     : client1
STAF/Config/Mem/Physical/Bytes  : 804175872
STAF/Config/Mem/Physical/KB     : 785328
STAF/Config/Mem/Physical/MB     : 766
STAF/Config/OS/MajorVersion     : 5
STAF/Config/OS/MinorVersion     : 0
STAF/Config/OS/Name             : Win2000
STAF/Config/OS/Revision         : 2195
STAF/Config/Processor/NumAvail  : 1
STAF/Config/Sep/Command         : & 
STAF/Config/Sep/File            : \
STAF/Config/Sep/Line            :
 
STAF/Config/Sep/Path            : ;
STAF/Config/STAFRoot            : C:\STAF
STAF/Config/StartupTime         : 20080421-14:15:37
STAF/DataDir                    : C:\STAF\data\STAF
STAF/Env/ALLUSERSPROFILE        : C:\Documents and Settings\All Users
STAF/Env/APPDATA                : C:\Documents and Settings\Administrator\Application Data
STAF/Env/CLASSPATH              : .;C:\STAF\lib\JSTAF.jar
STAF/Env/CommonProgramFiles     : C:\Program Files\Common Files
STAF/Env/COMPUTERNAME           : CLIENT1
STAF/Env/ComSpec                : C:\WINNT\system32\cmd.exe
STAF/Env/CVS_RSH                : ssh
STAF/Env/HOMEDRIVE              : C:
STAF/Env/HOMEPATH               : \Documents and Settings\Administrator
STAF/Env/INCLUDE                : C:\Program Files\ObjREXX\API
STAF/Env/LIB                    : C:\Program Files\ObjREXX\API
STAF/Env/LOGONSERVER            : \\CLIENT1
STAF/Env/NUMBER_OF_PROCESSORS   : 1
STAF/Env/OS                     : Windows_NT
STAF/Env/Os2LibPath             : C:\WINNT\system32\os2\dll;
STAF/Env/Path                   : C:\ibmjdk1.4.2\bin;C:\STAF\bin;C:\WINNT\system32;C:\WINNT;C:\WINNT\System32\Wbem;C:\cygwin\bin;
STAF/Env/PATHEXT                : .COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.RB;.RBW
STAF/Env/PD_SOCKET              : 6874
STAF/Env/PDBASE                 : C:\PROGRA~1\IBM\INFOPR~1
STAF/Env/PDHOST                 :
STAF/Env/PROCESSOR_ARCHITECTURE : x86
STAF/Env/PROCESSOR_IDENTIFIER   : x86 Family 15 Model 2 Stepping 7, GenuineIntel
 
STAF/Env/PROCESSOR_LEVEL        : 15
STAF/Env/PROCESSOR_REVISION     : 0207
STAF/Env/ProgramFiles           : C:\Program Files
STAF/Env/PROMPT                 : $P$G
STAF/Env/SOUNDPATH              : C:\WINNT
STAF/Env/SystemDrive            : C:
STAF/Env/SystemRoot             : C:\WINNT
STAF/Env/TEMP                   : C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp
STAF/Env/TMP                    : C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp
STAF/Env/USERDOMAIN             : CLIENT1
STAF/Env/USERNAME               : Administrator
STAF/Env/USERPROFILE            : C:\Documents and Settings\Administrator
STAF/Env/windir                 : C:\WINNT
STAF/Service/NC/Persist         : True
STAF/Version                    : 3.3.0
WebServer                       : testsrv1.test.austin.ibm.com
</PRE>
<P><H4><A NAME="Header_923">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Retrieve the list of system variables
<BR>
<B>Request:</B>&nbsp; <TT>LIST SYSTEM</TT>
<P>
<P><LI><B>Goal:</B> Retrieve the list of shared variables
<BR>
<B>Request:</B>&nbsp; <TT>LIST SHARED</TT>
<P>
<P><LI><B>Goal:</B> Retrieve the list of variables associated with handle 54
<BR>
<B>Request:</B>&nbsp; <TT>LIST HANDLE 54</TT>
<P>
<P><LI><B>Goal:</B> Retrieve the combined list of global variables and variables
associated with handle 62
<BR>
<B>Request:</B>&nbsp; <TT>LIST ASHANDLE 62</TT>
<P>
<P><LI><B>Goal:</B> Retrieve the combined list of variables from originating handle's 
pool associated with request number 48, the local system's shared pool, and the 
local system's system pool if the request came from local; otherwise, from the 
originating handle's pool associated with request number 48, the originating 
system's shared pool, the local system's shared pool, and the local system's 
system pool if the request came from remote.
<BR>
<B>Request:</B>&nbsp; <TT>LIST REQUEST 48</TT>
<P>
<P><LI><B>Goal:</B> Retrieve the combined list of variables from originating handle's 
pool associated with the current request's request number, the local system's 
shared pool, and the local system's system pool if the request came from local; 
otherwise, from the originating handle's pool associated with the current request's
request number, the originating system's shared pool, the local system's shared pool, 
and the local system's system pool if the request came from remote.
<BR>
<B>Request:</B>&nbsp; <TT>LIST REQUEST</TT>
<P>
<P><LI><B>Goal:</B> Retrieve the combined list of variables from originating handle's 
pool associated with the current request's request number, the local system's 
shared pool, and the local system's system pool if the request came from local; 
otherwise, from the originating handle's pool associated with the current request's
request number, the originating system's shared pool, the local system's shared pool, 
and the local system's system pool if the request came from remote.
<BR>
<B>Request:</B>&nbsp; <TT>LIST</TT>
</UL>
<A NAME="IDX679"></A>
<P><H3><A NAME="HDRVARRESOLVE">8.21.5 RESOLVE</A></H3>
<P>RESOLVE allows you to have all variable references in a string resolved to
their values. A variable reference is denoted by surrounding the variable in
curly braces, for example, {WebServer}.  Recursive and compound variable
references are allowed (see the examples).
<P>Note that you may RESOLVE multiple strings with a single request.
<P>
Because of this special significance of "{", if you do not want variable
substitution performed, use a caret, "^", as an escape character for "{"
and "^", or specify the IGNOREERRORS option.
Note that a caret cannot be used as an escape character within a variable reference
(see the examples).
<P>
<P><H4><A NAME="Header_925">Syntax</A></H4>
<PRE>
RESOLVE &#91;SYSTEM | SHARED | HANDLE &lt;Handle&gt; | ASHANDLE &lt;Handle&gt; | REQUEST &#91;&lt;Number&gt;&#93;&#93; 
        STRING &lt;String&gt; &#91;STRING &lt;String&gt;&#93;... [IGNOREERRORS]
</PRE>
<P><TT>SYSTEM</TT> specifies that only variables from the system variable
pool should be used to resolve a variable reference.
<P><TT>SHARED</TT> specifies that only variables from the shared variable
pool should be used to resolve a variable reference.
<P><TT>HANDLE</TT> specifies that only variables from the handle variable
pool should be used to resolve a variable reference. 
<P><TT>ASHANDLE</TT> indicates the variable reference should try to be resolved from
the specified handle's variable pool, its system's shared variable pool, and its 
system's system variable pool. Variables in a pool earlier in the list override 
variables in a pool later in the list.
<P><TT>REQUEST</TT> with a request number indicates the variable reference 
should try to be resolved from the originating handle's pool associated with 
the specified request number, the originating system's shared pool, the local 
system's shared pool, and the local system's system pool if the request came from 
remote; otherwise, will use the originating handle's pool associated with the 
specified request number, the local system's shared pool, and the local system's 
system pool if the request came from local. Variables in a pool earlier in the list 
override variables in a pool later in the list.
<P>If the <TT>REQUEST</TT> option is specified without specifying a request number,
variable resolution is done in the context of the RESOLVE request itself.
Also, if you don't specify the <TT>SYSTEM</TT>, <TT>SHARED</TT>, <TT>HANDLE</TT>,
<TT>ASHANDLE</TT>, or <TT>REQUEST</TT> option, the behavior will be the
same as when you specify the <TT>REQUEST</TT> option without specifiying a
request number.
<P><TT>STRING</TT> specifies a string that may contain one or more variable
references.
<P><TT>IGNOREERRORS</TT> specifies to not assume that every "{" in the
string being resolved denotes a reference to a STAF variable.
When using this option, you will not get a RC 13 (Variable Does Not Exist) or
RC 15 (Invalid Resolve String) error because:
<UL COMPACT>
<LI>if a "{" does not denote a reference to a STAF variable, it will be
left "as is" instead of returning RC 13, or
<LI>if a "{" has no matching closing "}", then it will be
left "as is" instead of returning RC 15.
</UL>
<P>
<P><H4><A NAME="Header_926">Security</A></H4>
<P>This command requires trust level 2.
<P>
<P><H4><A NAME="Header_927">Return Codes</A></H4>
<P>All return codes from RESOLVE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>
<P><H4><A NAME="Header_928">Results</A></H4>
<P>
<P>On successful return, the result buffer will contain results based on whether
the <TT>STRING</TT> option was specified once or multiple times:
<UL>
<P><LI>If only one string is specified to be resolved, the result buffer will contain the
input string with all variable references resolved.
<P>
<P><LI>If multiple strings are specified to be resolved, the result buffer will contain a
marshalled <TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Var/ResolveString&gt;</TT> representing
a list of the strings with all variable references resolved.
The entries in the list will be in the same order that the strings to be resolved
are specified.  The map is defined as follows: 
<BR>
<P><B><A NAME="Table_104">Table 104. Definition of map class STAF/Service/Var/ResolveString</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents a string with all variable references resolved.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">RC
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<P>If all variables in the string are resolved successfully, the "RC" value will
be '0' and the "Result" will contain the string with all variable references resolved.
Otherwise, if an error occurred resolving a string, the "RC" value will
contain the error return code and the result will contain additional information
on the error, such as the name of a variable that could not be resolved.
</TD></TR></TABLE>
</UL>
<P>
<P><H4><A NAME="Header_929">Examples</A></H4>
<P>
For the following examples, assume the following variables are in 
System1's system variable pool
<PRE>
a=Partridge
b=Doves
c=Hens
d=Birds
e=Rings
</PRE>
the following variables are in System1's shared variable pool
<PRE>
a=Happy
b=Sleepy
</PRE>
the following variables are in System1's originating handle variable pool 
<PRE>
a=One
</PRE>
the following variables are in System2's system variable pool
<PRE>
a=Geese
b=Swans
c=Maids
d=Ladies
e=Lords
</PRE>
the following variables are in System2's shared variable pool
<PRE>
d=Grumpy
e=Dopey
</PRE>
and the following variables are in the System1's variable pool associated with handle 71
<PRE>
a=Dogs 
b=Cats
</PRE>
Let's assume the following requests are done from System1:
<P>
<UL>
<P><LI><B>Request:</B>&nbsp; <TT>staf local var resolve string "{a} {b} {c} {d} {e}"</TT>
<BR>
<B>Result:</B>&nbsp; <TT>One Sleepy Hens Birds Two</TT>
<P><LI><B>Request:</B>&nbsp; <TT>staf System2 var resolve string "{a} {b} {c} {d} {e}"</TT>
<BR>
<B>Result:</B>&nbsp; <TT>One Sleepy Maids Grumpy Two</TT>
<P><LI><B>Request:</B>&nbsp; <TT>staf local var resolve ashandle 71 string "{a} {b} {c} {d} {e}"</TT>
<BR>
<B>Result:</B>&nbsp; <TT>Dogs Cats Hens Birds Two</TT>
</UL>
<P>
The following examples show the use of a caret (^) as an escape character
for "{" and "^".  Assume the following variables are in the
system variable pool for these examples:
<PRE>
h=Hi
Hi=HI
^Hi=Hello
</PRE>
<P>
<UL>
<P><LI><B>Request:</B>&nbsp; <TT>RESOLVE SYSTEM STRING "^{{h}, ^{{h}}, {{h}}, ^^{{h}}, and ^{^{h}}</TT>
<BR>
<B>Result:</B>&nbsp; <TT>{Hi, {Hi}, HI, ^HI, and {{h}}</TT>
<P>
<P><LI><B>Request:</B>&nbsp; <TT>RESOLVE SYSTEM STRING "{^{h}}"</TT>
<BR>
<B>Result:</B>&nbsp; <TT>Hello</TT>
</UL>
<P>
Note that {^{h}} shows that a caret cannot be used as an escape character within a
variable reference.
<P>
Here's an example of resolving multiple strings in a single RESOLVE request.
<UL>
<P><LI><B>Goal:</B> Resolve three different strings in a single <TT>RESOLVE</TT> request.
<BR>
<B>Request:</B>&nbsp; <TT>RESOLVE STRING {STAF/Version} STRING {aaa} STRING {STAF/Config/BootDrive}</TT>
<BR>
<B>Results:</B> If the request is submitted from the
command line, the result, in table format, could look like the following assuming no
variable named aaa exists:
<PRE> 
RC Result
-- ----------------------------------------------------------------------------
0  3.4.1
13 Variable resolution failed for string: {aaa}  You are trying to resolve a va
   riable that does not exist: aaa
0  C:
</PRE>
</UL>
<P>
Here's an example of using the IGNOREERRORS option on a VAR RESOLVE request:
<UL>
<P><LI><B>Goal:</B> Resolve a string that contains a "{" that does not denote
a reference to a variable,
<BR>
<B>Request:</B>  <TT>RESOLVE STRING "PythonMap = {'x': 1, 'osName': '{STAF/Config/OS/Name}'}"</TT>
<BR>
<B>Result:</B>  The result could look like the following if variable
STAF/Config/OS/Name has value "Linux":
<PRE>
PythonMap = {'x': 1, 'osName': 'Linux'}
</PRE>
<P>
If you did not use the IGNOREERRORS option, RC 13 (Variable Does Not Exist)
would have been returned as follows:
<PRE>
Error submitting request, RC: 13
Additional info
---------------
Variable resolution failed for string: PythonMap = {'x': 1, 'osName': '{STAF/Config/OS/Name}'}
 
You are trying to resolve a variable that does not exist: 'x': 1, 'osName': 'Linux'
</PRE>
</UL>
<P>
<A NAME="IDX682"></A>
<P><H3><A NAME="Header_930">8.21.6 DELETE</A></H3>
<P>DELETE will remove the given variable from the appropriate variable pool.
<P>Note that you may DELETE multiple variables with a single request.
<P><H4><A NAME="Header_931">Syntax</A></H4>
<PRE>
DELETE &#91;SYSTEM | SHARED | HANDLE &lt;Handle&gt;&#93; VAR &lt;Name&gt; &#91;VAR &lt;Name&gt;&#93;...
</PRE>
<P><TT>SYSTEM</TT> specifies that you want to delete the variable from the
system variable pool.
<P><TT>SHARED</TT> specifies that you want to delete the variable from the
shared variable pool.
<P><TT>HANDLE</TT> indicates that you want to delete the variable from the
variable pool associated with the specified handle.
<P>If options <TT>SYSTEM</TT>, <TT>SHARED</TT>, and <TT>HANDLE</TT> are
not specified, the variable will be deleted from the variable pool associated
with the handle of the process that submitted the request unless the request
came from another machine, in which case the variable will be deleted from the
system variable pool.
<P><TT>VAR</TT> specifies the name of the variable you want to delete.
<P>
<P><H4><A NAME="Header_932">Security</A></H4>
<P>This command requires trust level 3.
<P>
<P><H4><A NAME="Header_933">Return Codes</A></H4>
<P>All return codes from DELETE are documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>.
<P>If multiple variables are deleted via a single DELETE request and all
variables were deleted successfully, the return code will be 0.  If one or
more variables were not deleted successfully, the return code will be set
to the return code of the first variable that could not be deleted successfully.
Note that all variables specified will be attempted to be deleted.
<P>
<P><H4><A NAME="Header_934">Results</A></H4>
<P>
If successful, the result buffer will contain no data.
<P>
If the request failed, the result buffer's contents are based on whether
the <TT>VAR</TT> option was specified once or multiple times as follows:
<UL>
<P><LI>If only one variable is specified to be deleted, the result buffer
may contain additional information about the error.
<P>
<P><LI>If multiple variables are specified to be deleted:
<UL COMPACT>
<LI>If the request failed before it was able to delete any variables (e.g. due
to a request syntax error, insufficient trust, etc), the result buffer may
contain additional information about the error.
<LI>Otherwise, the result buffer will contain a marshalled <TT>&lt;List&gt; of
&lt;Map&#58;STAF/Service/Var/ErrorInfo&gt;</TT> representing a list of the
variable names and whether they were successfully deleted or not.  The entries
in the list will be in the same order that the variables to be deleted are
specified.  The map is defined as follows: 
<BR>
<P><B><A NAME="Table_105">Table 105. Definition of map class STAF/Service/Var/ErrorInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents information on whether
a variable was successfully deleted.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">rc
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">RC
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">Result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="25%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<P>If a variable is deleted successfully, its "RC" value will be '0' and its
"Result" will be blank.  If an error occurred deleting a variable, its "RC"
value will contain the error return code and its "Result" may contain
additional information about the error,
</TD></TR></TABLE>
</UL>
</UL>
<P>
<P><H4><A NAME="Header_935">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Delete the variable WebServer from the system variable pool.
<BR>
<B>Request:</B>&nbsp; <TT>DELETE SYSTEM VAR WebServer</TT>
<P>
<P><LI><B>Goal:</B> Delete the variable TestDirectory from the shared variable pool.
<BR>
<B>Request:</B>&nbsp; <TT>DELETE SHARED VAR TestDirectory</TT>
<P>
<P><LI><B>Goal:</B> Delete the variable "Bad String" from the process local variable pool.
<BR>
<B>Request:</B>&nbsp; <TT>DELETE VAR "Bad String"</TT>
<P>
<P><LI><B>Goal:</B> Delete the variable ConfigData from the variable pool associated
with handle 59
<BR>
<B>Request:</B>&nbsp; <TT>DELETE HANDLE 59 VAR ConfigData</TT>
<P>
<P><LI><B>Goal:</B> Delete the variables MyApp/Build# and MyApp/Version from
the system variable pool.
<BR>
<B>Request:</B>&nbsp; <TT>DELETE SYSTEM VAR MyApp/Build# VAR MyApp/Version</TT>
</UL>
<P>
<A NAME="IDX683"></A>
<A NAME="IDX685"></A>
<HR><H2><A NAME="HDRZIPSRV" HREF="#ToC_936">8.22 Zip Service</A></H2>
<P><H3><A NAME="Header_937">8.22.1 Description</A></H3>
The Zip service is an external STAF service that provides the following
functions:
<UL COMPACT>
<LI>UNZIP - Extract files/directories from a Zip archive
<LI>ADD (aka ZIP) - Add a file or directory into a Zip archive
<LI>DELETE - Delete files from Zip archive
<LI>LIST - List content of Zip archive
<LI>HELP &#45; Returns syntax information
</UL>
<P>The purpose of the Zip service is to allow a test case to easily work with Zip archives.
<P>By using of Zlib compression library, the Zip service can create, extract, delete and 
manage PKZip, WinZip and Jar compatible archives.
<P>The Zip service supports the following features: create / extract PKZip,
WinZip, and Jar compatible archives; save / restore owner, group and permission information
on files and directories; delete file(s) from a Zip archive; list content of a
Zip archive, append file / directory to an existing Zip archive, etc.
<A NAME="IDX687"></A>
<P><H3><A NAME="Header_938">8.22.2 Registration</A></H3>
The Zip service is an external service and must be registered with the SERVICE
configuration statement. The syntax is:
<PRE>
SERVICE <TT>&lt;Name&gt;</TT> LIBRARY STAFZip
</PRE>
<P><TT>&lt;Name&gt;</TT> is the name by which the Zip service will be known on this
machine.  The recommended name of the Zip service is "ZIP".
<P><H4><A NAME="Header_939">Example</A></H4>
<PRE>
service ZIP library STAFZip
</PRE>
<A NAME="IDX690"></A>
<P><H3><A NAME="HDRUNZIP">8.22.3 UNZIP</A></H3>
<P>Extract all entries (or specified files and/or directories) from a Zip
archive to a specified directory.
<P><H4><A NAME="Header_941">Syntax</A></H4>
<PRE>
UNZIP  ZIPFILE &lt;Name&gt; TODIRECTORY &lt;Name&gt;
       &#91;FILE &lt;Name&gt;&#93;... &#91;DIRECTORY &lt;Name&gt;&#93;...
       &#91;RESTOREPERMISSION&#93; &#91;REPLACE&#93;
</PRE>
<P><TT>ZIPFILE</TT> contains the fully qualified ZIP archive name.
<P><TT>TODIRECTORY</TT> contains the fully qualified output directory name.
<P><TT>FILE</TT> contains the fully qualified file name in the ZIP archive to be unzipped.
<P><TT>DIRECTORY</TT> contains the fully qualified directory name in the ZIP archive to be unzipped.
Subdirectories in the directory are recursively unzipped.
<P><TT>RESTOREPERMISSION</TT> indicates that the owner, group and permission
attributes of the file will be restored.
<P><TT>REPLACE</TT> indicates that the files/directories will be over written
they already exist in the specified output directory.
<P>
<P><B>Note: </B>If you specify multiple <TT>FILE</TT> and/or <TT>DIRECTORY</TT> options,
the files specified will be unzipped, followed by the directories specified.
If an error occurs while unzipping a file or directory, the unzip request will
not continue unzipping any remaining files/directories and will return an error.
<P>
<P><H4><A NAME="Header_942">Security</A></H4>
<P>This command requires trust level 4.
<P>
<P><H4><A NAME="Header_943">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
UNZIP also returns codes documented in <A HREF="#HDRZIPERR">8.22.7, "Zip Error Code Reference"</A>.
<P>
<P><H4><A NAME="Header_944">Results</A></H4>
<P>On a successful return, the result buffer will contain no data on return from a UNZIP command.
<P>
<P><H4><A NAME="Header_945">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Unzip all entries in archive myzip.zip to directory D:/mydata
<P><B>Syntax:</B>&nbsp; <TT>UNZIP ZIPFILE /opt/myzip.zip TODIRECTORY D:/mydata/</TT>
<P>
<P><LI><B>Goal:</B> Unzip file myjava/Hello.java from myzip.zip to
directory /usr/lpp/mydata, restoring permissions and replacing any existing file:
<P><B>Syntax:</B>&nbsp; <TT>UNZIP ZIPFILE /opt/myzip.zip TODIRECTORY /usr/lpp/mydata/ FILE myjava/Hello.java RESTOREPERMISSION REPLACE</TT>
<P>
<P><LI><B>Goal:</B> Unzip directory stax/docs from archive C:\temp\STAXV302.zip to
directory {STAF/Config/STAFRoot}/services:
<P><B>Syntax:</B>&nbsp; <TT>UNZIP ZIPFILE C:/temp/STAXV302.zip TODIRECTORY {STAF/Config/STAFRoot}/services DIRECTORY stax/docs</TT>
<P>
<P><LI><B>Goal:</B> Unzip two files (stax/STAX.jar and stax/STAFEvent.jar) and
two directories (stax/libraries and stax/samples) from archive C:\temp\STAXV302.zip to
directory C:\STAF\services and replace any existing files/directories:
<P><B>Syntax:</B>&nbsp; <TT>UNZIP ZIPFILE C:/temp/STAXV302.zip TODIRECTORY C:/STAF/services FILE stax/STAX.jar FILE stax/STAFEvent.jar DIRECTORY stax/libraries DIRECTORY stax/samples REPLACE</TT>
</UL>
<A NAME="IDX693"></A>
<P><H3><A NAME="Header_946">8.22.4 ADD (aka ZIP)</A></H3>
Adds a file or directory into a Zip archive file. If the Zip archive file does
not exist, it will be created and the file or directory will be added to it.
If the Zip archive file already exists, the file or directory will be added to it.
<P><H4><A NAME="Header_947">Syntax</A></H4>
<PRE>
ADD ZIPFILE &lt;Name&gt; &lt; FILE &lt;Name&gt; | DIRECTORY &lt;Name&gt; &#91;RECURSE&#93; &gt;
    &#91;RELATIVETO &lt;Directory&gt;&#93;
</PRE>    
or
<PRE>
ZIP ADD ZIPFILE &lt;Name&gt; &lt; FILE &lt;Name&gt; | DIRECTORY &lt;Name&gt; &#91;RECURSE&#93; &gt;
    &#91;RELATIVETO &lt;Directory&gt;&#93;
</PRE>
<P>
An <TT>ADD</TT> request performs the same function as a <TT>ZIP</TT> request.
An <TT>ADD</TT> request is preferred.  The <TT>ZIP</TT> request is deprecated
and will generate a trace message with a Deprecated tracepoint.
<P><TT>ZIPFILE</TT> contains the fully qualified name of a Zip archive file.
If the Zip archive file does not exist, it will be created, but the directory
path specified for it must already exist.
<P><TT>FILE</TT> contains the fully qualified file name you want to add into
the ZIP archive.
<P><TT>DIRECTORY</TT> contains the fully qualified directory name you want to
add into the ZIP archive.
<P><TT>RELATIVETO</TT> contains the prefix to be excluded from the fully
qualified file name or directory name that is to be added into the ZIP archive.
<P><TT>RECURSE</TT> indicates that the all the files and subdirectories in the
given directory will be added recursively.
<P><H4><A NAME="Header_948">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_949">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
Zip also returns codes documented in <A HREF="#HDRZIPERR">8.22.7, "Zip Error Code Reference"</A>.
<P><H4><A NAME="Header_950">Results</A></H4>
<P>On a successful return, the result buffer will contain no data on return from 
a ZIP command.
<P><H4><A NAME="Header_951">Examples</A></H4>
<UL>
<P><LI><B>Goal:</B> Add file C:/file.txt to Zip archive D:/myzip.zip.
<P><B>Syntax:</B>&nbsp; <TT>ADD ZIPFILE D:/myzip.zip FILE C:/file.txt</TT>
<P>
<P><LI><B>Goal:</B> Add directory /opt/mydir to Zip archive, relative to directory /opt.
<P><B>Syntax:</B>&nbsp; <TT>ADD ZIPFILE /myzip.zip DIRECTORY /opt/mydir RELATIVETO /opt</TT>
<P>
<P><LI><B>Goal:</B> Add directory /opt/mydir and all its subdirectories and files to Zip archive, 
relative to directory /opt.
<P><B>Syntax:</B>&nbsp; <TT>ADD ZIPFILE /myzip.zip DIRECTORY /opt/mydir RECURSE RELATIVETO /opt</TT>
</UL>
<A NAME="IDX696"></A>
<P><H3><A NAME="Header_952">8.22.5 DELETE</A></H3>
Delete one or more files from ZIP archive.
<P><H4><A NAME="Header_953">Syntax</A></H4>
<PRE>
DELETE ZIPFILE &lt;Name&gt; FILE &lt;Name&gt; &#91;FILE &lt;Name&gt;&#93;... CONFIRM
</PRE>
<P><TT>ZIPFILE</TT> contains the fully qualified ZIP archive name.
<P><TT>FILE</TT> contains the fully qualified file name to be deleted from the zip archive.
<P><TT>CONFIRM</TT> confirms you really want to delete the file from zip
archive.
<P><H4><A NAME="Header_954">Security</A></H4>
<P>This command requires trust level 4.
<P><H4><A NAME="Header_955">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
Delete also returns codes documented in <A HREF="#HDRZIPERR">8.22.7, "Zip Error Code Reference"</A>.
<P><H4><A NAME="Header_956">Results</A></H4>
<P>On a successful return, the result buffer will contain no data on return from a DELETE command.
<P><H4><A NAME="Header_957">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Delete file myjava/Hello.java from Zip archive D:/myzip.zip.
<P><B>Syntax:</B>&nbsp; <TT>DELETE ZIPFILE D:/myzip.zip FILE myjava/Hello.java CONFIRM</TT>
<P>
<P><LI><B>Goal:</B> Delete file myjava/Hello.java and bin/run from Zip archive /opt/myzip.zip.
<P><B>Syntax:</B>&nbsp; <TT>DELETE ZIPFILE /opt/myzip.zip FILE myjava/Hello.java FILE bin/run CONFIRM</TT>
</UL>
<A NAME="IDX699"></A>
<P><H3><A NAME="Header_958">8.22.6 LIST</A></H3>
List the content of a ZIP archive.
<P><H4><A NAME="Header_959">Syntax</A></H4>
<PRE>
LIST ZIPFILE &lt;Name&gt;
</PRE>
<P><TT>ZIPFILE</TT> contains the fully qualified ZIP archive name.
<P><H4><A NAME="Header_960">Security</A></H4>
<P>This command requires trust level 3.
<P><H4><A NAME="Header_961">Return Codes</A></H4>
<P>In addition to the return codes documented in <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A>,
LIST also returns codes documented in <A HREF="#HDRZIPERR">8.22.7, "Zip Error Code Reference"</A>
<P><H4><A NAME="Header_962">Results</A></H4>
<P>On successful return, the result buffer will contain a marshalled
<TT>&lt;List&gt; of &lt;Map&#58;STAF/Service/Zip/ZipInfo&gt;</TT> representing
content of the Zip archive. The map is defined as follows: 
<BR>
<P><B><A NAME="Table_106">Table 106. Definition of map class STAF/Service/Zip/ZipInfo</A></B><BR>
<TABLE  BORDER>
<TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Description&#58; </B>This map class represents an entry in Zip archive.
</TD></TR><TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Key Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Display Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Type
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">Format / Value
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">length
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Length
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">method
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Method
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Size
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">ratio
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Ratio
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">date
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Date
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Time
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">crc-32
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">CRC-32
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%">Name
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="17%"><TT>&lt;String&gt;</TT>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="50%">
<BR></TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" COLSPAN="4" WIDTH="100%"><B>Notes&#58; </B>
<OL COMPACT TYPE=1>
<LI>The "Length" value is the uncompressed size of the file.
<LI>The "Method" value is compression method, often in the
format of <TT>&lt;Compression Method&gt;&#58;&lt;Compression level&gt;</TT>
used to compress the file. For example "Defl&#58;X", "Defl" stands for "Deflated", 
"X" stands for "Maximum compression". Compression level can also contain the following
values: "N" stands for "Normal compression", "F" stands for "Fast and Super fast 
compression". Compression method can also contain the following values: "Stored" stands
for "No compression", "Unkn." stands for "Unknown compression method".
<LI>The "Size" value is the compressed size of the file.
<LI>The "Ratio" value is the compression ratio of the file.
<LI>The "Date" value is the date stamp of the original file.
<LI>The "Time" value is the time stamp of the original file.
<LI>The "CRC-32" value is the CRC-32 value of the file.
<LI>The "Name" value is the relative name of the file.
</OL>
</TD></TR></TABLE>
<P>
<P><H4><A NAME="Header_963">Examples</A></H4>
<P>
<UL>
<P><LI><B>Goal:</B> Show me the content of a ZIP archive.
<P><B>Syntax:</B>&nbsp; <TT>LIST ZIPFILE /usr/local/staf/services/STAXV301.zip</TT>
<P><B>Results:</B> If the request is submitted from the
command line, the result, in table format, could look like:
<PRE>
Length  Method Size    Ratio Date     Time  CRC-32   Name
------- ------ ------- ----- -------- ----- -------- --------------------------
      0 Stored       0   0%  07-28-05 03:44 00000000 stax/
      0 Stored       0   0%  07-28-05 03:44 00000000 stax/docs/
  42748 Defl&#58;N   13022  30%  07-28-05 03:44 f72affac stax/docs/History
  86379 Defl&#58;N   58971  68%  07-28-05 03:44 aeb290ca stax/docs/STAXDoc.pdf
 926998 Defl&#58;N  711411  76%  07-28-05 03:44 92496663 stax/docs/staxgs.pdf
 921917 Defl&#58;N  653042  70%  07-28-05 03:44 e4e64a11 stax/docs/staxug.pdf
      0 Stored       0   0%  07-28-05 03:44 00000000 stax/ext/
   2029 Defl&#58;N     572  28%  07-28-05 03:44 b9c0e581 stax/ext/stax-extensions.d
                                                     td
      0 Stored       0   0%  07-28-05 03:44 00000000 stax/libraries/
  57120 Defl&#58;N   10726  18%  07-28-05 03:44 03e1c2d9 stax/libraries/STAXUtil.ht
                                                     ml
  77766 Defl&#58;N   14909  19%  07-28-05 03:44 2cfa2ce7 stax/libraries/STAXUtil.xm
                                                     l
   2118 Defl&#58;N     938  44%  07-28-05 03:44 f15cb878 stax/readme.1st
      0 Stored       0   0%  07-28-05 03:44 00000000 stax/samples/
   5274 Defl&#58;N     826  15%  07-28-05 03:44 277d4fb7 stax/samples/FunctionList.
                                                     xsl
  10528 Defl&#58;N    2830  26%  07-28-05 03:44 b6dfa3ee stax/samples/sample1.xml
  30281 Defl&#58;N   27699  91%  07-28-05 03:44 837e1ab4 stax/STAFEvent.jar
2607441 Defl&#58;N 2541497  97%  07-28-05 03:44 0b9b43aa stax/STAX.jar
  25619 Defl&#58;N   22208  86%  07-28-05 03:44 8104f5b9 stax/STAXDoc.jar
 189539 Defl&#58;N  177191  93%  07-28-05 03:44 bd0c4288 stax/STAXMon.jar
</PRE>
</UL>
<A NAME="IDX701"></A>
<P><H3><A NAME="HDRZIPERR">8.22.7 Zip Error Code Reference</A></H3>
<P>In addition to the common STAF return codes (see <A HREF="#HDRRETCODE">Appendix A, "API Return Codes"</A> for
additional information), the following Zip return codes are defined:
<BR>
<P><B><A NAME="TBLZIPERR">Table 107. Zip Service Return Codes</A></B><BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">Error Code
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Meaning
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Comment
</TH></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4001</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">General zip error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">A general error occurred, additional error message can be found in result
buffer.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4002</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Not enough memory
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">There is not enough memory in the system.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4003</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Change file size error: &lt;file&gt;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Error changing the file size.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4004</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Error creating directory: &lt;dir&gt;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Error creating directory in the file system.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4005</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid zip file: &lt;file&gt;
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Invalid zip file format.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4006</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Bad CRC
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Bad CRC in the zip archive.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4007</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid owner group
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Invalid owner / group on the system when restore permission.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4008</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid file mode
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Invalid file mode.
</TD></TR></TABLE>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<A NAME="IDX702"></A>
<HR><H1><A NAME="HDRUTILS" HREF="#ToC_965">9.0 Log Utilities</A></H1>
<P>Some utilities are provided to assist in viewing and formatting STAF
log files and the JVM Log files.
<A NAME="IDX704"></A>
<A NAME="IDX705"></A>
<A NAME="IDX707"></A>
<A NAME="IDX709"></A>
<HR><H2><A NAME="HDRSTAFLOGVIEWER" HREF="#ToC_966">9.1 STAF Log Viewer Class</A></H2>
<P><H3><A NAME="Header_967">9.1.1 Description</A></H3>
The STAFLogViewer class provides a Java GUI that can display any STAF log on
any machine currently running STAF.
A STAF log is a binary log file that has been created by the STAF Log service.
This Java class submits requests to STAF, so STAF has to be running.
<P> 
This Java class can be run as an application via the command line or can be
run via another Java program.
<P>
<A NAME="IDX712"></A>
For more information on how to use the STAFLogViewer class, see section
"3.6.1 Class STAFLogViewer" in the
<A HREF="http://staf.sourceforge.net/current/STAFJava.htm#Header_STAFLogViewer">STAF Java User's Guide</A>.
<P>
<A NAME="IDX713"></A>
<A NAME="IDX714"></A>
<A NAME="IDX716"></A>
<A NAME="IDX718"></A>
<HR><H2><A NAME="HDRSTAFJVMLOGVIEWER" HREF="#ToC_968">9.2 JVM Log Viewer Class</A></H2>
<P><H3><A NAME="Header_969">9.2.1 Description</A></H3>
<P>
The <TT>STAFJVMLogViewer</TT> class provides a Java GUI that can display a
JVM Log for any STAF Java service that is currently registered.
Each Java service that is registered with STAF runs in a JVM (Java Virtual Machine).
A JVM Log is a text log file that is associated with each JVM created by STAF.
Note that more than one Java service may use the same JVM (and thus share the same
JVM Log file) depending on the options used when registering the service.
Section <A HREF="#HDRSERVICEREGCFG">4.4, "Service Registration"</A> provides more information on registering
STAF Java services using the JSTAF library.
<P>
A JVM Log file contains JVM start information such as the date/time when the JVM
was created, the JVM executable, and the J2 options used to start the JVM.
It also any other information logged by the JVM.  This includes any
errors that may have occurred while the JVM was running and any debug information
output by a Java service.  Also, the JVM Log for the STAX service contains the
output from any print statements that are used within a <TT>&lt;script&gt;</TT> element
in a STAX xml job file which is useful when debugging Python code contained in
a <TT>&lt;script&gt;</TT> element.  When a problem occurs with a STAF Java service,
you should always check it's JVM Log as it may contain information to help debug
the problem.
<P>
STAF stores JVM Log files in the <TT>{STAF/DataDir}/lang/java/jvm/&lt;JVMName&gt;</TT>
directory.   STAF retains a configurable number of JVM Logs (five by default) for each
JVM.  The current JVM log file is named <TT>JVMLog.1</TT> and older saved JVM log
files, if any, are named <TT>JVMLog.2</TT> to <TT>JVMLog.&lt;MAXLOGS&gt;</TT>.
When a JVM is started, if the size of the <TT>JVMLog.1</TT> file exceeds the
maximum configurable size (1M by default), the <TT>JVMLog.1</TT> file is copied
to <TT>JVMLog.2</TT> and so on for any older JVM Logs, and a new <TT>JVMLog.1</TT>
file will be created.
<P>
When using the <TT>STAFJVMLogViewer</TT>, you can specify the machine where the
STAF JVM log resides (e.g. where the Java service is registered) and you can
specify/select the name of the STAF service whose JVM Log you want to display.
This Java class submits requests to STAF, so STAF has to be running. 
This Java class can be run as an application via the command line or can be
run via another Java program.
<P>
Note that the STAX Monitor Java application uses the <TT>STAFJVMLogViewer</TT>
class to display the JVM log for the STAX service and for other services.
<P>
<A NAME="IDX721"></A>
For more information on how to use the STAFJVMLogViewer class, see section
"3.6.2 Class STAFJVMLogViewer" in the
<A HREF="http://staf.sourceforge.net/current/STAFJava.htm#Header_STAFJVMLogViewer">STAF Java User's Guide</A>.
<P>
<A NAME="IDX722"></A>
<A NAME="IDX723"></A>
<A NAME="IDX725"></A>
<A NAME="IDX727"></A>
<HR><H2><A NAME="HDRSTAFLOGFORMATTER" HREF="#ToC_970">9.3 STAF Log Formatter Class</A></H2>
<P><H3><A NAME="Header_971">9.3.1 Description</A></H3>
The STAFLogFormatter class allows you to format a STAX log (which
is a binary file that has been created by the STAF Log service) as html
or text.
<P>
This Java class can be run as an application via the command line or can be
run via another Java program.  When run as an application, it submits the
specified Log query request to query a STAF log on any machine currently
running STAF and then formats the output as either html or text.
Or, when run via a Java program that has already submitted a LOG QUERY request,
you can use the STAFLogFormatter class to format the log query result
as either html or text.  You can specify various options including whether you
want the formatted output written to a file.
<P>
<A NAME="IDX730"></A>
For more detailed information on using the STAFLogFormatter class,
see section "3.6.3 Class STAFLogFormatter" in the 
<A HREF="http://staf.sourceforge.net/current/STAFJava.htm#Header_STAFLogFormatter">STAF Java User's Guide</A>.
<P>
<P>
<A NAME="IDX731"></A>
<A NAME="IDX733"></A>
<A NAME="IDX735"></A>
<HR><H2><A NAME="HDRFMTLOG" HREF="#ToC_972">9.4 Format Log Utility</A></H2>
<P><H3><A NAME="Header_973">9.4.1 Description</A></H3>
The FmtLog utility will read a STAF log file and format and write the data to an
output file in a readable format.
A STAF log file is a binary log file that has been created by the STAF Log service. 
<A NAME="IDX738"></A>
<P><H3><A NAME="Header_974">9.4.2 FORMAT</A></H3>
Format data from a log file to an output file in a readable (non-compressed)
format.  Note that this utility does not interact with STAF (i.e. STAF does not
have to be running on the machine).
<P><H4><A NAME="Header_975">Syntax</A></H4>
<PRE>
FmtLog FORMAT LOGFILE &lt;Logfile&gt; NEWFILE &lt;Newfile&gt; &#91;LEVELBITSTRING&#93;  &#91;FIELDSEP &lt;Char&gt;&#93;
</PRE>
<P><TT>LOGFILE</TT> contains the name of the log you want to read.  This must
be the complete path and filename.
<P><TT>NEWFILE</TT> contains the name of the output file where you want to
write the results.  This must be the complete path and filename.
<P><TT>LEVELBITSTRING</TT> displays the selected records with the level
displayed as the 32 byte binary bit string, e.g.
00000000000000000000000000000001 instead of the standard level text e.g. Error.
See <A HREF="#HDRLOGLEV">8.9.11, "Logging Levels Reference"</A> for a complete list of logging levels.
<P><TT>FIELDSEP</TT> is the character that separates each record field, the
default is "|".
<P><H4><A NAME="Header_976">Directory Structure</A></H4>
If the log directory was defined as C:\STAF\data\STAF\service\log (the default log
directory name on Windows) then the following is an example of how the log directory
structure could look:
<PRE>
C:\STAF\data\STAF\service\log\                                        &lt;-Global Top
C:\STAF\data\STAF\service\log\GLOBAL\                                 &lt;--Global Dir
  STRESSTST.LOG                                                       &lt;---Global Log
  SUITE100.LOG                                                        &lt;---Global Log
C:\STAF\data\STAF\service\log\MACHINE\                                &lt;-Machine Top
C:\STAF\data\STAF\service\log\MACHINE\client1.company.com\            &lt;--clieot1 Top
C:\STAF\data\STAF\service\log\MACHINE\client1.company.com\GLOBAL\     &lt;---client1 Global Top
  TESTLOG1.LOG                                                        &lt;----client1 Global Logs
C:\STAF\data\STAF\service\log\MACHINE\client1.company.com\HANDLE\     &lt;--client1 Handle Top
C:\STAF\data\STAF\service\log\MACHINE\client1.company.com\HANDLE\100\ &lt;---Handle 100 Top
  TESTLOG2.LOG                                                        &lt;---Handle 100 Log
C:\STAF\data\STAF\service\log\MACHINE\AUTOMATE\                       &lt;--AUTOMATE Top
C:\STAF\data\STAF\service\log\MACHINE\AUTOMATE\GLOBAL\                &lt;---AUTOMATE Global Top
  AUTOGLOB.LOG                                                        &lt;----AUTOMATE Global Log
C:\STAF\data\STAF\service\log\MACHINE\AUTOMATE\HANDLE\                &lt;---AUTOMATE Handle Top
C:\STAF\data\STAF\service\log\MACHINE\AUTOMATE\HANDLE\42\             &lt;----Handle 42 Top
  HANDLOG1.log                                                        &lt;-----Handle 42 Log
C:\STAF\data\STAF\service\log\MACHINE\AUTOMATE\HANDLE\43\             &lt;----Handle 43 Top
  HANDLOG2.log                                                        &lt;-----Handle 43 Log
  HANDLOG3.log                                                        &lt;-----Handle 43 Log
C:\STAF\data\STAF\service\log\MACHINE\AUTOMATE\HANDLE\44\             &lt;----Handle 44 Top
  HANDLOG4.log                                                        &lt;-----Handle 44 Log
C:\STAF\data\STAF\service\log\MACHINE\automate\HANDLE\45\             &lt;----Handle 45 Top
  HANDLOG5.log                                                        &lt;-----Handle 45 Log
</PRE>
<P>
<P><H4><A NAME="Header_977">Result</A></H4>
A line will be written to the specified file for each record in the specified
logfile in the following format (assuming the default field separator, '|', is used):
<PRE>
Date-Time|Machine|Handle|Handle Name|User|Endpoint|Level|Message
</PRE>
<P>
<P><H4><A NAME="Header_978">Example</A></H4>
<P>
<PRE>
C:\&gt;FmtLog FORMAT LOGFILE C:/STAF/data/STAF/service/LOG/MACHINE/client1/GLOBAL/STAX_Job_4_User.log NEWFILE C:/myLog.txt
Formatted 10 record(s) to C:/myLog.txt
</PRE>
<P>
The contents of C:/myLog.txt could look like the following:
<PRE>
20041029-15:42:03|client1.company.com|78|STAX/Job/4|none://anonymous|tcp://client1.company.com|Info|TestMachines=['client1.company.com']
20041029-15:42:04|client1.company.com|78|STAX/Job/4|none://anonymous|tcp://client1.company.com|Info|JobHandle=78
20041029-15:42:04|client1.company.com|78|STAX/Job/4|none://anonymous|tcp://client1.company.com|Info|STAXMachineNickname=client1
20041029-15:42:04|client1.company.com|78|STAX/Job/4|none://anonymous|tcp://client1.company.com|Info|STAXMachine=client1.company.com
20041029-15:42:08|client1.company.com|78|STAX/Job/4|none://anonymous|tcp://client1.company.com|Info|Test machine: client1.company.com  OS type: Win2000  STAFRoot: C:\STAF
20041029-15:42:08|client1.company.com|78|STAX/Job/4|none://anonymous|tcp://client1.company.com|Info|STAF Testing started on machine client1.company.com
20041029-15:44:28|client1.company.com|78|STAX/Job/4|none://anonymous|tcp://client1.company.com|Info|STAF Testing completed on machine client1.company.com
20041029-15:44:28|client1.company.com|78|STAX/Job/4|none://anonymous|tcp://client1.company.com|Info|STAF Testing completed in 146 seconds
20041104-18:27:07|client1.company.com|50|STAX/Job/4|none://anonymous|local://local|Info|STAF local PROCESS START SHELL COMMAND "dir C&#58;d*." RETURNSTDOUT STDERRTOSTDOUT WAIT
20041105-11:22:51|client1.company.com|89|STAX/Job/4|none://anonymous|local://local|Info|STAF local PROCESS START SHELL COMMAND "dir C&#58;d*." RETURNSTDOUT STDERRTOSTDOUT WAIT
</PRE>
<P>
<P>
<P>
<A NAME="IDX740"></A>
<HR><H1><A NAME="HDRRETCODE" HREF="#ToC_979">Appendix A. API Return Codes</A></H1>
<P><B>Note: </B>In some shell environments, return codes above 255 may be returned modulo
256.  This can, in particular, cause service return codes (which range from
4000 upward) to be mistaken for (possibly) non-existent common STAF return
codes.  For example, if a service returned the return code 4010, this might
appear to be the return code 170 (4010 modulo 256) in a shell
environment.
<BR>
<P><B><A NAME="TBLERRTAB">Table 108. STAF API Return Codes</A></B><BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="CENTER" VALIGN="TOP" WIDTH="14%">Error Code
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Meaning
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Comment
</TH></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>0</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">No error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">
<BR></TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>1</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid API
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that a process has tried to call an invalid internal STAF API.
If this error occurs, report it to the authors.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>2</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Unknown Service
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You have tried to submit a request to a service that is unknown to STAFProc.
Verify that you have correctly registered the service.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>3</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid Handle
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You are passing an invalid handle to a STAF API.  Ensure that you are using
the handle you received when you registered with STAF.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Handle already exists
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that you are trying to register a process with one name when
that process has already been registered with a different name.  If you
register the same process multiple times, ensure that you use the same name
on each registration call.
<P><B>Note: </B>If you receive this error code when trying to perform an operation
other than registering a service, report it to the authors.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>5</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Handle does not exist
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You are trying to perform an operation on a handle that does not exist.
For example, you may be trying to stop a process, but you are specifying the
wrong handle.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>6</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Unknown Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">An unknown error has occurred.  This error is usually an indication of an
internal STAF error.  If this error occurs, report it the authors.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>7</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid Request String
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You have submitted an improperly formatted request to a service.  See the
appropriate section in this document for the syntax of the service's requests,
or contact the provider of the service.
<P><B>Note: </B>Additional information regarding the exact syntax error may be provided
in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>8</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid Service Result
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates an internal error with the service to which a request was
submitted.  If this error occurs, report it to the authors and the service
provider.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>9</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Rexx Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates an internal error in an external Rexx service.  If this error
occurs, report it to the authors and the service provider.
<P><B>Note: </B>The actual Rexx error code will be returned in the result passed back
from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>10</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Base OS Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that a base operating system error was encountered.
<P><B>Note: </B>The actual base operating system error code, and possibly additional
information about the error, will be returned in the result passed back
from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>11</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Process Already Complete
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You are trying to perform an invalid operation on a process that has
already completed.  For example, you may be trying to stop the process or
register for a process end notification.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>12</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Process Not Complete
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You are trying to free process information for a process that is still
executing.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>13</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Variable Does Not Exist
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You are trying to get, remove, or resolve a variable that does not exist.
Remember that variables are case sensitive.  The name of the variable that
does not exist will be in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>14</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">UnResolvable String
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You have requested to resolve a string that cannot be resolved.  This
indicates that you have exceeded the resolution depth of the VAR service.  The
most common cause of this is recursive variables definitions.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>15</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid Resolve String
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">The string you requested to be resolved has a non-matching left or right
curly brace.  Ensure that all variable references have both left and right
curly braces.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>16</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">No Path To Endpoint
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that STAFProc was not able to submit the request to
the requested endpoint (i.e. target machine).  This error usually indicates
one or more of the following:
<P>
<OL COMPACT TYPE=1>
<LI>STAFProc is not running on the target machine.
<LI>The requested endpoint is not valid.
<LI>The network interface or port for the requested endpoint is not supported.
<LI>A firewall is blocking communication via the port for the requested endpoint.
<LI>A secure network interface is being used to communicate to a machine that
doesn't have a secure network interface configured with the same certificate.
</OL>
Alternatively, you may need to increase your CONNECTTIMEOUT value for the
network interface and/or increase your CONNECTATTEMPTS value in your STAF.cfg
file.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>17</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">File Open Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that there was an error opening the requested file.
Some possible explanations are that the file/path does not exist, contains
invalid characters, or is locked.
<P><B>Note: </B>Additional information regarding which file could not be opened may be
provided in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>18</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">File Read Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that there was an error while trying to read data from a file.
<P><B>Note: </B>Additional information regarding which file could not be read and why may 
be provided in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>19</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">File Write Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that there was an error while trying to write data to a file.
<P><B>Note: </B>Additional information regarding which file could not be written to may
be provided in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>20</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">File Delete Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that there was an error while trying to delete a file or
directory.
<P><B>Note: </B>Additional information regarding which file or directory could not be
deleted may be provided in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>21</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">STAF Not Running
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that STAFProc is not running on the local machine with the
same STAF_INSTANCE_NAME (and/or the same STAF_TEMP_DIR if on a Unix machine).
<P>
<B>Notes:</B>
<OL COMPACT TYPE=1>
<LI>If the STAF_INSTANCE_NAME environment variable is not set, it defaults
to "STAF".
<LI>On Unix, if the STAF_TEMP_DIR environment variable is not set, it defaults
to "/tmp".  This environment variable is not used on Windows.
<LI>This error can also occur when submitting a request using the local IPC
interface on a Unix machine if the socket file that the local interface uses
has been inadvertently deleted. 
<LI>On Windows, with User Account Controls (UAC) enabled, if STAFProc.exe
is being run as an Administrator, this error will occur if a STAF service
request is not also run as an Administrator (e.g. from an "Administrator:
Command Prompt") or if programs that submit STAF service requests using
STAF APIs for Java, C/C++, Perl, Python, or Tcl are not run an an
Administrator. See section "5.1.2 Running STAFProc on Windows with User
Account Controls (UAC) Enabled" in the STAF User's Guide for more information.
<LI>More information on this error may be displayed if you set special
environment variable STAF_DEBUG_21=1 and resubmit your STAF service request.
</OL>
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>22</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Communication Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates an error transmitting data across the network, or to the
local STAF process.  For example, you would receive this error if STAFProc.exe
was terminated in the middle of a service request, or if a bridge went down
in the middle of a remote service request.  This can also indicate that the
requested endpoint is not valid (e.g. it has an invalid network interface and
port combination such as a non-secure tcp interface with the port for a secure
ssl interface).
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>23</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Trustee Does Not Exist
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You have requested to delete a trustee, and the trustee does not exist.
Verify that you have specified the correct trustee.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>24</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid Trust Level
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You have attempted to set a machine or default trust level to an invalid
level.  The valid trust levels are from zero to five.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>25</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Insufficient Trust Level
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You have submitted a request for which you do not have the required
trust level to perform the request.
<P><B>Note: </B>Additional information regarding the required trust level may be
provided in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>26</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">STAF Registration Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that an external service encountered a problem when trying
to register with STAF.  Ensure that STAF has been properly installed and
configured.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>27</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Service Configuration Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates an error with the configuration of an external service.  One 
possible explanation is that the LIBRARY you specified when configuring the
service does not exist.  Or, if you specified the EXECUTE option, verify that
the executable exists and has the execute permission.  Or, if you specified the
PARMS option, verify that all of the service configuration are valid.  Consult
the appropriate documentation for the service to verify whether you have
configured the service properly, or contact the service provider.
<P><B>Note: </B>Additional information regarding why the service configuration failed
may be provided in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>28</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Queue Full
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that you are trying to queue a message to a handle's queue,
but the queue is full.  The maximum queue size can be increased by using
the MAXQUEUESIZE statement in the STAF Configuration File.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>29</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">No Queue Element
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that you tried to GET or PEEK a particular element in a
queue, but no such element exists, or the queue is empty.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>30</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Notifiee Does Not Exist
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that you are trying to remove a message notification for
a machine/process/priority combination which does not exist in the
notification list.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>31</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid API Level
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that a process has tried to call an invalid level of an
internal STAF API.  If this error occurs, report it to the authors.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>32</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Service Not Unregisterable
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that you are trying to unregister a service that is not
unregisterable.  Note that internal services are not unregisterable.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>33</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Service Not Available
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that the service you requested is not currently able to
accept requests.  The service may be in the process of initializing or
terminating.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>34</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Semaphore Does Not Exist
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that you are trying to release, query, or delete a semaphore
that does not exist.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>35</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Not Semaphore Owner
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that you are trying to release a semaphore for which your
process is not the current owner.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>36</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Semaphore Has Pending Requests
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that you are trying to delete either a mutex semaphore that
is currently owned or an event semaphore that has waiting processes.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>37</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Timeout
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that you submitted a request with a timeout value and the
request did not complete within the requested time.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>38</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Java Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates an error performing a Java native method call.  A description
of the error will be returned in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>39</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Converter Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates an error performing a codepage conversion.  The most likely
cause of this error is that STAF was not properly installed.  However, it is
possible that you are currently using a codepage that was not present or
specified during STAF installation.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>40</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Move Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that there was an error while trying to move a file or
directory.
<P><B>Note: </B>Additional information regarding the error may be provided in the
result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>41</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid Object
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that an invalid object was specified to a STAF API.
If you receive this return code via a standard STAFSubmit call, report it to
the authors and the service provider.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>42</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid Parm
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that an invalid parameter was specified to a STAF API.
If you receive this return code via a standard STAFSubmit call, report it to 
the authors and the service provider.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>43</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Request Number Not Found
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that the specified Request Number was not found.  The 
specified Request Number may be invalid, or the request's information may no 
longer be available from the Service Service (for example, if the SERVICE FREE
command had previously been issued for the request number).
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>44</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid Asynch Option
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that an invalid Asynchronous submit option was specified.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>45</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Request Not Complete
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that the specified request is not complete.  This error code 
would be returned, for example, if you requested the result of a request which 
has not yet completed.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>46</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Process Authentication Denied
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that the userid/password you specified could not be 
authenticated.  The userid/password may not be valid or authentication may be 
disabled.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>47</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid Value
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that an invalid value was specified.  This is closely related
to the Invalid Request String return code, but indicates that a specific value 
in the request is invalid.  For example, you may not have specified a number 
where a number was expected.
<P><B>Note: </B>Additional information regarding which value is invalid may be provided
in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>48</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Does Not Exist
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that the item you specified does not exist.  
<P><B>Note: </B>Additional information regarding which item could not be found may be
provided in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>49</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Already Exists
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that the item you specified already exists.  
<P><B>Note: </B>Additional information regarding which item already exists may be
provided in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>50</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Directory Not Empty
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that you have tried to delete a directory, but that directory
is not empty.
<P><B>Note: </B>Additional information specifying the directory which could not be deleted
may be provided in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>51</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Directory Copy Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that you have tried to copy a directory, but errors occurred
during the copy.
<P><B>Note: </B>Additional information specifying the entries which could not be copied
may be provided in the result passed back from the submit call.
More details about why a specific file could not be copied may be provided by 
submitting a COPY FILE request instead of a COPY DIRECTORY request.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>52</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Diagnostics Not Enabled
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that you tried to record diagnostics data, but diagnostics
have not been enabled.  You must enable diagnostics before you can record
diagnostics data.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>53</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Handle Authentication Failed
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that the user, credentials, and/or authenticator you specified
could not be authenticated. The user/credentials may not be valid or the
authenticator may not be registered.
<P><B>Note: </B>Additional information specifying why authentication was denied may be
provided in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>54</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Handle Already Authenticated
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that the handle is already authenticated. The handle must be
unauthenticated in order to be authenticated.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>55</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Invalid STAF Version
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that the version of STAF (or the version of a STAF service)
is lower than the minimum required version.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>56</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Request cancelled
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that the request has been cancelled.
<P><B>Note: </B>Additional information specifying why the request was cancelled may be
provided in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>57</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Create Thread Error
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that a problem occurred creating a new thread. One possible
explanation is that there's not enough memory available to create a new
thread.
<P><B>Note: </B>Additional information specifying why creating a new thread failed may be
provided in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>58</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Maximum Size Exceeded
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that the size of a file exceeded the maximum size allowed
(e.g. per the MAXRETURNFILESIZE operational parameter or per the
MAXRETURNFILESIZE setting for the STAX service).
A maximum file size is usually set to prevent the creation of result strings
that require more memory than is available which can cause errors or crashes.
<P><B>Note: </B>Additional information specifying why this error occurred may be
provided in the result passed back from the submit call.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>59</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Maximum Handles Exceeded
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This indicates that a new handle could not be created/registered
because the maximum number of active handles allowed by STAF has been
exceeded.  You need to delete one or more handles that are no longer
being used.  The Handle service's LIST HANDLES SUMMARY request provides
information on the maximum number of active STAF handles and this may be
helpful in better understanding why this error occurred.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>60</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Not Pending Requester
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">You cannot cancel a pending request your handle did not submit unless
you specify the FORCE option.
</TD></TR><TR>
<TD ALIGN="CENTER" VALIGN="TOP" WIDTH="14%"><B>4000+</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Service Defined
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Error codes of 4000 and beyond are service specific error codes.  Either
see the appropriate section in this document for the syntax of the service's
requests, or contact the provider of the service.
</TD></TR></TABLE>
<P>
<A NAME="IDX741"></A>
<A NAME="IDX742"></A>
<HR><H1><A NAME="HDRCMDREF" HREF="#ToC_980">Appendix B. Service Command Reference</A></H1>
<BR>
<P><B><A NAME="TBLCMDTAB">Table 109. STAF Service Command Reference</A></B><BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="20%">Command
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Syntax
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>CONFIG</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Provides a way to save the current STAF configuration to a file,
reflecting any changes made since STAFProc was started
<P>
<PRE>
SAVE [FILE &lt;Name&gt;] [VARS &lt;Current | Startup&gt;]
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>DELAY</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Delay (or sleep) for a specified amount of time.
<P>
<PRE>
DELAY &lt;Number&gt;[s|m|h|d|w]
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>DIAG</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows diagnostics to be recorded, listed, enabled, disabled, and reset.
<P>
<PRE>
RECORD TRIGGER &lt;Trigger&gt; SOURCE &lt;Source&gt;
 
LIST   &lt; &#91;TRIGGER &lt;Trigger&gt; | SOURCE &lt;Source&gt; | TRIGGERS | SOURCES&#93;
         &#91;SORTBYCOUNT | SORTBYTRIGGER | SORTBYSOURCE&#93; &gt; |
       SETTINGS
 
RESET  FORCE
 
ENABLE
 
DISABLE
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>ECHO</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Echo a return string from other STAF clients.
<P>
<PRE>
ECHO &lt;Message&gt;
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>FS</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows you to manipulate files and directories and get information about file system entries.
<P>
<PRE>
COPY   FILE &lt;Name&gt; &#91;TOFILE &lt;Name&gt; | TODIRECTORY &lt;Name&gt;&#93;  &#91;TOMACHINE &lt;Machine&gt;&#93;
       &#91;TEXT &#91;FORMAT &lt;Format&gt;&#93;&#93;  &#91;FAILIFEXISTS | FAILIFNEW&#93;
 
COPY   DIRECTORY &lt;Name&gt; &#91;TODIRECTORY &lt;Name&gt;&#93;  &#91;TOMACHINE &lt;Machine&gt;&#93;
       &#91;NAME &lt;Pattern&gt;&#93;  &#91;EXT &lt;Pattern&gt;&#93; &#91;CASESENSITIVE | CASEINSENSITIVE&#93;
       &#91;TEXTEXT &lt;Pattern&gt;... &#91;FORMAT &lt;Format&gt;&#93;&#93;
       &#91;RECURSE &#91;KEEPEMPTYDIRECTORIES | ONLYDIRECTORIES&#93;&#93;
       &#91;IGNOREERRORS&#93; &#91;FAILIFEXISTS | FAILIFNEW&#93;
 
MOVE   FILE &lt;Name&gt; &lt;TOFILE &lt;Name&gt; | TODIRECTORY &lt;Name&gt;&gt;
 
MOVE   DIRECTORY &lt;Name&gt; TODIRECTORY &lt;Name&gt;
 
GET    FILE &lt;Name&gt; &#91;&#91;TEXT | BINARY&#93; &#91;FORMAT &lt;Format&gt;&#93;&#93;
 
GET    ENTRY &lt;Name&gt; &lt;TYPE | SIZE | MODTIME | LINKTARGET |
                     CHECKSUM &#91;&lt;Algorithm&gt;&#93;&gt;
QUERY  ENTRY &lt;Name&gt;
 
CREATE DIRECTORY &lt;Name&gt; &#91;FULLPATH&#93; &#91;FAILIFEXISTS&#93;
 
LIST   DIRECTORY &lt;Name&gt; &#91;RECURSE&#93; &#91;LONG &#91;DETAILS&#93; | SUMMARY&#93; &#91;TYPE &lt;Types&gt;&#93;
       &#91;NAME &lt;Pattern&gt;&#93; &#91;EXT &lt;Pattern&gt;&#93; &#91;CASESENSITIVE | CASEINSENSITIVE&#93;
       &#91;SORTBYNAME | SORTBYSIZE | SORTBYMODTIME&#93;     
 
LIST   COPYREQUESTS &#91;LONG&#93; &#91;INBOUND&#93; &#91;OUTBOUND&#93;
       &#91;FILE &#91;&#91;BINARY&#93; &#91;TEXT&#93;&#93;&#93; &#91;DIRECTORY&#93;
 
LIST   SETTINGS
 
DELETE ENTRY &lt;Name&gt; CONFIRM &#91;RECURSE&#93; &#91;IGNOREERRORS&#93;
       &#91; CHILDREN &#91;TYPE &lt;Types&gt;&#93; &#91;NAME &lt;Pattern&gt;&#93; &#91;EXT &lt;Pattern&gt;&#93;
                  &#91;CASESENSITIVE | CASEINSENSITIVE&#93; &#93;
                  
SET    STRICTFSCOPYTRUST &lt;Enabled | Disabled&gt;
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>HANDLE</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows you to query information on various process handles and to manage static handles.
<P>
<PRE>
CREATE HANDLE NAME &lt;Handle Name&gt;
 
DELETE HANDLE &lt;Number&gt;
 
QUERY HANDLE &lt;Handle&gt;
 
LIST &#91; HANDLES &lt;&#91;NAME &lt;Handle Name&gt;&#93; &#91;LONG&#93; &#91;PENDING&#93; &#91;REGISTERED&#93;
                &#91;INPROCESS&#93; &#91;STATIC&#93;&gt; | &#91;SUMMARY&#93; &#93;
 
LIST NOTIFICATIONS &#91;HANDLE &lt;Handle&gt; | MACHINE &lt;Machine&gt;&#93; &#91;LONG&#93;
 
AUTHENTICATE USER &lt;User Identifier&gt; CREDENTIALS &lt;Credentials&gt;
             &#91;AUTHENTICATOR &lt;Authenticator Name&gt;&#93;
 
UNAUTHENTICATE
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>HELP</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">List and query STAF return codes.  Allows services to register their own
return codes.
<P>
<PRE>
REGISTER   SERVICE &lt;Name&gt; ERROR &lt;Number&gt; INFO &lt;String&gt; DESCRIPTION &lt;String&gt;
 
UNREGISTER SERVICE &lt;Name&gt; ERROR &lt;Number&gt;
 
&#91;SERVICE &lt;Name&gt;&#93; ERROR &lt;Number&gt;
 
LIST SERVICES | &#91;SERVICE &lt;Name&gt;&#93; ERRORS
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>LIFECYCLE</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows STAF service requests to be submitted automatically when STAFProc starts
up or shuts down.  Also, allows managing registration of the STAF service requests
to be submitted.
<P>
<PRE>
REGISTER   PHASE &lt;Startup | Shutdown&gt;
           MACHINE &lt;Machine&gt; SERVICE &lt;Service&gt; REQUEST &lt;Request&gt;
           [ONCE] [PRIORITY &lt;Priority&gt;] [DESCRIPTION &lt;Description&gt;]
 
UNREGISTER ID &lt;Registration ID&gt;
 
UPDATE     ID &lt;Registration ID&gt; [PRIORITY &lt;Priority&gt;] [ONCE &lt;True | False&gt;]
           [MACHINE &lt;Machine&gt;] [SERVICE &lt;Service&gt;] [REQUEST &lt;Request&gt;]
           [PHASE &lt;Startup | Shutdown&gt;] [DESCRIPTION &lt;Description&gt;]
 
LIST       [PHASE &lt;Startup | Shutdown&gt;] [LONG]
 
QUERY      ID &lt;Registration ID&gt;
 
TRIGGER    &lt;ID &lt;Registration ID&gt; | PHASE &lt;Startup | Shutdown&gt;&gt; CONFIRM
 
ENABLE     ID &lt;Registration ID&gt;
 
DISABLE    ID &lt;Registration ID&gt;
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>LOG</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows for robust data-logging and log file querying and manipulation.
<P>
<PRE>
LOG    &lt;GLOBAL | MACHINE | HANDLE&gt; LOGNAME &lt;Logname&gt; LEVEL &lt;Level&gt;
       MESSAGE &lt;Message&gt; &#91;RESOLVEMESSAGE | NORESOLVEMESSAGE&#93;
 
QUERY  &lt;GLOBAL | MACHINE &lt;Machine&gt; &#91;HANDLE &lt;Handle&gt;&#93;&gt; LOGNAME &lt;Logname&gt;
       &#91;LEVELMASK &lt;Mask&gt;&#93; &#91;QMACHINE &lt;Machine&gt;&#93;... &#91;QHANDLE &lt;Handle&gt;&#93;...
       &#91;NAME &lt;Name&gt;&#93;... &#91;USER &lt;User&gt;&#93;... &#91;ENDPOINT &lt;Endpoint&gt;&#93;...
       &#91;CONTAINS &lt;String&gt;&#93;... &#91;CSCONTAINS &lt;String&gt;&#93;...
       &#91;STARTSWITH &lt;String&gt;&#93;... &#91;CSSTARTSWITH &lt;String&gt;&#93;...
       &#91;FROM &lt;Timestamp&gt; | AFTER &lt;Timestamp&gt;&#93;
       &#91;BEFORE &lt;Timestamp&gt; | TO &lt;Timestamp&gt;&#93;
       &#91;FROMRECORD &lt;Num&gt;&#93; &#91;TORECORD &lt;Num&gt;&#93;
       &#91;FIRST &lt;Num&gt; | LAST &lt;Num&gt; | ALL&#93; &#91;TOTAL | STATS | LONG&#93;
       &#91;LEVELBITSTRING&#93;
 
LIST   GLOBAL | MACHINES | MACHINE &lt;Machine&gt; &#91;HANDLE &lt;Handle&gt; | HANDLES&#93; |
       SETTINGS
 
DELETE &lt;GLOBAL | MACHINE &lt;Machine&gt; &#91;HANDLE &lt;Handle&gt;&#93;&gt;
        LOGNAME &lt;Logname&gt; CONFIRM
 
PURGE  &lt;GLOBAL | MACHINE &lt;Machine&gt; &#91;HANDLE &lt;Handle&gt;&#93;&gt; LOGNAME &lt;Logname&gt;
       CONFIRM | CONFIRMALL
       &#91;LEVELMASK &lt;Mask&gt;&#93; &#91;QMACHINE &lt;Machine&gt;&#93;... &#91;QHANDLE &lt;Handle&gt;&#93;...
       &#91;NAME &lt;Name&gt;&#93;... &#91;USER &lt;User&gt;&#93;... &#91;ENDPOINT &lt;Endpoint&gt;&#93;...
       &#91;CONTAINS &lt;String&gt;&#93;... &#91;CSCONTAINS &lt;String&gt;&#93;...
       &#91;STARTSWITH &lt;String&gt;&#93;... &#91;CSSTARTSWITH &lt;String&gt;&#93;...
       &#91;FROM &lt;Timestamp&gt; | AFTER &lt;Timestamp&gt;&#93;
       &#91;BEFORE &lt;Timestamp&gt; | TO &lt;Timestamp&gt;&#93;
       &#91;FROMRECORD &lt;Num&gt;&#93; &#91;TORECORD &lt;Num&gt;&#93;
       &#91;FIRST &lt;Num&gt; | LAST &lt;Num&gt;&#93;
 
SET    &#91;MAXRECORDSIZE &lt;Size&gt;&#93; &#91;DEFAULTMAXQUERYRECORDS &lt;Number&gt;&#93;
       &#91;ENABLERESOLVEMESSAGEVAR | DISABLERESOLVEMESSAGEVAR&#93;
       &#91;RESOLVEMESSAGE | NORESOLVEMESSAGE&#93;
 
VERSION
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>MISC</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Provides miscellaneous services such as VERSION, WHOAMI, and WHOAREYOU
information, allows for listing and querying enabled interfaces, allows
you to set operational parameters for STAF and show their settings,
and allows you to list and purge the endpoint cache used by automatic
interface cycling.
<P>
<PRE>
VERSION
 
WHOAMI
 
WHOAREYOU
 
LIST  INTERFACES | SETTINGS | ENDPOINTCACHE
 
QUERY INTERFACE &lt;Name&gt;
 
SET   &#91;CONNECTATTEMPTS &lt;Number&gt;&#93; &#91;CONNECTRETRYDELAY &lt;Number&gt;&#91;s|m|h|d|w&#93;&#93;
      &#91;MAXQUEUESIZE &lt;Number&gt;&#93; &#91;HANDLEGCINTERVAL &lt;Number&gt;&#91;s|m|h|d&#93;&#93;
      &#91;INTERFACECYCLING &lt;Enabled | Disabled&gt;&#93;
      &#91;DEFAULTINTERFACE &lt;Name&gt;&#93;  &#91;DEFAULTAUTHENTICATOR &lt;Name&gt;&#93;
      &#91;RESULTCOMPATIBILITYMODE &lt;Verbose | None&gt;&#93;
      
PURGE ENDPOINTCACHE &lt;ENDPOINT &lt;Endpoint&gt;... | CONFIRM&gt;
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>MONITOR</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows test cases the ability to log and query status messages.
<P>
<PRE>
LOG    MESSAGE &lt;Message&gt; [NAME &lt;Name&gt;] &#91;RESOLVEMESSAGE | NORESOLVEMESSAGE&#93;
 
QUERY  MACHINE &lt;Machine&gt; &lt; HANDLE &lt;Handle&gt; | NAME &lt;Name&gt; &gt;
 
LIST   &lt;MACHINES | MACHINE &lt;Machine&gt; [NAMES] | SETTINGS&gt;
 
DELETE &#91;BEFORE &lt;Timestamp&gt;&#93; CONFIRM
 
SET    &#91;RESOLVEMESSAGE | NORESOLVEMESSAGE&#93;
       &#91;OLDRETURNCODES | NEWRETURNCODES&#93; &#91;MAXRECORDSIZE &lt;Size&gt;&#93;
       &#91;ENABLERESOLVEMESSAGEVAR | DISABLERESOLVEMESSAGEVAR&#93;
 
VERSION
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>PING</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows you to ping other STAF clients.
<P>
<PRE>
PING &#91;MACHINE &lt;Machine&gt;&#93;
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>PROCESS</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows you to start, stop, and manage processes.
<P>
<PRE>
START &#91;SHELL &#91;&lt;Shell&gt;&#93;&#93; COMMAND &lt;Command&gt; &#91;PARMS &lt;Parms&gt;&#93; &#91;WORKDIR &lt;Directory&gt;&#93;
      &#91;VAR &lt;Variable&gt;=&lt;Value&gt;&#93;... &#91;ENV &lt;Variable&gt;=&lt;Value&gt;&#93;... &#91;USEPROCESSVARS&#93;
      &#91;WORKLOAD &lt;Name&gt;&#93; &#91;TITLE &lt;Title&gt;&#93; &#91;WAIT &#91;&lt;Number&gt;[s|m|h|d|w]&#93; | ASYNC&#93;
      &#91;STOPUSING &lt;Method&gt;&#93; &#91;STATICHANDLENAME &lt;Name&gt;&#93;
      &#91;NEWCONSOLE | SAMECONSOLE&#93; &#91;FOCUS &lt;Background | Foreground | Minimized&gt;&#93;
      &#91;USERNAME &lt;User name&gt; &#91;PASSWORD &lt;Password&gt;&#93;&#93;
      &#91;DISABLEDAUTHISERROR | IGNOREDISABLEDAUTH&#93;
      &#91;STDIN &lt;File&gt;&#93; &#91;STDOUT &lt;File&gt; | STDOUTAPPEND &lt;File&gt;&#93;
      &#91;STDERR &lt;File&gt; | STDERRAPPEND &lt;File&gt; | STDERRTOSTDOUT&#93;
      &#91;RETURNSTDOUT&#93; &#91;RETURNSTDERR&#93; &#91;RETURNFILE &lt;File&gt;&#93;...
      &#91;NOTIFY ONEND &#91;HANDLE &lt;Handle&gt; | NAME &lt;Name&gt;&#93;
      &#91;MACHINE &lt;Machine&gt;&#93; &#91;PRIORITY &lt;Priority&gt;&#93; &#91;KEY &lt;Key&gt;&#93;&#93;
 
STOP  &lt;ALL CONFIRM | WORKLOAD &lt;Name&gt; | HANDLE &lt;Handle&gt;&gt; &#91;USING &lt;Method&gt;&#93;
 
KILL  PID &lt;Pid&gt; CONFIRM &#91;USING &lt;Method&gt;&#93;
 
LIST  &#91;HANDLES&#93; &#91;RUNNING&#93; &#91;COMPLETED&#93; &#91;WORKLOAD &lt;Name&gt;&#93; &#91;LONG&#93;
LIST  SETTINGS
 
QUERY HANDLE &lt;Handle&gt;&gt;
 
FREE  &lt;ALL | WORKLOAD &lt;Name&gt; | HANDLE &lt;Handle&gt;&gt;
 
NOTIFY REGISTER   ONENDOFHANDLE &lt;Handle&gt; &#91;HANDLE &lt;Handle&gt; | NAME &lt;Name&gt;&#93;
                  &#91;MACHINE &lt;Machine&gt;&#93; &#91;PRIORITY &lt;Priority&gt;&#93;
 
NOTIFY UNREGISTER ONENDOFHANDLE &lt;Handle&gt; &#91;HANDLE &lt;Handle&gt; | NAME &lt;Name&gt;&#93;
                  &#91;MACHINE &lt;Machine&gt;&#93; &#91;PRIORITY &lt;Priority&gt;&#93;
                  
NOTIFY LIST       ONENDOFHANDLE &lt;Handle&gt;
 
SET   &#91;DEFAULTSTOPUSING &lt;Method&gt;&#93; &#91;DEFAULTCONSOLE &lt;New | Same&gt;&#93;
      &#91;DEFAULTFOCUS &lt;Background | Foreground | Minimized&gt;&#93;
      &#91;PROCESSAUTHMODE &lt;Auth Mode&gt;&#93;
      &#91;DEFAULTAUTHUSERNAME &lt;User Name&gt;&#93; &#91;DEFAULTAUTHPASSWORD &lt;Password&gt;&#93;
      &#91;DEFAULTAUTHDISABLEDACTION &lt;Error | Ignore&gt;&#93; &#91;DEFAULTSHELL &lt;Shell&gt;&#93;
      &#91;DEFAULTNEWCONSOLESHELL &lt;Shell&gt;&#93; &#91;DEFAULTSAMECONSOLESHELL &lt;Shell&gt;&#93;
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>QUEUE</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows you to manipulate and manage queues.
<P>
<PRE>
QUEUE  MESSAGE &lt;Message&gt;
       &#91;HANDLE &lt;Handle&gt;&#93; | &#91;NAME &lt;Name&gt;&#93; &#91;PRIORITY &lt;Priority&gt;&#93; &#91;TYPE &lt;Type&gt;&#93;
 
GET    &#91;PRIORITY &lt;Priority&gt;&#93;... &#91;MACHINE &lt;Endpoint&gt;&#93;... &#91;NAME &lt;Name&gt;&#93;...
       &#91;HANDLE &lt;Handle&gt;&#93;... &#91;USER &lt;User&gt;&#93;... &#91;TYPE &lt;Type&gt;&#93;...
       &#91;CONTAINS &lt;String&gt;&#93;... &#91;ICONTAINS &lt;String&gt;&#93;...
       &#91;FIRST &lt;Number&gt; | ALL&#93;
       &#91;WAIT &#91;&lt;Number&gt;[s|m|h|d|w]&#93;&#93;
 
PEEK   &#91;PRIORITY &lt;Priority&gt;&#93;... &#91;MACHINE &lt;Endpoint&gt;&#93;... &#91;NAME &lt;Name&gt;&#93;...
       &#91;HANDLE &lt;Handle&gt;&#93;... &#91;USER &lt;User&gt;&#93;... &#91;TYPE &lt;Type&gt;&#93;...
       &#91;CONTAINS &lt;String&gt;&#93;... &#91;ICONTAINS &lt;String&gt;&#93;...
       &#91;FIRST &lt;Number&gt; | ALL&#93;
       &#91;WAIT &#91;&lt;Number&gt;[s|m|h|d|w]&#93;&#93;
 
DELETE &#91;PRIORITY &lt;Priority&gt;&#93;... &#91;MACHINE &lt;Endpoint&gt;&#93;... &#91;NAME &lt;Name&gt;&#93;...
       &#91;HANDLE &lt;Handle&gt;&#93;... &#91;USER &lt;User&gt;&#93;... &#91;TYPE &lt;Type&gt;&#93;...
       &#91;CONTAINS &lt;String&gt;&#93;... &#91;ICONTAINS &lt;String&gt;&#93;...
 
LIST   &#91;HANDLE &lt;Handle&gt;&#93;
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>RESPOOL</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows you to manage exclusive access to entries within resource pools.
<P>
<PRE>
CREATE  POOL &lt;PoolName&gt; DESCRIPTION &lt;Pooltext&gt;
 
DELETE  POOL &lt;PoolName&gt; CONFIRM &#91;FORCE&#93;
 
QUERY   POOL &lt;PoolName&gt;
 
REQUEST POOL &lt;PoolName&gt;
        &#91;FIRST | RANDOM | ENTRY &lt;Value&gt; &#91;RELEASE&#93;&#93; &#91;PRIORITY &lt;Number&gt;&#93;
        &#91;TIMEOUT &lt;Number&gt;[s|m|h|d|w]&#93; &#91;GARBAGECOLLECT &lt;Yes | No&gt;&#93;
 
RELEASE POOL &lt;PoolName&gt; ENTRY &lt;Value&gt; &#91;FORCE&#93;
 
CANCEL  POOL &lt;PoolName&gt;
        &#91;FORCE &#91;MACHINE &lt;Machine&gt;&#93; &#91;HANDLE &lt;Handle #&gt; | NAME &lt;Handle Name&gt;&#93;&#93;
        &#91;ENTRY &lt;Entry&gt;&#93; &#91;PRIORITY &lt;Number&gt;&#93; &#91;FIRST | LAST&#93;
 
ADD     POOL &lt;PoolName&gt; ENTRY &lt;Value&gt; &#91;ENTRY &lt;Value&gt;&#93;...
 
REMOVE  POOL &lt;PoolName&gt; ENTRY &lt;Value&gt; &#91;ENTRY &lt;Value&gt;&#93;... CONFIRM &#91;FORCE&#93;
 
LIST    [POOLS | SETTINGS]
 
VERSION
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>SEM</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows you to manipulate and manage mutex and event semaphores.
<P>
<PRE>
REQUEST MUTEX &lt;Name&gt; &#91;TIMEOUT &lt;Number&gt;[s|m|h|d|w]&#93; &#91;GARBAGECOLLECT &lt;Yes | No&gt;&#93;
RELEASE MUTEX &lt;Name&gt; &#91;FORCE&#93;
CANCEL  MUTEX &lt;Name&gt;
        &#91;FORCE [MACHINE &lt;Machine&gt;&#93; &#91;HANDLE &lt;Handle #&gt; | NAME &lt;Handle Name&gt;&#93;&#93;
        &#91;FIRST | LAST&#93;
 
POST    EVENT &lt;Name&gt;
RESET   EVENT &lt;Name&gt;
PULSE   EVENT &lt;Name&gt;
WAIT    EVENT &lt;Name&gt; &#91;TIMEOUT &lt;Number&gt;[s|m|h|d|w]&#93;
 
DELETE  MUTEX &lt;Name&gt; | EVENT &lt;Name&gt;
QUERY   MUTEX &lt;Name&gt; | EVENT &lt;Name&gt;
LIST    MUTEX | EVENT
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>SERVICE</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows you to manage STAF services and requests.
<P>
<PRE>
LIST    &#91; SERVICES | SERVICELOADERS | AUTHENTICATORS |
          REQUESTS &lt;&#91;PENDING&#93; &#91;COMPLETE&#93; &#91;LONG&#93;&gt; | &#91;SUMMARY&#93; &#93;
 
QUERY   SERVICE &lt;Service Name&gt; | SERVICELOADER &lt;ServiceLoader Name&gt; |
        AUTHENTICATOR &lt;Authenticator Name&gt; | REQUEST &lt;Request Number&gt;
 
ADD     SERVICE &lt;Service Name&gt; LIBRARY &lt;Library Name&gt;
        &#91;EXECUTE &lt;Executable&gt;&#93; &#91;OPTION &lt;Name=&#91;=Value&#93;&gt;&#93;...
        &#91;PARMS &lt;Parameters&gt;&#93;
 
REMOVE  SERVICE &lt;Service Name&gt;
 
FREE    REQUEST &lt;Request Number&gt; [FORCE]
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>SHUTDOWN</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows you to manage the STAFProc daemon process.
<P>
<PRE>
SHUTDOWN
 
NOTIFY REGISTER   &#91;MACHINE &lt;Machine&gt;&#93; &#91;HANDLE &lt;Handle&gt; | NAME &lt;Name&gt;&#93;
                  &#91;PRIORITY &lt;Priority&gt;&#93;
 
NOTIFY UNREGISTER &#91;MACHINE &lt;Machine&gt;&#93; &#91;HANDLE &lt;Handle&gt; | NAME &lt;Name&gt;&#93;
                  &#91;PRIORITY &lt;Priority&gt;&#93;
 
NOTIFY LIST
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>TRACE</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows you to turn tracing on and off at the service and tracepoint level.
<P>
<PRE>
ENABLE ALL  &#91; TRACEPOINTS | SERVICES &#93;
ENABLE TRACEPOINTS &lt;Trace point list&gt; | SERVICES &lt;Service list&gt;
ENABLE TRACEPOINT &lt;Trace point&gt; &#91;TRACEPOINT &lt;Trace point&gt;&#93;...
ENABLE SERVICE &lt;Service&gt; &#91;SERVICE &lt;Service&gt;&#93;...
 
DISABLE ALL  &#91; TRACEPOINTS | SERVICES &#93;
DISABLE TRACEPOINTS &lt;Trace point list&gt; | SERVICES &lt;Service list&gt;
DISABLE TRACEPOINT &lt;Trace point&gt; &#91;TRACEPOINT &lt;Trace point&gt;&#93;...
DISABLE SERVICE &lt;Service&gt; &#91;SERVICE &lt;Service&gt;&#93;...
 
SET DESTINATION TO &lt; &#91;STDOUT | STDERR&#93; &#91;FILE &lt;File name&gt; [APPEND]&#93; &gt;
SET DEFAULTSERVICESTATE &lt; Enabled | Disabled &gt;
 
LIST &#91;SETTINGS&#93;
 
PURGE
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>TRUST</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows you to manipulate and manage trust levels (security).
<P>
<PRE>
SET &lt; MACHINE &lt;Machine&gt; | USER &lt;User&gt; | DEFAULT &gt; LEVEL &lt;Level&gt;
 
GET MACHINE &lt;Machine&gt; &#91;USER &lt;User&gt;&#93;
 
DELETE MACHINE &lt;Machine&gt; | USER &lt;User&gt;
 
LIST
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>VAR</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows you to manipulate and manage system, shared and process specific variable pools.
<P>
<PRE>
SET &#91;SYSTEM | SHARED | HANDLE &lt;Handle&gt;&#93; &#91;FAILIFEXISTS&#93;
    VAR &lt;Name=Value&gt; &#91;VAR &lt;Name=Value&gt;&#93;...
 
GET &#91;SYSTEM | SHARED | HANDLE &lt;Handle&gt;&#93; VAR &lt;Name&gt;
 
DELETE &#91;SYSTEM | SHARED | HANDLE &lt;Handle&gt;&#93; VAR &lt;Name&gt; &#91;VAR &lt;Name&gt;&#93;...
 
LIST &#91;SYSTEM | SHARED | HANDLE &lt;Handle&gt; | ASHANDLE &lt;Handle&gt; | REQUEST &#91;&lt;Number&gt;&#93;&#93;
 
RESOLVE &#91;SYSTEM | SHARED | HANDLE &lt;Handle&gt; | ASHANDLE &lt;Handle&gt; | REQUEST &#91;&lt;Number&gt;&#93;&#93;
        STRING &lt;String&gt; &#91;STRING &lt;String&gt;&#93;...
 
HELP
</PRE>
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="20%"><B>ZIP</B>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="80%">Allows for unzipping, listing, and adding/deleting entries in Zip archives which are
PKZip, WinZip and Jar compatible.
<P>
<PRE>
UNZIP  ZIPFILE &lt;Name&gt; TODIRECTORY &lt;Name&gt;
       &#91;FILE &lt;Name&gt;&#93;... &#91;DIRECTORY &lt;Name&gt;&#93;...
       &#91;RESTOREPERMISSION&#93; &#91;REPLACE&#93;
       
ADD    ZIPFILE &lt;Name&gt; &lt; FILE &lt;Name&gt; | DIRECTORY &lt;Name&gt; &#91;RECURSE&#93; &gt;
       &#91;RELATIVETO &lt;Directory&gt;&#93;
 
DELETE ZIPFILE &lt;Name&gt; FILE &lt;Name&gt; &#91;FILE &lt;Name&gt;&#93;... CONFIRM
 
LIST   ZIPFILE &lt;Name&gt;
 
VERSION
 
HELP
</PRE>
</TD></TR></TABLE>
<P>
<P>
<A NAME="IDX743"></A>
<HR><H1><A NAME="HDRSAMPREF" HREF="#ToC_981">Appendix C. Samples Descriptions</A></H1>
<BR>
<P><B><A NAME="TBLSAMPTAB">Table 110. STAF Sample Code</A></B><BR>
<TABLE  BORDER>
<TR>
<TH ALIGN="LEFT" VALIGN="TOP" WIDTH="14%">Name
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Description
</TH><TH ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">Comments
</TH></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%"><A HREF="#HDRJAVSAM1">D.1.1, "Java Sample 1"</A>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Java Ping Sample
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This sample uses the STAF Ping command to ping a STAF client
and measure the throughput.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%"><A HREF="#HDRREXSAM1">D.2.1, "Rexx Sample 1"</A>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Rexx Synchronous Process Sample
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This sample loads the STAF Functions, registers to STAF, queries
a system variable from STAF, initiates a synchronous process
which is a chkdsk of the boot drive, then unregisters.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%"><A HREF="#HDRREXSAM2">D.2.2, "Rexx Sample 2"</A>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Rexx Asynchronous Process Sample
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This sample loads REXX and STAF Functions, registers to STAF,
sets a system variable, initiates an asynchronous PMSEEK process,
list variables, queries process status, stops PMSEEK, queries
process status again, frees the process, queries the system
variable previously set, then unregisters.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%"><A HREF="#HDRREXSAM3">D.2.3, "Rexx Sample 3"</A>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Rexx Monitor Sample
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This sample loads STAF Functions, registers to STAF,
writes a monitor message and then queries it, this is done 10 times,
then it unregisters. The size of the monitor messages written
is based on a random number generated.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%"><A HREF="#HDRREXSAM4">D.2.4, "Rexx Sample 4"</A>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Rexx Log Sample
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This sample loads STAF Functions, registers to STAF, writes and
queries 10 log messages to a global log called LOGTEST, then unregisters.
The size of the log messages written is based on a random number generated.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%"><A HREF="#HDRREXSAM5">D.2.5, "Rexx Sample 5"</A>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">Rexx Ping Sample
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This sample uses the STAF Ping command to ping a STAF client
and measure the throughput.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%"><A HREF="#HDRCSAM1">D.3.1, "C Sample 1"</A>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">C Log Sample
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This sample logs a message via the STAF LOG service.
</TD></TR><TR>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH="14%"><A HREF="#HDRCPPSAM1">D.4.1, "C++ Sample 1"</A>
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="29%">C++ Log Sample
</TD><TD ALIGN="LEFT" VALIGN="TOP" WIDTH="57%">This sample logs a message via the STAF LOG service.
</TD></TR></TABLE>
<P>
<HR><H1><A NAME="HDRCODE" HREF="#ToC_982">Appendix D. Code Samples and Snipets</A></H1>
<A NAME="IDX744"></A>
<A NAME="IDX746"></A>
<A NAME="IDX748"></A>
<HR><H2><A NAME="HDRJAVASAMP" HREF="#ToC_983">D.1 Java</A></H2>
<P><H3><A NAME="HDRJAVSAM1">D.1.1 Java Sample 1</A></H3>
<PRE>
/*****************************************************************************/
/* Software Testing Automation Framework (STAF)                              */
/* (C) Copyright IBM Corp. 2001                                              */
/*                                                                           */
/* This software is licensed under the Eclipse Public License (EPL) V1.0.    */
/*****************************************************************************/
 
//===========================================================================
// JPing - A multi-threaded STAF PING test
//===========================================================================
// Accepts: Where to PING
//          Optionally, the number of threads to use (default = 5)
//          Optionally, the number of loops per thread (default = 10000)
//          Optionally, the display modulus (default = 250)
//
// Returns: 0 , on success
//          &gt;0, if an error is encountered
//===========================================================================
// Date        Who           Comment
// ----------  ------------  ------------------------------------------
// 04/25/1998  C. Rankin     File Created
//===========================================================================
 
import com.ibm.staf.*;
import java.util.Date;
import java.util.Calendar;
import java.text.DateFormat;
 
public class JPing implements Runnable
{
    // Constructor
 
    public JPing(int numLoops, int displayModulus, int myThreadNum)
    {
        loopCount = numLoops;
        modulus = displayModulus;
        threadNum = myThreadNum;
        errors = 0;
    }
 
    // This is the main command line entry point
 
    public static void main(String [] argv)
    {
        // Verify the command line arguments
 
        if ((argv.length &lt; 1) || (argv.length &gt; 4))
        {
            System.out.println();
            System.out.println("Usage: java JPing &lt;Where&gt; [# Threads] " +
                               "[# Loops per thread] [Display Modulus]");
            System.out.println();
            System.out.println("Defaults:");
            System.out.println();
            System.out.println("  # Threads          = 5");
            System.out.println("  # Loops per thread = 10000");
            System.out.println("  Display Modulus    = 250");
            System.out.println();
            System.out.println("Examples:");
            System.out.println();
            System.out.println("java JPing local");
            System.out.println("java JPing SomeServer 3 1000 100");
            System.exit(1);
        }
 
        // Register with STAF
 
        try
        {
            handle = new STAFHandle("Java_Ping_Test");
        }
        catch (STAFException e)
        {
            System.out.println("Error registering with STAF, RC: " + e.rc);
            System.exit(1);
        }
 
        // Initialize variables
 
        timeFormatter = DateFormat.getTimeInstance(DateFormat.MEDIUM);
 
        where = argv[0];
        int numThreads = 5;
        int numLoops = 10000;
        int displayModulus = 250;
 
        if (argv.length &gt; 1) numThreads = Integer.parseInt(argv[1]);
        if (argv.length &gt; 2) numLoops = Integer.parseInt(argv[2]);
        if (argv.length &gt; 3) displayModulus = Integer.parseInt(argv[3]);
 
        JPing [] pingers = new JPing[numThreads];
        Thread [] threads = new Thread[numThreads];
 
        System.out.println("(0)" + timeFormatter.format(new Date()) +
                           " - Started");
        long startSecs = (new Date()).getTime();
 
        // Start the threads
 
        for(int i = 0; i &lt; numThreads; ++i)
        {
            pingers[i] = new JPing(numLoops, displayModulus, i + 1);
            threads[i] = new Thread(pingers[i]);
            threads[i].start();
        }
 
        // Wait for all the threads to finish
 
        for(int i = 0; i &lt; numThreads; ++i)
        {
            try
            {
                threads[i].join();
            }
            catch (Exception e)
            {
                System.out.println("Exception: " + e);
                System.out.println(e.getMessage());
            }
        }
 
        // Output final pings/sec
 
        long stopSecs = (new Date()).getTime();
        System.out.println("(0)" + timeFormatter.format(new Date()) +
                           " - Ended");
 
        System.out.println("Average: " + ((numLoops * numThreads * 1000) /
                           (stopSecs - startSecs)) + " pings/sec");
 
        // Unregister with STAF
 
        try
        {
            handle.unRegister();
        }
        catch (STAFException e)
        {
            System.out.println("Error unregistering with STAF, RC: " + e.rc);
            System.exit(1);
        }
    }
 
    // This is the method called when each thread starts
 
    public void run()
    {
        for(int i = 1; i &lt;= loopCount; ++i)
        {
            STAFResult result = handle.submit2(where, "PING", "PING");
 
            // If we get a non-zero return code, or a response of something
            // other than "PONG", display an error
 
            if (result.rc != 0)
            {
                System.out.println("(" + threadNum + ")" +
                                   timeFormatter.format(new Date()) +
                                   " - Loop #" + i + ", Error #" +
                                   ++errors + ", RC: " + result.rc);
            }
            else if (result.result.compareTo("PONG") != 0)
            {
                System.out.println("(" + threadNum + ")" +
                                   timeFormatter.format(new Date()) +
                                   " - Loop #" + i + ", Error #" +
                                   ++errors + ", RESULT = " + result.result);
            }
 
            // If we are at our display modulus display a status message
 
            if ((i % modulus) == 0)
            {
                System.out.println("(" + threadNum + ")" +
                                   timeFormatter.format(new Date()) +
                                   " - Ended Loop #" + i + ", Errors = " +
                                   errors);
            }
        }
    }
 
    private static STAFHandle handle;
    private static String where;
    private static DateFormat timeFormatter;
 
    private int loopCount;
    private int modulus;
    private int threadNum;
    private int errors;
}
</PRE>
<A NAME="IDX749"></A>
<A NAME="IDX751"></A>
<A NAME="IDX753"></A>
<HR><H2><A NAME="HDRREXXSAMP" HREF="#ToC_985">D.2 Rexx</A></H2>
<P><H3><A NAME="HDRREXSAM1">D.2.1 Rexx Sample 1</A></H3>
<PRE>
/*****************************************************************************/
/* Software Testing Automation Framework (STAF)                              */
/* (C) Copyright IBM Corp. 2001                                              */
/*                                                                           */
/* This software is licensed under the Eclipse Public License (EPL) V1.0.    */
/*****************************************************************************/
 
/*********************************************************************/
/* Sample1.cmd - Rexx sample program using STAF                      */
/*********************************************************************/
/* This sample loads the STAF Functions, registers to STAF, queries  */
/* a global variable from STAF, inititates a synchronous process     */
/* which is a chkdsk of the boot drive, then unregisters.            */
/*                                                                   */
/* Returns: 0, on success                                            */
/*         &gt;0, if an error is encountered                            */
/*********************************************************************/
/* Date        Who           Comment                                 */
/* ----------  ------------  --------------------------------------- */
/* 02/01/1998  D. Randall    File Created                            */
/*********************************************************************/
SIGNAL ON HALT NAME STAFAbort
 
/* Load STAF functions */
call RxFuncAdd "STAFLoadFuncs", "RXSTAF", "STAFLoadFuncs"
call STAFLoadFuncs
 
/* Register to STAF */
call STAFRegister "STAF_REXX_Sample1"
if RESULT \= 0 then
do
  say "Error registering to STAF:" RESULT
  RETURN RESULT
end
 
/* Query STAF for a variable */
STAFRC = STAFSubmit("local", "var", "resolve {STAF/Config/BootDrive}")
if STAFRC = 0 then
  bootdrive = STAFResult
else
do
  say "Unable to determine boot drive!"
  call STAFUnRegister
  RETURN STAFRC
end
 
/* Build the process start request with a work load name of STAFSample */
request = "START WAIT COMMAND chkdsk.com WORKLOAD STAFSample"
 
/* Pass the boot drive parameter to chkdsk */
parms = "PARMS" bootdrive
 
/* Query STAF for a variable */
STAFRC = STAFSubmit("local", "var", "resolve {STAF/Config/Sep/File}")
if STAFRC = 0 then
  filesep = STAFResult
else
do
  say "Unable to determine file seperator!"
  call STAFUnRegister
  RETURN STAFRC
end
 
/* Set the working directory */
workdir = "WORKDIR" bootdrive||filesep
 
/* Submit the request to STAF */
say "Attempting to CHKDSK bootdrive" bootdrive
STAFRC = STAFSubmit("local", "process", request parms workdir)
say "Submit Return Code="STAFRC ", Result="STAFResult
 
/* Unregister */
call STAFUnRegister
RETURN 0
 
/*********************************************************************/
/* STAFAbort - If user aborts, make sure STAF unregister occurs.     */
/*********************************************************************/
STAFAbort:
  call STAFUnRegister
  EXIT 1
</PRE>
<P><H3><A NAME="HDRREXSAM2">D.2.2 Rexx Sample 2</A></H3>
<PRE>
/*****************************************************************************/
/* Software Testing Automation Framework (STAF)                              */
/* (C) Copyright IBM Corp. 2001                                              */
/*                                                                           */
/* This software is licensed under the Eclipse Public License (EPL) V1.0.    */
/*****************************************************************************/
 
/*********************************************************************/
/* Sample2.cmd - Rexx sample program using STAF                      */
/*********************************************************************/
/* This sample loads REXX and STAF Functions, registers to STAF,     */
/* inititates an asynchronous PMSEEK process, queries, stops,        */
/* queries again then frees the process, then unregisters.           */
/*                                                                   */
/* Note that this example explictly uses STAFHandle in all calls     */
/* and additional error checking is needed.                          */
/*                                                                   */
/* Returns: 0,  on success                                           */
/*         &gt;0, if an error is encountered                            */
/*********************************************************************/
/* Date        Who           Comment                                 */
/* ----------  ------------  --------------------------------------- */
/* 02/02/1998  D. Randall    File Created                            */
/*********************************************************************/
SIGNAL ON HALT NAME STAFAbort
 
/* Load system functions */
call RxFuncAdd "SysLoadFuncs", "REXXUTIL", "SysLoadFuncs"
call SysLoadFuncs
 
/* Load STAF functions */
call RxFuncAdd "STAFLoadFuncs", "RXSTAF", "STAFLoadFuncs"
call STAFLoadFuncs
 
/* Register Sample to STAF */
call STAFRegister "STAF_REXX_Sample2", "STAFHandle"
if RESULT \= 0 then
do
  say "Error registering to STAF:" RESULT
  RETURN RESULT
end
 
/* Set a global variable for start timestamp */
request = " GLOBAL SET Start="||DATE('s')||'-'||TIME()
STAFRC = STAFSubmit(STAFHandle, "local", "VAR", request)
 
/* Build the process start request with a work load name of STAFSample2 */
request = "START COMMAND pmseek.exe WORKLOAD STAFSample2"
 
/* Submit the request to STAF */
STAFRC = STAFSubmit(STAFHandle, "local", "PROCESS", request)
if STAFRC = 0 then
do
  PROCHandle = STAFResult
  STAFRC = STAFSubmit(STAFHandle, "local", "VAR", "LIST")
  say STAFResult
  say "Press &lt;Enter&gt; to continue"
  pull response
 
  request = "query handle" PROCHandle
  STAFRC = STAFSubmit(STAFHandle, "local", "PROCESS", request)
  say STAFResult
  say "Press &lt;Enter&gt; to stop PMSEEK"
  pull response
 
  STAFRC = STAFSubmit(STAFHandle, "local", "PROCESS", "STOP HANDLE" PROCHandle)
  call SysSleep 1
 
  STAFRC = STAFSubmit(STAFHandle, "local", "PROCESS", request)
  say STAFResult
 
  STAFRC = STAFSubmit(STAFHandle, "local", "PROCESS", "FREE HANDLE" PROCHandle)
 
  STAFRC = STAFSubmit(STAFHandle, "local", "var", "resolve {Start}")
  if (STAFRC = 0) & (STAFResult \= '') then Start = STAFResult
 
  say "Start =" Start
  say "End   =" DATE('s')||'-'||TIME()
end
 
/* Unregister */
call STAFUnRegister STAFHandle
RETURN 0
 
/*********************************************************************/
/* STAFAbort - If user aborts, make sure STAF unregister occurs.     */
/*********************************************************************/
STAFAbort:
  call STAFUnRegister STAFHandle
  EXIT 1
</PRE>
<P><H3><A NAME="HDRREXSAM3">D.2.3 Rexx Sample 3</A></H3>
<PRE>
/*****************************************************************************/
/* Software Testing Automation Framework (STAF)                              */
/* (C) Copyright IBM Corp. 2001                                              */
/*                                                                           */
/* This software is licensed under the Eclipse Public License (EPL) V1.0.    */
/*****************************************************************************/
 
/*********************************************************************/
/* Sample3.cmd - Rexx sample program using STAF                      */
/*********************************************************************/
/* This sample writes a monitor message and then queries it, this    */
/* is done 10 times.  A size of the string written is based on a     */
/* random number generated.                                          */
/*                                                                   */
/* Returns: 0, on success                                            */
/*         &gt;0, if an error is encountered                            */
/*********************************************************************/
/* Date        Who           Comment                                 */
/* ----------  ------------  --------------------------------------- */
/* 03/01/1998  D. Randall    File Created                            */
/*********************************************************************/
SIGNAL ON HALT NAME STAFAbort
 
/* Load STAF functions */
call RxFuncAdd "STAFLoadFuncs", "RXSTAF", "STAFLoadFuncs"
call STAFLoadFuncs
 
/* Register Sample to STAF */
call STAFRegister "STAF_REXX_Sample3"
if RESULT \= 0 then
do
  say "Error registering to STAF:" RESULT
  RETURN RESULT
end
 
/* Query STAF for a variable */
STAFRC = STAFSubmit("local", "var", "resolve {STAF/Config/MachineNickname}")
if STAFRC = 0 then machine = STAFResult
else
do
  say "Unable to determine machine nickname!"
  call STAFUnRegister
  RETURN STAFRC
end
 
service = "monitor"
times = 10
wait = 0
string = "Software Testing Automation Framework (STAF) (C) Copyright IBM Corp.",
         "1998 All Rights Reserved"
 
do times
  message = substr(string,1,1 + random(99))
  msglen = length(message)
  data = "LOG MESSAGE :"msglen":"message
  STAFRC = STAFSubmit("local", service, data)
  if STAFRC \= 0 then
    say "Monitor Log Error: " STAFRC STAFResult
 
  data = "query machine" machine "handle" STAFHandle
  STAFRC = STAFSubmit("local", service, data)
  if STAFRC = 0 then
    say STAFResult
  else
    say "Monitor Query Error: " STAFRC STAFResult
end
 
/* Unregister */
call STAFUnRegister
RETURN 0
 
/*********************************************************************/
/* STAFAbort - If user aborts, make sure STAF unregister occurs.     */
/*********************************************************************/
STAFAbort:
  call STAFUnRegister
  EXIT 1
 
</PRE>
<P><H3><A NAME="HDRREXSAM4">D.2.4 Rexx Sample 4</A></H3>
<PRE>
/*****************************************************************************/
/* Software Testing Automation Framework (STAF)                              */
/* (C) Copyright IBM Corp. 2001                                              */
/*                                                                           */
/* This software is licensed under the Eclipse Public License (EPL) V1.0.    */
/*****************************************************************************/
 
/*********************************************************************/
/* Sample4.cmd - Rexx sample program using STAF                      */
/*********************************************************************/
/* This sample writes 10 log messages to a global log file called    */
/* LOGTEST and then queries them.  The size of the string written is */
/* based on a random number generated.                               */
/*                                                                   */
/* Returns: 0, on success                                            */
/*         &gt;0, if an error is encountered                            */
/*********************************************************************/
/* Date        Who           Comment                                 */
/* ----------  ------------  --------------------------------------- */
/* 03/02/1998  D. Randall    File Created                            */
/*********************************************************************/
SIGNAL ON HALT NAME STAFAbort
 
/* Load STAF functions */
call RxFuncAdd "STAFLoadFuncs", "RXSTAF", "STAFLoadFuncs"
call STAFLoadFuncs
 
/* Register Sample to STAF */
call STAFRegister "STAF_REXX_Sample4"
if RESULT \= 0 then
do
  say "Error registering to STAF:" RESULT
  RETURN RESULT
end
 
/* Query STAF for a variable */
STAFRC = STAFSubmit("local", "var", "global resolve {STAF/Config/Machine}")
if STAFRC = 0 then machine = STAFResult
else
do
  say "Unable to determine machine name!"
  call STAFUnRegister
  RETURN STAFRC
end
 
service = "LOG"
times = 10
count = 0
level = error
logtype = "log global logname "
logname=LogTest
string = "Software Testing Automation Framework (STAF) (C) Copyright IBM Corp.",
         "1998. All Rights Reserved"
 
say  "Settings:" logtype logname "level" level "(times="  times ")"
do count = 1 for times
  message = substr(string,1,1 + random(99))
  msglen = length(message)
  data = "LOG GLOBAL LOGNAME" logname "LEVEL" level "MESSAGE :"msglen":"message
  STAFRC = STAFSubmit("LOCAL", service, data)
  if STAFRC \= 0 then
    say "Log Error: " STAFRC STAFResult
  say count "of" times "Logged"
end
 
say "Querying last 10 log records..."
data = "QUERY GLOBAL LOGNAME" logname "LAST 10"
STAFRC = STAFSubmit("local", service, data)
say STAFResult
 
/* Unregister */
call STAFUnRegister
RETURN 0
 
/*********************************************************************/
/* STAFAbort - If user aborts, make sure STAF unregister occurs.     */
/*********************************************************************/
STAFAbort:
  call STAFUnRegister
EXIT 1
</PRE>
<P><H3><A NAME="HDRREXSAM5">D.2.5 Rexx Sample 5</A></H3>
<PRE>
/*****************************************************************************/
/* Software Testing Automation Framework (STAF)                              */
/* (C) Copyright IBM Corp. 2001                                              */
/*                                                                           */
/* This software is licensed under the Eclipse Public License (EPL) V1.0.    */
/*****************************************************************************/
 
/*********************************************************************/
/* Sample5.cmd - Rexx sample program using STAF                      */
/*********************************************************************/
/* This sample uses the STAF Ping command to ping a STAF client and  */
/* and measure the throughput.                                       */
/*                                                                   */
/* Accepts: [Machine] [LoopCount] [DisplayModulus]                   */
/*                                                                   */
/* Returns: 0, on success                                            */
/*         &gt;0, if an error is encountered                            */
/*********************************************************************/
/* Date        Who           Comment                                 */
/* ----------  ------------  --------------------------------------- */
/* 03/02/1998  C. Rankin     File Created                            */
/*********************************************************************/
SIGNAL ON HALT NAME STAFAbort
 
parse arg Machine LoopCount DisplayModulus
 
if (Machine = "?") | (Machine = "/?") | (Machine = "-?") then
do
    say
    say "Usage: PingTest [Machine] [LoopCount] [DisplayModulus]"
    RETURN 1
end
 
if Machine = "" then Machine = "LOCAL"
if LoopCount = "" then LoopCount = 999999999
if DisplayModulus = "" then DisplayModulus = 1000
 
call RxFuncAdd "STAFLoadFuncs", "RXSTAF", "STAFLoadFuncs"
call STAFLoadFuncs
 
call STAFRegister "STAF_PING_Test", "STAFHandle"
if RESULT \= 0 then
do
    say "Error registering with STAF, RC:" RESULT
    RETURN 1
end
 
say TIME() "- Started"
 
startDate = DATE('B')
startTime = TIME('S')
errors = 0
 
do i=1 to LoopCount
    call STAFSubmit STAFHandle, Machine, "PING", "PING"
 
    if RESULT \= 0 then
    do
        errors = errors + 1
        say TIME() "- Loop #"i", Error #"errors", RC:" RESULT
    end
    else if STAFResult \= "PONG" then
    do
        errors = errors + 1
        say TIME() "- Loop #"i", Error #"errors", STAFResult =" STAFResult
    end
 
    if i // DisplayModulus = 0 then
        say TIME() "- Ended Loop #"i", Errors =" errors
end
 
call AtEnd
 
RETURN 0
 
 
/*********************************************************************/
/* AtEnd - Unregister from STAF and calculate final PING throughput. */
/*********************************************************************/
AtEnd:
 
    call STAFUnRegister STAFHandle
    say TIME() "- Ended"
 
    endTime = TIME('S')
    endDate = DATE('B')
 
    endSecs = ((endDate - 720000) * 86400) + endTime
    startSecs = ((startDate - 720000) * 86400) + startTime
 
    say "Average:" FORMAT((i / (endSecs - startSecs)), 3, 2) "pings/sec"
 
    RETURN 0
 
 
/*********************************************************************/
/* STAFAbort - If user aborts, make sure STAF unregister occurs.     */
/*********************************************************************/
STAFAbort:
 
    call AtEnd
    EXIT 1
</PRE>
<A NAME="IDX754"></A>
<A NAME="IDX756"></A>
<A NAME="IDX758"></A>
<HR><H2><A NAME="HDRCSAMP" HREF="#ToC_991">D.3 C</A></H2>
<P><H3><A NAME="HDRCSAM1">D.3.1 C Sample 1</A></H3>
<PRE>
/*****************************************************************************/
/* Software Testing Automation Framework (STAF)                              */
/* (C) Copyright IBM Corp. 2001                                              */
/*                                                                           */
/* This software is licensed under the Eclipse Public License (EPL) V1.0.    */
/*****************************************************************************/
 
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include "STAF.h"
 
unsigned int logIt(char *type, char *name, char *level, char *message);
 
// This could be a handy macro.
// Just set gLogType and gLogName to the appropriate values.
// Then you can use the macro as follows
//    LOGIT("INFO", "This is some data I want to log");
 
#define LOGIT(level, message) logIt(gLogType, gLogName, level, message)
 
char *gLogType = "GLOBAL";
char *gLogName = "MyLog";
 
char *gRegName = "Logit";
STAFHandle_t gHandle = 0;
 
int main(int argc, char **argv)
{
    unsigned int rc = 0;
 
    if (argc != 5)
    {
        printf("Usage: %s &lt;Type&gt; &lt;Name&gt; &lt;Level&gt; &lt;Message&gt;\n", argv[0]);
        return 1;
    }
 
    if ((rc = STAFRegister(gRegName, &gHandle)) != 0)
    {
        printf("Error registering with STAF, RC: %d\n", rc);
        return rc;
    }
 
    if ((rc = logIt(argv[1], argv[2], argv[3], argv[4])) != 0)
    {
        printf("Error logging data to STAF, RC: %d\n", rc);
        return rc;
    }
 
    if ((rc = STAFUnRegister(gHandle)) != 0)
    {
        printf("Error unregistering with STAF, RC: %d\n", rc);
        return rc;
    }
 
    return rc;
}
 
unsigned int logIt(char *type, char *name, char *level, char *message)
{
    static char *where = "LOCAL";
    static char *service = "LOG";
    static char buffer[4000] = { 0 };
    char *resultPtr = 0;
    unsigned int resultLength = 0;
    unsigned int rc = 0;
 
    sprintf(buffer, "LOG %s LOGNAME %s LEVEL %s MESSAGE :%d:%s", type, name,
            level, strlen(message), message);
 
    rc = STAFSubmit(gHandle, where, service, buffer, strlen(buffer),
                    &resultPtr, &resultLength);
 
    STAFFree(gHandle, resultPtr);
 
    return rc;
}
</PRE>
<A NAME="IDX759"></A>
<A NAME="IDX761"></A>
<A NAME="IDX763"></A>
<HR><H2><A NAME="HDRC++SAMP" HREF="#ToC_993">D.4 C++</A></H2>
<P><H3><A NAME="HDRCPPSAM1">D.4.1 C++ Sample 1</A></H3>
<PRE>
/*****************************************************************************/
/* Software Testing Automation Framework (STAF)                              */
/* (C) Copyright IBM Corp. 2001                                              */
/*                                                                           */
/* This software is licensed under the Eclipse Public License (EPL) V1.0.    */
/*****************************************************************************/
 
#include "STAF.h"
#include "STAF_iostream.h"
#include "STAFString.h"
 
STAFResultPtr logIt(const STAFString &type, const STAFString &name,
                    const STAFString &level, const STAFString &message);
 
// This could be a handy macro.
// Just set gLogType and gLogName to the appropriate values.
// Then you can use the macro as follows
//    LOGIT("INFO", "This is some data I want to log");
 
#define LOGIT(level, message) logIt(gLogType, gLogName, level, message)
 
STAFString gLogType("GLOBAL");
STAFString gLogName("MyLog");
STAFString gRegName("Logit");
STAFHandlePtr gHandle;
 
int main(int argc, char **argv)
{
    if (argc != 5)
    {
        cout &lt;&lt; "Usage: LogIt &lt;Type&gt; &lt;Name&gt; &lt;Level&gt; &lt;Message&gt;" &lt;&lt; endl;
        return 1;
    }
 
    unsigned int rc = STAFHandle:&#58;create(gRegName, gHandle);
 
    if (rc != 0)
    {
        cout &lt;&lt; "Error registering with STAF, RC: " &lt;&lt; rc &lt;&lt; endl;
        return rc;
    }
 
    STAFResultPtr result = logIt(argv[1], argv[2], argv[3], argv[4]);
 
    if (result-&gt;rc != 0)
    {
        cout &lt;&lt; "Error logging to STAF, RC: " &lt;&lt; result-&gt;rc
             &lt;&lt; " RESULT: " &lt;&lt; result-&gt;result &lt;&lt; endl;
    }
 
    return result-&gt;rc;
}
 
STAFResultPtr logIt(const STAFString &type, const STAFString &name,
                    const STAFString &level, const STAFString &message)
{
    static STAFString where("LOCAL");
    static STAFString service("LOG");
 
    STAFString request("LOG " + type + " LOGNAME " + name + " LEVEL " +
                       level + " MESSAGE " + STAFHandle:&#58;wrapData(message)); 
 
    return gHandle-&gt;submit(where, service, request);
}
</PRE>
<HR><H1><A NAME="HDRINDEX_START" HREF="#ToC_995">Index</A></H1>
<A NAME="IDX0_41" HREF="#IDX1_41">A</A>
<A NAME="IDX0_43" HREF="#IDX1_43">C</A>
<A NAME="IDX0_44" HREF="#IDX1_44">D</A>
<A NAME="IDX0_45" HREF="#IDX1_45">E</A>
<A NAME="IDX0_46" HREF="#IDX1_46">F</A>
<A NAME="IDX0_48" HREF="#IDX1_48">H</A>
<A NAME="IDX0_49" HREF="#IDX1_49">I</A>
<A NAME="IDX0_4A" HREF="#IDX1_4A">J</A>
<A NAME="IDX0_4C" HREF="#IDX1_4C">L</A>
<A NAME="IDX0_4D" HREF="#IDX1_4D">M</A>
<A NAME="IDX0_4E" HREF="#IDX1_4E">N</A>
<A NAME="IDX0_4F" HREF="#IDX1_4F">O</A>
<A NAME="IDX0_50" HREF="#IDX1_50">P</A>
<A NAME="IDX0_51" HREF="#IDX1_51">Q</A>
<A NAME="IDX0_52" HREF="#IDX1_52">R</A>
<A NAME="IDX0_53" HREF="#IDX1_53">S</A>
<A NAME="IDX0_54" HREF="#IDX1_54">T</A>
<A NAME="IDX0_55" HREF="#IDX1_55">U</A>
<A NAME="IDX0_56" HREF="#IDX1_56">V</A>
<A NAME="IDX0_57" HREF="#IDX1_57">W</A>
<A NAME="IDX0_5A" HREF="#IDX1_5A">Z</A>
<HR>
<STRONG><A NAME="IDX1_41" HREF="#IDX0_41">A</A></STRONG>
<MENU>
<LI>API Reference 
<A HREF="STAFUG.htm#IDX124">(124)</A>
<LI>Authenticator registration 
<A HREF="STAFUG.htm#IDX74">(74)</A>
</MENU>
<STRONG><A NAME="IDX1_43" HREF="#IDX0_43">C</A></STRONG>
<MENU>
<LI>C API 
<MENU>
<LI>Data Structure and Marshalling APIs 
<A HREF="STAFUG.htm#IDX159">(159)</A>
<LI>Other APIs 
<A HREF="STAFUG.htm#IDX165">(165)</A>
<LI>Other Utility APIs 
<A HREF="STAFUG.htm#IDX163">(163)</A>
<LI>Private Data Manipulation APIs 
<A HREF="STAFUG.htm#IDX161">(161)</A>
<LI>STAFFree 
<A HREF="STAFUG.htm#IDX154">(154)</A>
<LI>STAFRegister 
<A HREF="STAFUG.htm#IDX128">(128)</A>
<LI>STAFRegisterUTF8 
<A HREF="STAFUG.htm#IDX135">(135)</A>
<LI>STAFSubmit 
<A HREF="STAFUG.htm#IDX144">(144)</A>
<LI>STAFSubmit2UTF8 
<A HREF="STAFUG.htm#IDX152">(152)</A>
<LI>STAFSubmitUTF8 
<A HREF="STAFUG.htm#IDX150">(150)</A>
<LI>STAFUnRegister 
<A HREF="STAFUG.htm#IDX139">(139)</A>
</MENU>
<LI>C code 
<A HREF="STAFUG.htm#IDX754">(754)</A>
<LI>C++ classes 
<MENU>
<LI>STAFHandle 
<A HREF="STAFUG.htm#IDX169">(169)</A>
<LI>STAFMapClassDefinition 
<A HREF="STAFUG.htm#IDX189">(189)</A>
<LI>STAFObject 
<A HREF="STAFUG.htm#IDX177">(177)</A>
<LI>STAFObjectIterator 
<A HREF="STAFUG.htm#IDX182">(182)</A>
<LI>STAFResult 
<A HREF="STAFUG.htm#IDX170">(170)</A>
</MENU>
<LI>C++ code 
<A HREF="STAFUG.htm#IDX759">(759)</A>
<LI>codepage 
<MENU>
<LI>concepts 
<A HREF="STAFUG.htm#IDX24">(24)</A>
</MENU>
<LI>command reference 
<A HREF="STAFUG.htm#IDX741">(741)</A>
<LI>commands 
<MENU>
<LI>FmtLog 
<A HREF="STAFUG.htm#IDX733">(733)</A>
<LI>STAF 
<A HREF="STAFUG.htm#IDX123">(123)</A>
<LI>STAFJVMLogViewer 
<A HREF="STAFUG.htm#IDX716">(716)</A>
<LI>STAFLogFormatter 
<A HREF="STAFUG.htm#IDX725">(725)</A>
<LI>STAFLogViewer 
<A HREF="STAFUG.htm#IDX707">(707)</A>
<LI>STAFProc 
<A HREF="STAFUG.htm#IDX120">(120)</A>
</MENU>
<LI>config service 
<A HREF="STAFUG.htm#IDX236">(236)</A>
<LI>configuration 
<MENU>
<LI>Authenticator registration 
<A HREF="STAFUG.htm#IDX76">(76)</A>
<LI>connection providers 
<A HREF="STAFUG.htm#IDX37">(37)</A>
<LI>data directory structure 
<A HREF="STAFUG.htm#IDX111">(111)</A>
<LI>example 
<A HREF="STAFUG.htm#IDX103">(103)</A>
<LI>instructions 
<A HREF="STAFUG.htm#IDX31">(31)</A>
<LI>Java Virtual Machine 
<A HREF="STAFUG.htm#IDX57">(57)</A>
<LI>machine name 
<A HREF="STAFUG.htm#IDX34">(34)</A>
<LI>network interfaces 
<A HREF="STAFUG.htm#IDX36">(36)</A>
<LI>Operational parameters 
<A HREF="STAFUG.htm#IDX83">(83)</A>
<LI>Perl Interpreter 
<A HREF="STAFUG.htm#IDX61">(61)</A>
<LI>Perl Service Registration 
<A HREF="STAFUG.htm#IDX58">(58)</A>
<LI>PLSTAF 
<A HREF="STAFUG.htm#IDX59">(59)</A>
<LI>Service loader registration 
<A HREF="STAFUG.htm#IDX67">(67)</A>
<LI>Service registration 
<A HREF="STAFUG.htm#IDX51">(51)</A>
<LI>STAFEXECPROXY 
<A HREF="STAFUG.htm#IDX62">(62)</A>, <A HREF="STAFUG.htm#IDX63">(63)</A>
<LI>STAFTCP connection provider 
<A HREF="STAFUG.htm#IDX42">(42)</A>
<LI>STAFTCP network interface 
<A HREF="STAFUG.htm#IDX41">(41)</A>
<LI>start/shutdown notifications 
<A HREF="STAFUG.htm#IDX95">(95)</A>
<LI>tracing 
<A HREF="STAFUG.htm#IDX99">(99)</A>
<LI>trust 
<A HREF="STAFUG.htm#IDX89">(89)</A>
<LI>tuning 
<A HREF="STAFUG.htm#IDX107">(107)</A>
<LI>Unix temporary diretory 
<A HREF="STAFUG.htm#IDX115">(115)</A>
<LI>variables 
<A HREF="STAFUG.htm#IDX85">(85)</A>
</MENU>
<LI>connection providers 
<A HREF="STAFUG.htm#IDX39">(39)</A>, <A HREF="STAFUG.htm#IDX44">(44)</A>
</MENU>
<STRONG><A NAME="IDX1_44" HREF="#IDX0_44">D</A></STRONG>
<MENU>
<LI>data directory structure 
<MENU>
<LI>configuration 
<A HREF="STAFUG.htm#IDX113">(113)</A>
</MENU>
<LI>delay service 
<A HREF="STAFUG.htm#IDX242">(242)</A>
<LI>diag service 
<A HREF="STAFUG.htm#IDX248">(248)</A>
</MENU>
<STRONG><A NAME="IDX1_45" HREF="#IDX0_45">E</A></STRONG>
<MENU>
<LI>echo service 
<A HREF="STAFUG.htm#IDX266">(266)</A>
<LI>error codes 
<MENU>
<LI>help service 
<A HREF="STAFUG.htm#IDX351">(351)</A>
<LI>LifeCycle service 
<A HREF="STAFUG.htm#IDX380">(380)</A>
<LI>log service 
<A HREF="STAFUG.htm#IDX412">(412)</A>
<LI>monitor service 
<A HREF="STAFUG.htm#IDX460">(460)</A>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX555">(555)</A>
<LI>STAF 
<A HREF="STAFUG.htm#IDX740">(740)</A>
<LI>zip service 
<A HREF="STAFUG.htm#IDX701">(701)</A>
</MENU>
<LI>examples 
<MENU>
<LI>C API 
<MENU>
<LI>STAFFree 
<A HREF="STAFUG.htm#IDX157">(157)</A>
<LI>STAFSubmit 
<A HREF="STAFUG.htm#IDX147">(147)</A>
<LI>STAFUnRegister 
<A HREF="STAFUG.htm#IDX142">(142)</A>
</MENU>
<LI>C code 
<A HREF="STAFUG.htm#IDX758">(758)</A>
<LI>C++ Classes 
<MENU>
<LI>STAFHandle 
<A HREF="STAFUG.htm#IDX173">(173)</A>
<LI>STAFObject 
<A HREF="STAFUG.htm#IDX180">(180)</A>
<LI>STAFObjectIterator 
<A HREF="STAFUG.htm#IDX185">(185)</A>
</MENU>
<LI>C++ code 
<A HREF="STAFUG.htm#IDX763">(763)</A>
<LI>C/C++ API 
<MENU>
<LI>STAFRegister 
<A HREF="STAFUG.htm#IDX131">(131)</A>
</MENU>
<LI>configuration file 
<A HREF="STAFUG.htm#IDX105">(105)</A>
<LI>Java code 
<A HREF="STAFUG.htm#IDX748">(748)</A>
<LI>Rexx API 
<MENU>
<LI>STAFLog 
<A HREF="STAFUG.htm#IDX216">(216)</A>
<LI>STAFMon 
<A HREF="STAFUG.htm#IDX211">(211)</A>
<LI>STAFPool 
<A HREF="STAFUG.htm#IDX221">(221)</A>
<LI>STAFRegister 
<A HREF="STAFUG.htm#IDX196">(196)</A>
<LI>STAFSubmit 
<A HREF="STAFUG.htm#IDX206">(206)</A>
<LI>STAFUnRegister 
<A HREF="STAFUG.htm#IDX201">(201)</A>
<LI>STAFUtil 
<A HREF="STAFUG.htm#IDX226">(226)</A>
</MENU>
<LI>Rexx code 
<A HREF="STAFUG.htm#IDX753">(753)</A>
<LI>STAFSubmit2 
<A HREF="STAFUG.htm#IDX148">(148)</A>
<LI>trust 
<A HREF="STAFUG.htm#IDX93">(93)</A>
</MENU>
</MENU>
<STRONG><A NAME="IDX1_46" HREF="#IDX0_46">F</A></STRONG>
<MENU>
<LI>file system service 
<A HREF="STAFUG.htm#IDX272">(272)</A>
<LI>FmtLog command 
<A HREF="STAFUG.htm#IDX731">(731)</A>
<LI>Formatting STAF Logs as Html or Text 
<A HREF="STAFUG.htm#IDX722">(722)</A>
</MENU>
<STRONG><A NAME="IDX1_48" HREF="#IDX0_48">H</A></STRONG>
<MENU>
<LI>handle service 
<A HREF="STAFUG.htm#IDX314">(314)</A>
<LI>handles 
<MENU>
<LI>concepts 
<A HREF="STAFUG.htm#IDX4">(4)</A>
</MENU>
<LI>help service 
<A HREF="STAFUG.htm#IDX335">(335)</A>
</MENU>
<STRONG><A NAME="IDX1_49" HREF="#IDX0_49">I</A></STRONG>
<MENU>
<LI>installation 
<MENU>
<LI>Registration 
<A HREF="STAFUG.htm#IDX29">(29)</A>
</MENU>
</MENU>
<STRONG><A NAME="IDX1_4A" HREF="#IDX0_4A">J</A></STRONG>
<MENU>
<LI>Java code 
<A HREF="STAFUG.htm#IDX744">(744)</A>
<LI>JVM Log Viewer 
<A HREF="STAFUG.htm#IDX713">(713)</A>
</MENU>
<STRONG><A NAME="IDX1_4C" HREF="#IDX0_4C">L</A></STRONG>
<MENU>
<LI>lifecycle service 
<A HREF="STAFUG.htm#IDX352">(352)</A>
<LI>log service 
<A HREF="STAFUG.htm#IDX383">(383)</A>
<LI>Log Utilities 
<A HREF="STAFUG.htm#IDX702">(702)</A>
<LI>Log Viewer 
<A HREF="STAFUG.htm#IDX704">(704)</A>
<LI>logging levels 
<A HREF="STAFUG.htm#IDX410">(410)</A>
</MENU>
<STRONG><A NAME="IDX1_4D" HREF="#IDX0_4D">M</A></STRONG>
<MENU>
<LI>machine name 
<A HREF="STAFUG.htm#IDX32">(32)</A>
<LI>marshalling 
<MENU>
<LI>STAFMapClassDefinition C++ class 
<A HREF="STAFUG.htm#IDX187">(187)</A>
<LI>STAFObject C++ class 
<A HREF="STAFUG.htm#IDX175">(175)</A>
</MENU>
<LI>misc service 
<A HREF="STAFUG.htm#IDX413">(413)</A>
<LI>monitor service 
<A HREF="STAFUG.htm#IDX437">(437)</A>
</MENU>
<STRONG><A NAME="IDX1_4E" HREF="#IDX0_4E">N</A></STRONG>
<MENU>
<LI>network interfaces 
<A HREF="STAFUG.htm#IDX38">(38)</A>, <A HREF="STAFUG.htm#IDX43">(43)</A>
</MENU>
<STRONG><A NAME="IDX1_4F" HREF="#IDX0_4F">O</A></STRONG>
<MENU>
<LI>Operational parameters 
<A HREF="STAFUG.htm#IDX81">(81)</A>
<LI>overview 
<A HREF="STAFUG.htm#IDX1">(1)</A>
</MENU>
<STRONG><A NAME="IDX1_50" HREF="#IDX0_50">P</A></STRONG>
<MENU>
<LI>parameters 
<MENU>
<LI>log service 
<A HREF="STAFUG.htm#IDX389">(389)</A>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX526">(526)</A>
</MENU>
<LI>ping service 
<A HREF="STAFUG.htm#IDX461">(461)</A>
<LI>port 
<A HREF="STAFUG.htm#IDX47">(47)</A>
<MENU>
<LI>STAFTCP Connection Provider 
<A HREF="STAFUG.htm#IDX48">(48)</A>
</MENU>
<LI>process 
<MENU>
<LI>Changing User Rights Assignments 
<A HREF="STAFUG.htm#IDX476">(476)</A>
<LI>Starting a process under a different username 
<A HREF="STAFUG.htm#IDX474">(474)</A>
</MENU>
<LI>process service 
<A HREF="STAFUG.htm#IDX467">(467)</A>
<LI>process termination notifications 
<A HREF="STAFUG.htm#IDX492">(492)</A>
</MENU>
<STRONG><A NAME="IDX1_51" HREF="#IDX0_51">Q</A></STRONG>
<MENU>
<LI>queue service 
<A HREF="STAFUG.htm#IDX502">(502)</A>
<LI>queues 
<MENU>
<LI>concepts 
<A HREF="STAFUG.htm#IDX22">(22)</A>
</MENU>
</MENU>
<STRONG><A NAME="IDX1_52" HREF="#IDX0_52">R</A></STRONG>
<MENU>
<LI>Registering 
<A HREF="STAFUG.htm#IDX27">(27)</A>
<LI>registration 
<MENU>
<LI>Authenticator registration 
<A HREF="STAFUG.htm#IDX78">(78)</A>, <A HREF="STAFUG.htm#IDX80">(80)</A>
<LI>Java Service Registration 
<A HREF="STAFUG.htm#IDX54">(54)</A>
<LI>JSTAF 
<A HREF="STAFUG.htm#IDX55">(55)</A>
<LI>log service 
<A HREF="STAFUG.htm#IDX387">(387)</A>
<LI>monitor service 
<A HREF="STAFUG.htm#IDX441">(441)</A>
<LI>notify on shutdown 
<A HREF="STAFUG.htm#IDX616">(616)</A>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX524">(524)</A>
<LI>Service loader registration 
<A HREF="STAFUG.htm#IDX69">(69)</A>
<LI>Service registration 
<A HREF="STAFUG.htm#IDX53">(53)</A>
<LI>STAFHandle C++ class 
<A HREF="STAFUG.htm#IDX167">(167)</A>
<LI>STAFRegister C API 
<A HREF="STAFUG.htm#IDX126">(126)</A>
<LI>STAFRegister Rexx API 
<A HREF="STAFUG.htm#IDX191">(191)</A>
<LI>STAFRegisterUTF8 C API 
<A HREF="STAFUG.htm#IDX133">(133)</A>
<LI>STAFUnRegister C API 
<A HREF="STAFUG.htm#IDX137">(137)</A>
<LI>zip service 
<A HREF="STAFUG.htm#IDX687">(687)</A>
</MENU>
<LI>requirements 
<A HREF="STAFUG.htm#IDX2">(2)</A>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX520">(520)</A>
<LI>Rexx API 
<MENU>
<LI>STAFLog wrapper 
<A HREF="STAFUG.htm#IDX213">(213)</A>
<LI>STAFMon wrapper 
<A HREF="STAFUG.htm#IDX208">(208)</A>
<LI>STAFPool wrapper 
<A HREF="STAFUG.htm#IDX218">(218)</A>
<LI>STAFRegister 
<A HREF="STAFUG.htm#IDX193">(193)</A>
<LI>STAFSubmit 
<A HREF="STAFUG.htm#IDX203">(203)</A>
<LI>STAFUnRegister 
<A HREF="STAFUG.htm#IDX198">(198)</A>
<LI>STAFUtil library 
<A HREF="STAFUG.htm#IDX223">(223)</A>
</MENU>
<LI>Rexx code 
<A HREF="STAFUG.htm#IDX749">(749)</A>
</MENU>
<STRONG><A NAME="IDX1_53" HREF="#IDX0_53">S</A></STRONG>
<MENU>
<LI>samples 
<A HREF="STAFUG.htm#IDX743">(743)</A>
<MENU>
<LI>C code 
<A HREF="STAFUG.htm#IDX756">(756)</A>
<LI>C++ code 
<A HREF="STAFUG.htm#IDX761">(761)</A>
<LI>Java code 
<A HREF="STAFUG.htm#IDX746">(746)</A>
<LI>Rexx code 
<A HREF="STAFUG.htm#IDX751">(751)</A>
</MENU>
<LI>security 
<A HREF="STAFUG.htm#IDX18">(18)</A>
<LI>semaphore service 
<A HREF="STAFUG.htm#IDX556">(556)</A>
<LI>service command reference 
<A HREF="STAFUG.htm#IDX742">(742)</A>
<LI>service commands 
<MENU>
<LI>ADD 
<MENU>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX538">(538)</A>
<LI>service service 
<A HREF="STAFUG.htm#IDX598">(598)</A>
</MENU>
<LI>ADD (aka ZIP) 
<MENU>
<LI>zip service 
<A HREF="STAFUG.htm#IDX693">(693)</A>
</MENU>
<LI>AUTHENTICATE 
<MENU>
<LI>handle service 
<A HREF="STAFUG.htm#IDX331">(331)</A>
</MENU>
<LI>CANCEL 
<MENU>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX553">(553)</A>
<LI>semaphore service 
<A HREF="STAFUG.htm#IDX567">(567)</A>
</MENU>
<LI>COPY 
<MENU>
<LI>file system service 
<A HREF="STAFUG.htm#IDX277">(277)</A>
</MENU>
<LI>COPY DIRECTORY 
<MENU>
<LI>file system service 
<A HREF="STAFUG.htm#IDX280">(280)</A>
</MENU>
<LI>CREATE 
<MENU>
<LI>file system service 
<A HREF="STAFUG.htm#IDX307">(307)</A>
<LI>handle service 
<A HREF="STAFUG.htm#IDX319">(319)</A>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX532">(532)</A>
</MENU>
<LI>DELAY 
<MENU>
<LI>delay service 
<A HREF="STAFUG.htm#IDX247">(247)</A>
</MENU>
<LI>DELETE 
<MENU>
<LI>file system service 
<A HREF="STAFUG.htm#IDX310">(310)</A>
<LI>handle service 
<A HREF="STAFUG.htm#IDX322">(322)</A>
<LI>log service 
<A HREF="STAFUG.htm#IDX403">(403)</A>
<LI>monitor service 
<A HREF="STAFUG.htm#IDX455">(455)</A>
<LI>queue service 
<A HREF="STAFUG.htm#IDX516">(516)</A>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX535">(535)</A>
<LI>semaphore service 
<A HREF="STAFUG.htm#IDX582">(582)</A>
<LI>trust service 
<A HREF="STAFUG.htm#IDX664">(664)</A>
<LI>variable service 
<A HREF="STAFUG.htm#IDX682">(682)</A>
<LI>zip service 
<A HREF="STAFUG.htm#IDX696">(696)</A>
</MENU>
<LI>DISABLE 
<MENU>
<LI>Diagnostics (DIAG) service 
<A HREF="STAFUG.htm#IDX265">(265)</A>
<LI>LifeCycle service 
<A HREF="STAFUG.htm#IDX378">(378)</A>
<LI>TRACE service 
<A HREF="STAFUG.htm#IDX632">(632)</A>
</MENU>
<LI>ECHO 
<MENU>
<LI>echo service 
<A HREF="STAFUG.htm#IDX271">(271)</A>
</MENU>
<LI>ENABLE 
<MENU>
<LI>Diagnostics (DIAG) service 
<A HREF="STAFUG.htm#IDX262">(262)</A>
<LI>LifeCycle service 
<A HREF="STAFUG.htm#IDX375">(375)</A>
<LI>TRACE service 
<A HREF="STAFUG.htm#IDX627">(627)</A>
</MENU>
<LI>ERROR 
<MENU>
<LI>help service 
<A HREF="STAFUG.htm#IDX343">(343)</A>
</MENU>
<LI>FREE 
<MENU>
<LI>process service 
<A HREF="STAFUG.htm#IDX491">(491)</A>
<LI>service service 
<A HREF="STAFUG.htm#IDX603">(603)</A>
</MENU>
<LI>GET 
<MENU>
<LI>queue service 
<A HREF="STAFUG.htm#IDX510">(510)</A>
<LI>trust service 
<A HREF="STAFUG.htm#IDX658">(658)</A>
<LI>variable service 
<A HREF="STAFUG.htm#IDX673">(673)</A>
</MENU>
<LI>GET ENTRY 
<MENU>
<LI>file system service 
<A HREF="STAFUG.htm#IDX292">(292)</A>
</MENU>
<LI>GET FILE 
<MENU>
<LI>file system service 
<A HREF="STAFUG.htm#IDX289">(289)</A>
</MENU>
<LI>KILL 
<MENU>
<LI>process service 
<A HREF="STAFUG.htm#IDX482">(482)</A>
</MENU>
<LI>LIST 
<MENU>
<LI>Diagnostics (DIAG) service 
<A HREF="STAFUG.htm#IDX256">(256)</A>
<LI>handle service 
<A HREF="STAFUG.htm#IDX325">(325)</A>
<LI>help service 
<A HREF="STAFUG.htm#IDX340">(340)</A>
<LI>LifeCycle service 
<A HREF="STAFUG.htm#IDX366">(366)</A>
<LI>log service 
<A HREF="STAFUG.htm#IDX400">(400)</A>
<LI>misc service 
<A HREF="STAFUG.htm#IDX427">(427)</A>
<LI>monitor service 
<A HREF="STAFUG.htm#IDX452">(452)</A>
<LI>process service 
<A HREF="STAFUG.htm#IDX485">(485)</A>
<LI>queue service 
<A HREF="STAFUG.htm#IDX519">(519)</A>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX529">(529)</A>
<LI>semaphore service 
<A HREF="STAFUG.htm#IDX588">(588)</A>
<LI>service service 
<A HREF="STAFUG.htm#IDX593">(593)</A>
<LI>TRACE service 
<A HREF="STAFUG.htm#IDX642">(642)</A>
<LI>trust service 
<A HREF="STAFUG.htm#IDX661">(661)</A>
<LI>variable service 
<A HREF="STAFUG.htm#IDX676">(676)</A>
<LI>zip service 
<A HREF="STAFUG.htm#IDX699">(699)</A>
</MENU>
<LI>LIST COPYREQUESTS 
<MENU>
<LI>file system service 
<A HREF="STAFUG.htm#IDX301">(301)</A>
</MENU>
<LI>LIST DIRECTORY 
<MENU>
<LI>file system service 
<A HREF="STAFUG.htm#IDX298">(298)</A>
</MENU>
<LI>LIST SETTINGS 
<MENU>
<LI>file system service 
<A HREF="STAFUG.htm#IDX304">(304)</A>
</MENU>
<LI>LOG 
<MENU>
<LI>log service 
<A HREF="STAFUG.htm#IDX394">(394)</A>
<LI>monitor service 
<A HREF="STAFUG.htm#IDX446">(446)</A>
</MENU>
<LI>MOVE 
<MENU>
<LI>file system service 
<A HREF="STAFUG.htm#IDX283">(283)</A>, <A HREF="STAFUG.htm#IDX286">(286)</A>
</MENU>
<LI>NOTIFY LIST 
<MENU>
<LI>process service 
<A HREF="STAFUG.htm#IDX498">(498)</A>
<LI>shutdown service 
<A HREF="STAFUG.htm#IDX619">(619)</A>
</MENU>
<LI>NOTIFY REGISTER/UNREGISTER 
<MENU>
<LI>process service 
<A HREF="STAFUG.htm#IDX495">(495)</A>
<LI>shutdown service 
<A HREF="STAFUG.htm#IDX614">(614)</A>
</MENU>
<LI>PEEK 
<MENU>
<LI>queue service 
<A HREF="STAFUG.htm#IDX513">(513)</A>
</MENU>
<LI>PING 
<MENU>
<LI>ping service 
<A HREF="STAFUG.htm#IDX466">(466)</A>
</MENU>
<LI>POST 
<MENU>
<LI>semaphore service 
<A HREF="STAFUG.htm#IDX570">(570)</A>
</MENU>
<LI>PULSE 
<MENU>
<LI>semaphore service 
<A HREF="STAFUG.htm#IDX576">(576)</A>
</MENU>
<LI>PURGE 
<MENU>
<LI>log service 
<A HREF="STAFUG.htm#IDX406">(406)</A>
<LI>misc service 
<A HREF="STAFUG.htm#IDX436">(436)</A>
<LI>TRACE service 
<A HREF="STAFUG.htm#IDX637">(637)</A>
</MENU>
<LI>QUERY 
<MENU>
<LI>file system service 
<A HREF="STAFUG.htm#IDX295">(295)</A>
<LI>handle service 
<A HREF="STAFUG.htm#IDX328">(328)</A>
<LI>LifeCycle service 
<A HREF="STAFUG.htm#IDX369">(369)</A>
<LI>log service 
<A HREF="STAFUG.htm#IDX397">(397)</A>
<LI>misc service 
<A HREF="STAFUG.htm#IDX430">(430)</A>
<LI>monitor service 
<A HREF="STAFUG.htm#IDX449">(449)</A>
<LI>process service 
<A HREF="STAFUG.htm#IDX488">(488)</A>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX544">(544)</A>
<LI>semaphore service 
<A HREF="STAFUG.htm#IDX585">(585)</A>
<LI>service service 
<A HREF="STAFUG.htm#IDX595">(595)</A>
</MENU>
<LI>QUEUE 
<MENU>
<LI>queue service 
<A HREF="STAFUG.htm#IDX507">(507)</A>
</MENU>
<LI>RECORD 
<MENU>
<LI>Diagnostics (DIAG) service 
<A HREF="STAFUG.htm#IDX253">(253)</A>
</MENU>
<LI>REGISTER 
<MENU>
<LI>help service 
<A HREF="STAFUG.htm#IDX346">(346)</A>
<LI>LifeCycle service 
<A HREF="STAFUG.htm#IDX357">(357)</A>
</MENU>
<LI>RELEASE 
<MENU>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX550">(550)</A>
<LI>semaphore service 
<A HREF="STAFUG.htm#IDX564">(564)</A>
</MENU>
<LI>REMOVE 
<MENU>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX541">(541)</A>
<LI>service service 
<A HREF="STAFUG.htm#IDX601">(601)</A>
</MENU>
<LI>REQUEST 
<MENU>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX547">(547)</A>
<LI>semaphore service 
<A HREF="STAFUG.htm#IDX561">(561)</A>
</MENU>
<LI>RESET 
<MENU>
<LI>Diagnostics (DIAG) service 
<A HREF="STAFUG.htm#IDX259">(259)</A>
<LI>semaphore service 
<A HREF="STAFUG.htm#IDX573">(573)</A>
</MENU>
<LI>RESOLVE 
<MENU>
<LI>variable service 
<A HREF="STAFUG.htm#IDX679">(679)</A>
</MENU>
<LI>SAVE 
<MENU>
<LI>config service 
<A HREF="STAFUG.htm#IDX241">(241)</A>
</MENU>
<LI>SET 
<MENU>
<LI>file system service 
<A HREF="STAFUG.htm#IDX313">(313)</A>
<LI>log service 
<A HREF="STAFUG.htm#IDX409">(409)</A>
<LI>misc service 
<A HREF="STAFUG.htm#IDX433">(433)</A>
<LI>monitor service 
<A HREF="STAFUG.htm#IDX458">(458)</A>
<LI>process service 
<A HREF="STAFUG.htm#IDX501">(501)</A>
<LI>TRACE service 
<A HREF="STAFUG.htm#IDX647">(647)</A>
<LI>trust service 
<A HREF="STAFUG.htm#IDX655">(655)</A>
<LI>variable service 
<A HREF="STAFUG.htm#IDX670">(670)</A>
</MENU>
<LI>SHUTDOWN 
<MENU>
<LI>shutdown service 
<A HREF="STAFUG.htm#IDX609">(609)</A>
</MENU>
<LI>START 
<MENU>
<LI>process service 
<A HREF="STAFUG.htm#IDX472">(472)</A>
</MENU>
<LI>STOP 
<MENU>
<LI>process service 
<A HREF="STAFUG.htm#IDX479">(479)</A>
</MENU>
<LI>TRIGGER 
<MENU>
<LI>LifeCycle service 
<A HREF="STAFUG.htm#IDX372">(372)</A>
</MENU>
<LI>UNAUTHENTICATE 
<MENU>
<LI>handle service 
<A HREF="STAFUG.htm#IDX334">(334)</A>
</MENU>
<LI>UNREGISTER 
<MENU>
<LI>help service 
<A HREF="STAFUG.htm#IDX349">(349)</A>
<LI>LifeCycle service 
<A HREF="STAFUG.htm#IDX360">(360)</A>
</MENU>
<LI>UNZIP 
<MENU>
<LI>zip service 
<A HREF="STAFUG.htm#IDX690">(690)</A>
</MENU>
<LI>UPDATE 
<MENU>
<LI>LifeCycle service 
<A HREF="STAFUG.htm#IDX363">(363)</A>
</MENU>
<LI>VERSION 
<MENU>
<LI>misc service 
<A HREF="STAFUG.htm#IDX418">(418)</A>
</MENU>
<LI>WAIT 
<MENU>
<LI>semaphore service 
<A HREF="STAFUG.htm#IDX579">(579)</A>
</MENU>
<LI>WHOAMI 
<MENU>
<LI>misc service 
<A HREF="STAFUG.htm#IDX421">(421)</A>
</MENU>
<LI>WHOAREYOU 
<MENU>
<LI>misc service 
<A HREF="STAFUG.htm#IDX424">(424)</A>
</MENU>
</MENU>
<LI>Service loader registration 
<A HREF="STAFUG.htm#IDX10">(10)</A>, <A HREF="STAFUG.htm#IDX65">(65)</A>
<LI>Service Loaders 
<MENU>
<LI>Default Service Loader Service (STAFDSLS) 
<A HREF="STAFUG.htm#IDX71">(71)</A>
<LI>HTTP Service Loader Service (STAFHTTPSLS) 
<A HREF="STAFUG.htm#IDX73">(73)</A>
</MENU>
<LI>service logging 
<MENU>
<LI>LifeCycle service 
<A HREF="STAFUG.htm#IDX382">(382)</A>
</MENU>
<LI>Service registration 
<A HREF="STAFUG.htm#IDX49">(49)</A>
<LI>services 
<MENU>
<LI>authenticator 
<A HREF="STAFUG.htm#IDX12">(12)</A>
<LI>config service 
<A HREF="STAFUG.htm#IDX238">(238)</A>
<LI>delay service 
<A HREF="STAFUG.htm#IDX244">(244)</A>
<LI>Diagnostics (DIAG) service 
<A HREF="STAFUG.htm#IDX250">(250)</A>
<LI>echo service 
<A HREF="STAFUG.htm#IDX268">(268)</A>
<LI>file system service 
<A HREF="STAFUG.htm#IDX274">(274)</A>
<LI>general 
<A HREF="STAFUG.htm#IDX228">(228)</A>
<MENU>
<LI>concepts 
<A HREF="STAFUG.htm#IDX7">(7)</A>
<LI>description 
<A HREF="STAFUG.htm#IDX229">(229)</A>
<LI>option value formats 
<A HREF="STAFUG.htm#IDX231">(231)</A>
<LI>private data 
<A HREF="STAFUG.htm#IDX232">(232)</A>
<LI>service help 
<A HREF="STAFUG.htm#IDX235">(235)</A>
<LI>service result definition 
<A HREF="STAFUG.htm#IDX234">(234)</A>
<LI>syntax 
<A HREF="STAFUG.htm#IDX230">(230)</A>
<LI>variable resolution 
<A HREF="STAFUG.htm#IDX233">(233)</A>
</MENU>
<LI>handle service 
<A HREF="STAFUG.htm#IDX316">(316)</A>
<LI>help service 
<A HREF="STAFUG.htm#IDX337">(337)</A>
<LI>LifeCycle service 
<A HREF="STAFUG.htm#IDX354">(354)</A>
<LI>log service 
<A HREF="STAFUG.htm#IDX385">(385)</A>
<LI>misc service 
<A HREF="STAFUG.htm#IDX415">(415)</A>
<LI>monitor service 
<A HREF="STAFUG.htm#IDX439">(439)</A>
<LI>ping service 
<A HREF="STAFUG.htm#IDX463">(463)</A>
<LI>process service 
<A HREF="STAFUG.htm#IDX469">(469)</A>
<LI>queue service 
<A HREF="STAFUG.htm#IDX504">(504)</A>
<LI>Resource Pool service 
<A HREF="STAFUG.htm#IDX522">(522)</A>
<LI>semaphore service 
<A HREF="STAFUG.htm#IDX558">(558)</A>
<LI>service loader 
<A HREF="STAFUG.htm#IDX9">(9)</A>
<LI>service service 
<A HREF="STAFUG.htm#IDX590">(590)</A>
<LI>shutdown service 
<A HREF="STAFUG.htm#IDX606">(606)</A>
<LI>trace service 
<A HREF="STAFUG.htm#IDX622">(622)</A>
<LI>trust service 
<A HREF="STAFUG.htm#IDX652">(652)</A>
<LI>variable service 
<A HREF="STAFUG.htm#IDX667">(667)</A>
<LI>zip service 
<A HREF="STAFUG.htm#IDX685">(685)</A>
</MENU>
<LI>shutdown service 
<A HREF="STAFUG.htm#IDX604">(604)</A>
<LI>STAF command 
<A HREF="STAFUG.htm#IDX121">(121)</A>
<LI>STAFJVMLogViewer command 
<A HREF="STAFUG.htm#IDX714">(714)</A>
<LI>STAFLogFormatter command 
<A HREF="STAFUG.htm#IDX723">(723)</A>
<LI>STAFLogViewer command 
<A HREF="STAFUG.htm#IDX705">(705)</A>
<LI>STAFProc command 
<A HREF="STAFUG.htm#IDX118">(118)</A>
<LI>STAFTCP 
<A HREF="STAFUG.htm#IDX45">(45)</A>
<LI>start/shutdown notifications 
<MENU>
<LI>configuration 
<A HREF="STAFUG.htm#IDX97">(97)</A>
<LI>shutdown service 
<A HREF="STAFUG.htm#IDX611">(611)</A>
</MENU>
<LI>strings 
<MENU>
<LI>concepts 
<A HREF="STAFUG.htm#IDX26">(26)</A>
</MENU>
</MENU>
<STRONG><A NAME="IDX1_54" HREF="#IDX0_54">T</A></STRONG>
<MENU>
<LI>TCP/IP 
<A HREF="STAFUG.htm#IDX46">(46)</A>
<LI>trace service 
<A HREF="STAFUG.htm#IDX620">(620)</A>
<LI>tracing 
<MENU>
<LI>configuration 
<A HREF="STAFUG.htm#IDX101">(101)</A>
<LI>hexadecimal trace points 
<A HREF="STAFUG.htm#IDX624">(624)</A>
<LI>trace service 
<A HREF="STAFUG.htm#IDX629">(629)</A>, <A HREF="STAFUG.htm#IDX634">(634)</A>, <A HREF="STAFUG.htm#IDX639">(639)</A>, <A HREF="STAFUG.htm#IDX644">(644)</A>, <A HREF="STAFUG.htm#IDX649">(649)</A>
</MENU>
<LI>trust 
<MENU>
<LI>configuration 
<A HREF="STAFUG.htm#IDX91">(91)</A>
<LI>levels 
<A HREF="STAFUG.htm#IDX20">(20)</A>
</MENU>
<LI>trust service 
<A HREF="STAFUG.htm#IDX650">(650)</A>
<LI>tuning 
<MENU>
<LI>configuration 
<A HREF="STAFUG.htm#IDX109">(109)</A>
</MENU>
</MENU>
<STRONG><A NAME="IDX1_55" HREF="#IDX0_55">U</A></STRONG>
<MENU>
<LI>Unix STAF Temporary Directory 
<MENU>
<LI>configuration 
<A HREF="STAFUG.htm#IDX117">(117)</A>
</MENU>
<LI>utilities 
<MENU>
<LI>format log 
<A HREF="STAFUG.htm#IDX735">(735)</A>
<LI>Format STAF log as Html or Text 
<A HREF="STAFUG.htm#IDX727">(727)</A>
<LI>View STAF JVM log 
<A HREF="STAFUG.htm#IDX718">(718)</A>
<LI>View STAF log 
<A HREF="STAFUG.htm#IDX709">(709)</A>
</MENU>
<LI>utility commands 
<MENU>
<LI>FmtLog 
<MENU>
<LI>FmtLog utility 
<A HREF="STAFUG.htm#IDX738">(738)</A>
</MENU>
<LI>STAFJVMLogViewer 
<MENU>
<LI>STAFJVMLogViewer utility 
<A HREF="STAFUG.htm#IDX721">(721)</A>
</MENU>
<LI>STAFLogFormatter 
<MENU>
<LI>STAFLogFormatter utility 
<A HREF="STAFUG.htm#IDX730">(730)</A>
</MENU>
<LI>STAFLogViewer 
<MENU>
<LI>STAFLogViewer utility 
<A HREF="STAFUG.htm#IDX712">(712)</A>
</MENU>
</MENU>
</MENU>
<STRONG><A NAME="IDX1_56" HREF="#IDX0_56">V</A></STRONG>
<MENU>
<LI>variable service 
<A HREF="STAFUG.htm#IDX665">(665)</A>
<LI>variables 
<MENU>
<LI>concepts 
<A HREF="STAFUG.htm#IDX16">(16)</A>
<LI>configuration 
<A HREF="STAFUG.htm#IDX87">(87)</A>
<LI>log service 
<A HREF="STAFUG.htm#IDX391">(391)</A>
<LI>monitor service 
<A HREF="STAFUG.htm#IDX443">(443)</A>
<LI>predefined 
<A HREF="STAFUG.htm#IDX17">(17)</A>
</MENU>
</MENU>
<STRONG><A NAME="IDX1_57" HREF="#IDX0_57">W</A></STRONG>
<MENU>
<LI>workload 
<MENU>
<LI>concepts 
<A HREF="STAFUG.htm#IDX14">(14)</A>
</MENU>
</MENU>
<STRONG><A NAME="IDX1_5A" HREF="#IDX0_5A">Z</A></STRONG>
<MENU>
<LI>zip service 
<A HREF="STAFUG.htm#IDX683">(683)</A>
</MENU>
<HR><H1><A NAME="HDRSTAFUGEND" HREF="#ToC_996">End Of Document</A></H1>
<P>This is the end of the document.
<A NAME="Bot_Of_Page"></A>
</BODY></HTML>
